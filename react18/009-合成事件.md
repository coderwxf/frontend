合成事件 => synthetic event 

React 的合成事件系统是一个跨浏览器的事件封装层，确保在不同浏览器中表现一致。

```jsx
import { Component } from 'react'

export default class Child extends Component {
  handleClick() {
    // React合成事件处理函数调用方式  => handleClick()
    // 类和模块在编译时自动开启严格模式 => 所以合成事件处理函数中this的值默认是undefined
    console.log(this) // => undefined
  }

  render() {
    return (
      <>
        {/* 合成事件 命名格式 onXxxx */}
        <button onClick={this.handleClick}>click</button>
      </>
    )
  }
}
```



## 修正this

1. bind => 不推荐 => 可以预处理this和传参，但语义化不佳

   ```jsx
   <button onClick={this.handleClick.bind(this)}>click</button>
   ```

2. 类成员表达式 => 不推荐 => 事件被挂载到了实例上 且传参不便

   ```jsx
   import { Component } from 'react'
   
   export default class Child extends Component {
     handleClick= (num1, num2, e) => {
       console.log(this, num1, num2, e)
     }
   
     render() {
       return (
         <>
         	{/* 这里的this不重要 使用null或undefined占位 */}
           <button onClick={this.handleClick.bind(null, 10, 20)}>click</button>
         </>
       )
     }
   }
   ```

3. 箭头函数 => 推荐

   ```jsx
   {/* 
   	1. 调用合成事件时，React会自动传入合成事件对象
   	2. e.nativeEvent => 对应原生事件处理对象
   	3. 原生event 有stopImmediatePropergation => 合成事件没有 
   */}
   <button onClick={e => this.handleClick(e)}>click</button>
   
   {/* 在捕获阶段触发回调 */}
   <button onClickCapture={e => this.handleClick(e)}>click</button>
   ```

 

## 事件绑定

DOM0级事件绑定  => `el.onclick`

1. `onxxx` => 全小写
2. 本质是属性 => 不能同时绑定多个事件处理函数
3. 移除事件  => `el.onxxxx = null`



DOM2级事件绑定 => `el.xxxEventListener`

1. 可以同时绑定多个事件处理函数 => 组成数组并被依次回调
2. `el.addEventListener(cb) => el.removeEventListener(cb)` => 绑定和移除事件时，回调函数需要是同一个 => 只匹配引用地址



### addEventListener

```js
/*
	type - 事件名 - 没有on
	handler - 事件处理函数
	useCapture - 布尔类型值 - true 「 捕获阶段触发 」 | false 「 冒泡阶段触发 」- 默认值是false
*/
el.addEventListener(type, handler, useCapture)
```

```js
/*
	type options = {
		capture: boolean // => 默认值 false
		once: boolean // => 默认值 false
		passive: boolean // => 默认值 false => 禁止调用preventDefault()，依旧调用会在控制台抛出警告
	}
*/
el.addEventListener(type, handler, options)
```



## 事件传播

事件传播路径是从 `window -> document -> html -> body -> ... -> 目标元素` 

1. 捕获 => 在捕获阶段分析出事件传播路径
2.  目标 => 触发事件源的捕获和冒泡处理函数
3. 冒泡

```js
handleClick(e) {
  const event = e.nativeEvent

  /*
    在Event实例上存在三个常量
    1. CAPTURING_PHASE - 捕获阶段
    2. AT_TARGET - 目标阶段
    3. BUBBLING_PHASE - 冒泡阶段
  */
  console.log(event.eventPhase) // number类型值 => 表示事件执行时处于哪一个阶段
  
  // 获取事件传播路径 -> 是从target开始向外的路径 即以冒泡路径为t
  console.log(event.composedPath()) // => [button, div#root, body, html, document, Window]
}
```



出现交互，就会触发对应事件

1. 如果事件存在响应函数就会去触发对应事件处理函数
2. 即使没有事件处理函数，对应事件依旧会被触发



`stopPropagation` => 阻止事件传播 「 包括冒泡传播，捕获传播和目标阶段传播  」

DOM2级事件绑定可以在一个元素上绑定多个事件回调，多个事件回调会组成数组并被依次回调

```js
e.stopPropagation() // => 当前元素冒泡回调数组中事件全部处理完毕后，再阻止冒泡行为

e.stopImmediatePropagation() // => 立即阻止冒泡行为，即使冒泡回调数组中还存在没有被执行的回调函数
```

```js
handleClick(e) {
  const event = e.nativeEvent

  // 无论stopProgation还是stopImmediatePropagation都是当前所在回调函数执行完毕后再阻止冒泡行为
  event.stopProgation()
  console.log(event) // 事件对象依旧可以被正常打印
}
```



 事件传播机制的意义是实现事件委托

1. 可以减少需要获取的DOM元素和需要绑定的事件处理函数 => 提升JavaScript运行性能 
2. 如果新增了子元素，可以不用再单独为子元素添加事件处理函数 => 会自动传播到父元素这
3. 某些需求必须通过事件委托处理 => 除了A做xxx，其余都执行yyy => 减少了重复代码的编写 



事件传播的局限性:

1. 并不是所有的事件都支持事件传播 「 例如 `mouseEnter/mouseLeave` 」
2. 如果子元素存在自己的事件处理函数，并在其中阻止了事件传播，则事件委托处理函数将不会再执行

 

## 实现原理

不是给当前元素单独进行DOM2级事件绑定，React中的合成事件都是基于事件委托进行处理的

所以给循环元素绑定事件，React无需手动实现事件委托，而Vue需要手动实现事件委托



```jsx
<button
  onClick={() => console.log('click')}
  onClickCapture={() => console.log('click capture')}
>
  click
</button>
```

会被编译为

```js
const reactElement = {
  $$typeof: Symbol('react.element'),
  key: null,
  ref: null,
  type: 'button',
  props: {
    children: 'click',
    // 事件绑定会作为props属性被挂载 - onXxxx 和 onXxxxCapture 这类属性可以被称之为合成事件属性
    onClick: () => console.log('click'),
    onClickCapture: () => console.log('click capture')
  }
};
```



React17 及以后:

1. 委托给挂载容器 `#root`
2. 冒泡和捕获 都进行了 委托
3. 不支持事件传播的事件，单独绑定在元素本身上

```js
// 伪代码 - 仅实现点击事件
const root = document.querySelector('#root'),
      outer = document.querySelector('#outer'),
      inner = document.querySelector('#inner');

// 经过视图渲染解析，outer/inner上都有onXxx/onXxxCapture这样的属性
//「 实际代码是执行VDOM上的对应onXxx/onXxxCapture { onXxx/onXxxCapture并没有被挂载到DOM上 } 」
outer.onClick = () => { console.log('outer 冒泡「合成」'); }
outer.onClickCapture = () => { console.log('outer 捕获「合成」'); }
inner.onClick = () => { console.log('inner 冒泡「合成」'); }
inner.onClickCapture = () => { console.log('inner 捕获「合成」'); }

// 伪函数 功能: 将传入的原生事件对象转换为React合成事件对象
function covertEvent(e) { .... }

// 给#root做事件绑定
root.addEventListener('click', e => {
  [...e.composedPath()].reverse().forEach(el => {
    if (el.onClickCapture) {
      // 是默认函数调用 不是 el.onClickCapture -> 所以合成事件默认this是undefined
      onClickCapture(covertEvent(e))
    }
  })

}, true);

root.addEventListener('click', e => {
  e.composedPath().forEach(el => {
    if (el.onClick) {
      onClick(covertEvent(e))
    }
  })
}, false);
```



React17  以前:

1. 委托给document元素
2. 捕获阶段的合成事件和冒泡阶段的合成事件 全都被挂载到了 document的冒泡阶段处理函数中
3. 不支持事件传播的事件，单独绑定在元素本身上

```js
document.addEventListener('click',(ev)=>{
  // ev: 原生事件对象
  let path=ev.composedPath();  // 传播路径：[事件源->...->window]
  let syntheticEv=处理事件对象(ev);
  
  // 把捕获阶段的合成事件执行
  [...path].reverse().forEach(ele=>{
    let handle=ele.onClickCapture;
    if(handle) handle(syntheticEv);
  });
  
  // 把冒泡阶段的合成事件执行
  path.forEach(ele=>{
    let handle=ele.onClick;
    if(handle) handle(syntheticEv);
  });
},false);
```





## 阻止传播

```jsx
import { Component } from 'react'

export default class Child extends Component {
  render() {
    return (
      <>
        <div id="outer" onClick={e => this.handleOuterClick(e)}>
          <div id="inner" onClick={e => this.handleInnerClick(e)}>
            click
          </div>
        </div>
      </>
    )
  }

  handleOuterClick() {
    console.log('合成 Outer')
  }

  handleInnerClick(e) {
    console.log('合成 Inner')
  }

  componentDidMount() {
    document.getElementById('root').addEventListener('click', () => {
      console.log('root 原生')
    })

    document.body.addEventListener('click', () => {
      console.log('body 原生')
    })
  }
}
```

实现效果: 

1. 如果不阻止传播 => `合成 Inner -> 合成 Outer -> root 原生 -> body 原生`
2. 如果在`Inner`中调用了`e.stopPropagation() ` => `合成 Inner -> root 原生`
3. 如果在`Inner`中调用了`e.nativeEvent.stopPropagation()` => `合成 Inner -> 合成 Outer -> root 原生`
4. 如果在`Inner`中调用了`e.nativeEvent.stopImmediatePropagation()` => ``合成 Inner -> 合成 Outer`



总结如下:

1. 合成事件的阻止冒泡可以阻止合成事件传播也可以阻止默认事件传播

2. 原生事件的阻止冒泡只能阻止原生事件传播，无法阻止合成事件传播

3. 对于`root`的事件绑定，React绑定的事件 一定先于 我们自己绑定的原生事件回调

4. 无论合成事件还是原生事件都无法阻止 `root`上绑定的原生事件回调 

   「 原生阻止使用的还是原生的`stopPropagation`方法，只不过加了合成事件的特殊处理 」

   如果要阻止`root`上绑定的原生事件回调，需要使用`e.nativeEvent.stopImmediatePropagation()`



## 事件对象池

在React 16及之前的版本中，React使用事件对象池来优化合成事件的创建和销毁。当事件被触发时，React会检查事件池中是否有可用的合成事件对象。如果没有，就创建一个新的；如果有，就重复使用。当事件处理完成后，合成事件对象会被重置并返回池中。

由于这个机制，如果在事件处理函数中执行异步操作（例如`setTimeout`或`Promise`），直接访问合成事件对象可能会导致问题，因为对象可能已经被重置。为了解决这个问题，可以调用`e.persist()`方法，防止合成事件对象被回收。

在React 17及之后的版本中，事件对象池被移除，因此开发者不再需要使用`e.persist()`，这使得合成事件的使用更加简单和直观。



## 300ms延迟

在过去，移动浏览器通常会有一个300ms的延迟，以区分单击和双击操作，这是因为双击通常用于缩放网页。

然而，现代浏览器在理想视口（即没有缩放的视口）下，已经取消了这个延迟

```html
<!-- 双击缩放被禁用, 依旧可以手指缩放（即双指缩放） -->
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- 所有缩放功能都被禁用，包括手指缩放和双击缩放 -->
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
```

或者通过CSS属性

```css
touch-action: manipulation /* 双击缩放被禁用, 依旧可以手指缩放（即双指缩放) */
```





----

https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal