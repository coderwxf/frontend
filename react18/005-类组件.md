## 类基本使用

```js
class Parent {
  // 类成员变量写法 「 依旧挂载实例上 」
  num = 0;
  // 私有属性必须先通过类成员表达式进行声明后才能使用
  #msg = 'running' // #开头的属性是私有属性 「 只能在当前类中使用 」
  
  static call() {} // 静态方法「 类方法 」=> 不可枚举
  static calssName = 'className' // 静态属性 「 类属性 」

  // new的时候，会自动调用构造函数
  constructor(x, y) {
    // this->创建的实例
    this.num = x + y;
  }

  // 方法会自动挂载原型上 「 且是不可枚举的 」
  run() {
    console.log(this.#msg)
  }

  study = () => {
    // class后边的大括号会生成块级作用域 「 箭头函数study内this，会找到组件实例 」
    // 可以理解为成员表达式写法 解析时会移动到构造函数中执行
    console.log(this)
  } // 会被挂载到实例上
}

// 如果要往类原型上加属性 => 只能在类外部添加
Parent.prototype.msg = 'prototype message'
```

默认情况下，不使用构造函数，构造函数可以省略，存在如下默认构造函数

```js
constructor() { }
```



```js
// react的Component组件实现伪代码
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
```

因为继承属性使用的是借用父类构造函数继承「 call继承 」，所以子类会存在通用实例属性`props`、`context`、`refs`和`updater` 「 更新队列 」

顺着原型链向上查找，一定会找到`Component.prototype`，所以会存在方法`forceUpdate`、`setState`和属性`isReactCompoent`

```js
// extends关键字实现继承
class Child extends Parent {
  constructor(childName) {
    // 在子类构造方法中使用this之前必须通过super方法调用父类构造方法
    // 以确保JS可以转换为借用构造函数继承 和 借用原型链继承
    super() // 调用父类构造函数
    this.childName = childName
  }

  childRunning() {
    super.running() // 调用父类实例方法
  }

  static childStudying() {
    super.studying() // 调用父类静态方法
  }
}
```

实现继承后，默认实现的构造函数变成了

```js
constructor(...args) {
  super(...args)
}
```



## 类组件

```js
import { Component } from 'react'

// 一个类只要继承自PureComponent 或 Component 才能是类组件
// Component和PureComponent 在react中被直接导出了，同时也被挂载到了rect对象上 「 可以通过解构获取 」
export default class App extends Component {
  // 类组件中只有render方法是必传的，返回需要渲染的JSX元素
  render() {
    return (
      <>
        This is a class component
      </>
    )
  }
}
```



render函数在渲染的时候，如果type是：

+ 字符串 => 创建标签
+ 普通函数 => `组件(props)`
+ 类 => `new 组件(props)` => 传入的是包含所有props和children的props对象



函数每次调用都会生成新的函数执行上下文，类每次调用都会生成单独的实例 => 组件可以被多次调用

类组件在渲染时会执行render方法，将返回的JSX作为视图进行渲染



## 接收props

通过`super`方法进行初始化

1. 本质是借用构造函数继承 => props会被挂载到组件实例上
2. props依旧是单向数据流  => props是被冻结的 => 只读的

```jsx
export default class App extends Component {
  constructor(props) {
    super(props)

    console.log(this.props)
  }

  render() {
    return (
      <>
        This is a class component
      </>
    )
  }
}
```



不通过`super()`初始化props，react内部也会在初始化类后自动进行props初始化

1. `constructor`中无法获取props
2. 其余方法中，只要this是组件实例，就可以正确获取props

```js
import { Component } from 'react'

export default class App extends Component {
  constructor() {
    super()

    console.log(this.props) // undefined
  }

  // render方法中this一定是组件实例
  render() {
    console.log(this.props) // 可以正常获取

    return (
      <>
        This is a class component
      </>
    )
  }
}
```



## 规则校验

```jsx
import { Component } from 'react'
import PropTypes from 'prop-types'

export default class Child extends Component {
  static defaultProps = {
    age: 18
  }

  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number
  }

  render() {
    const { name, age } = this.props

    return (
      <>
        <h2>{ name }</h2>
        <h3>{ age }</h3>
      </>
    )
  }
}
```



## 状态

1. 状态是一种特殊数据
2. 状态改变会导致界面重新渲染
3. 通过`state`挂载属性 => `state`的默认值是`null`

```js
class Parent {
  constructor(props) {
    super(props)

    this.state = {
      // 定义状态
    }
  }
}
```

可以简写为

```js
class Parent {
  state = {
    // 定义状态
  }
}
```



### setState

React不存在响应式

1. 直接修改状态，界面不会更新 「 `this.state.xxx = yyy`是错误的 」
   + react没有向vue那样对状态进行数据劫持
   + 以在修改状态时，触发setter，并在setter中通知视图更新
2. 需要通过`this.state(partialState)`来修改状态
   + `setState`  会做两件事 => 更新状态 + 更新视图
   + 内部会执行`Object.assign(state, partialState)` => 支持部分更新

```jsx
export default class Child extends Component {
  state = {
    count: 0
  }

  render() {
    const { count } = this.state

    return (
      <>
        <div>{ count }</div>
        {/*
          onClick
          1. 需要是小驼峰写法 => 因为是react中的合成事件
          2. 绑定的值 需要是一个函数 => 不支持像vue那样直接绑定函数调用
        */}
        <button onClick={ () => this.setState({ count: count + 1 }) }>add</button>
      </>
    )
  }
}
```



### forceUpdate

`forceUpdate`会跳过`SCU`, 直接执行`render` 

1. 全量生成`VDOM` 并进行 `DOM-DIFF`
2. 根据`DOM-DIFF`后是否存在`PATCH`来决定是否需要更新

```jsx
export default class Child extends Component {
  state = {
    count: 0
  }

  /*
    自定义事件处理函数
    => 自定义事件调用方式类似于 updateCount() => 不是通过组件实例.updateCount()调用
    => 类和模块解析会自动开启严格模式 => 自定义事件中this等于undefined
  */
  updateCount() {
    this.state.count++
    this.forceUpdate() // 强制更新视图
  }

  render() {
    const { count } = this.state

    return (
      <>
        <div>{ count }</div>
        {/*
          自定义方法 => 需要修正this
        */}
        <button onClick={ () => this.updateCount() }>add</button>
      </>
    )
  }
}
```



## 生命周期

1. 预设的一系列回调函数
2. 这些函数会在组件执行的某些关键时刻被React回调
3. 从而实现一些自定义的业务逻辑 => 也就是执行组件渲染和更新之外的一系列副作用操作



### 老版本

![image.png](https://s2.loli.net/2024/09/24/bkeFHJAfCavu5zD.png) 



### 新版本

![image.png](https://s2.loli.net/2024/09/24/pKU7w1jfJNlkuCg.png)



1. 生命周期构子都是和render同级的函数

2. render是渲染函数 => 组件生命周期过程中的重要函数 => 严格意义上render不是生命周期钩子

3. `componentWillXxxx` => 都是不安全的生命周期 => 一定要使用需要加上`UNSAFE_`前缀

   「 `componentWillUnmount` 是安全的生命周期钩子 」

```jsx
UNSAFE_componentWillMount() {
  // componentWillMount => 已过时 => 控制台会报警告 
  // 『 React严格模式和非React严格模式都是黄色警告 』

  // UNSAFE_componentWillMount => 推荐写法
  // 1. 非React严格模式 => 不出现警告
  // 2. React严格模式 => 控制台抛出红色警告 => 本质是检测了 UNSAFE_ 前缀

  // componentWillMount 和 UNSAFE_componentWillMount 适用于所有过时生命周期钩子
}
```



```jsx
UNSAFE_componentWillUpate(nextProps, nextState) {
  // UNSAFE_componentWillUpate 执行时 组件也没有更新
  // 参数依旧是 更新前的 props 和 state
}
```



```jsx
render(props) {
	// 执行render方法时
  // 	1. 如果是第一次渲染 => 执行render前，会初始化props和state
  // 	2. 如果不是第一次渲染 => 执行render前，会更新props和state
  // 所以在render中永远都能拿到最新的props和state
}
```



###  SCU

![image.png](https://s2.loli.net/2024/09/25/dwpQ6UtlK4G3cfX.png) 

1. shouldComponentUpdate => 简称SCU => 会在组件更新之前被回调 => 用于决定组件是否需要更新
2. 如果不重写 `shouldComponentUpdate`，组件会默认返回 `true`，这意味着每次状态或属性更新时，组件都会重新渲染
3. shouldComponentUpdate的返回值是布尔类型值
   + `true`：组件生成虚拟 DOM（VDOM），并进行 DOM-DIFF 操作，然后执行组件更新。
   + `false`：组件不会重新渲染，也不会生成新的 VDOM，这可以提高性能，减少不必要的渲染。

```jsx
// 执行时，组件还没有更新 
// => 实例上是更新前状态和props，参数是更新后状态和props
shouldComponentUpdate(nextProps, nextState) {

  // 函数默认返回undefined，但还是推荐显示返回明确的布尔类型值
  return ture
}
```

React的默认行为是当父组件重新渲染时，其所有子组件也会重新渲染。

当子组件的props和state没有改变时，子组件是不需要重新更新的，但React只有通过DOM-DIFF后才能知道

手动实现SCU可以显示告诉React，组件是否需要更新

如果SCU返回了false，组件更新将被直接跳过 => 不会生成新的VDOM, 也不会进行DOM-DFF 

所以SCU的主要目的是提升渲染性能，减少不必要的渲染。







## React.StrictMode

React中的严格模式，用于检测一些React中一些不规范的操作 「 如调用过时的或者不推荐使用的API 」

这和JavaScript中的严格模式是完全不同的两种东西



某些第三方开发时间较早，内部会使用不推荐或过时的API 「 如Ant-Design 」 => 所以实际开发中一般不开





































1. props 规则校验 => 初始化props 「 挂载到组件实例上 」
1. 初始化状态
1. 执行生命周期钩子
1. 
