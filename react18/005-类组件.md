```jsx
import { Component } from 'react'

// 一个类只要继承自PureComponent 或 Component 才能是类组件
// Component和PureComponent 在react中被直接导出了，同时也被挂载到了rect对象上 「 可以通过解构获取 」
export default class App extends Component {
  // 类组件中只有render方法是必传的，返回需要渲染的JSX元素
  render() {
    return (
      <>
        This is a class component
      </>
    )
  }
}
```



## 类基本使用

```js
class Parent {
  // 类成员变量写法 「 依旧挂载实例上 」
  num = 0;
  // 私有属性必须先通过类成员表达式进行声明后才能使用
  #msg = 'running' // #开头的属性是私有属性 「 只能在当前类中使用 」
  
  static call() {} // 静态方法「 类方法 」=> 不可枚举
  static calssName = 'className' // 静态属性 「 类属性 」

  // new的时候，会自动调用构造函数
  constructor(x, y) {
    // this->创建的实例
    this.num = x + y;
  }

  // 方法会自动挂载原型上 「 且是不可枚举的 」
  run() {
    console.log(this.#msg)
  }

  study = () => {
    // class后边的大括号会生成块级作用域 「 箭头函数study内this，会找到组件实例 」
    // 可以理解为成员表达式写法 解析时会移动到构造函数中执行
    console.log(this)
  } // 会被挂载到实例上
}

// 如果要往类原型上加属性 => 只能在类外部添加
Parent.prototype.msg = 'prototype message'
```

默认情况下，不使用构造函数，构造函数可以省略，存在如下默认构造函数

```js
constructor() { }
```



```js
// react的Component组件实现伪代码
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
```

因为继承属性使用的是借用父类构造函数继承「 call继承 」，所以子类会存在通用实例属性`props`、`context`、`refs`和`updater` 「 更新队列 」

顺着原型链向上查找，一定会找到`Component.prototype`，所以会存在方法`forceUpdate`、`setState`和属性`isReactCompoent`

```js
// extends关键字实现继承
class Child extends Parent {
  constructor(childName) {
    // 在子类构造方法中使用this之前必须通过super方法调用父类构造方法
    // 以确保JS可以转换为借用构造函数继承 和 借用原型链继承
    super() // 调用父类构造函数
    this.childName = childName
  }

  childRunning() {
    super.running() // 调用父类实例方法
  }

  static childStudying() {
    super.studying() // 调用父类静态方法
  }
}
```

实现继承后，默认实现的构造函数变成了

```js
constructor(...args) {
  super(...args)
}
```

