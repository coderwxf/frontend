父传子

+ 普通数据 => 基于普通类型的props
+ 传递html片段 => 基于`props.children` => 插槽

子传父 => 基于函数类型props



父子组件还可以通过`ref`进行通信 「 不推荐 」

如果组件和组件层级较远，还可以使用全局状态管理 「 如redux，mobx等 」



## 类组件

```jsx
import { PureComponent } from 'react'

// 省略props类型校验和默认值设置
class Count extends PureComponent {
  render() {
    // 父传子
    return <h1>{ this.props.count }</h1>
  }
}

class Action extends PureComponent {
  render() {
    // 子传父
    return <button onClick={this.props.increment}>click me</button>
  }
}

export default class Child extends PureComponent {
  state = {
    count: 0
  }

  // 类组件实例并没有重复创建，更新时只是重新执行render方法
  // 所以类组件实例上的increment方法永远是一个，不会发生改变
  increment() {
    this.setState({
      count: this.state.count + 1
    })
  }

  render() {
    return (
      <>
        <Count count={this.state.count} />
        {/*
          传递给子组件的函数 => 使用箭头函数
         	 => 子组件调用父组件函数时，父组件函数内容this永远是父组件实例
        */}
        <Action increment={() =>  this.increment()} />
      </>
    )
  }
}
```



## 函数组件

```jsx
import { useState, useCallback, memo } from "react"

// 父传子
const Count = memo(({ count }) => <h2>{count}</h2>)

// 子传父
const Action = memo(({ increment })  => <button onClick={increment}>click me</button>)

export default function Child(props) {
  const [ count, setCount ] = useState(0)

  const increment = useCallback(() => {
    setCount(count + 1)
  }, [count])

  return (
    <>
      <Count count={count} />
      <Action increment={increment}  />
    </>
  )
}
```

