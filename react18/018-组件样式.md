默认情况下，样式是全局作用域生效，所以在组件开发中，很可能出现样式冲突问题

所以需要将组件样式设置为组件作用域，这个过程被称之为样式私有化



在React中使用样式私有化方案

1. 内联样式 => 直接写`行内样式` 或使用 `tailwindcss`
2.  外部样式表 => 使用BEM等命名规则 进行人为避免
3. css modules
4. css in js
   + React jss
   + Styled-component



## 内联样式

1. 不利于样式复用 「 TailwindCss 和 内联样式 都不可以  」
2. 没有使用伪类或伪元素 「 TailwindCss 可以 」
3. 样式和结构混合在一起，没有抽离 「 TailwindCss 可以 」

```jsx
function Header() {
  return <div style={{ backgroundColor: 'orange' }}>header</div>
}

function Footer() {
  return <div style={{ backgroundColor: 'skyblue' }}>footer</div>
}

export default function Child(props) {
  return (
    <>
      <Header />
      <div style={{ backgroundColor: 'purple' }}>content</div>
      <Footer />
    </>
  )
}
```



## 样式表

保证组件的最外层容器的类名不冲突

+ BEM命名规范
+ 路径 + 组件名
  + 组件所在目录为`/src/views/product/userList.jsx`
  + 组件最外层容器命名为 `.product-user-list-box`
+ 路由 + 组件名
+ 。。。



组件组织结构

```shell
# 组件目录结构类似如下:
Footer # 组件名
  ├── index.jsx # 组件UI结构
  ├── style.css # 组件样式
```

```css
/* @style.css */
.footer-box {
  background: skyblue;
}

.footer-box__a {
  text-decoration: none;
}
```



全局样式 => 写在根组件对应的`style.css`中

```css
.app a {
  color: red;
}
```



缺点:

1. 编写复杂
2. 依赖人为规范 => 没有实际完全的组件作用域，依旧容易造成冲突
4. 无法在样式中使用动态值



### BEM

BEM（Block, Element, Modifier）是一种前端命名规范，用于创建可重用的组件和代码

类名格式：`block--modifier` 或 `block__element--modifier`

```jsx
<button class="button button--primary">
  <span class="button__icon"></span>
  <span class="button__text">Click Me</span>
</button>
```



## css module

`css module`并不是css原生支持功能，需要在构建工具中引入对应插件来实现对应功能 「 如`css-loader` 」

`css module`的后缀可以是`xxx.module.css`、`xxx.module.less`、`xxx.module.scss`等

```shell
# 组件目录结构类似如下:
Footer # 组件名
  ├── index.jsx # 组件UI结构
  ├── style.module.css # 组件样式
```



```css
/* @style.module.css */
.users {
  font-size: 20px;
}

/* 
	类名不推荐使用kebab-case, 建议使用camelCase => 方便在JSX中使用对应样式类名
	例如: .user-name 改成 .userName => 使用时 style['user-name']就可以变为style.userName
*/
.user {
  list-style: none;
}

.user a {
  color: skyblue;
  display: block;
}

.user a:hover {
  background: orange;
}
```

编译后

```js
const style = {
  // 仅编译样式名 格式为 <fileNameOrFolder>_<类名>__<hash值>
  // + 如果组件名为 Header -> style.module.css => style_user__f4uEk
  // + 如果组件名为 Header -> index.module.css => Header_user__f4uEk
	user: "style_user__f4uEk", 
	users: "style_users__Cc11J"
}
```

使用

```jsx
import style from './style.module.css' // 组件样式
import common from './common.module.css' // 全局样式

export default function Header() {
  return <>
    <ul className={style.users}>
      <li className={`${style.user} ${common.link}`}><a href="/klaus">Klaus</a></li>
      <li className={`${style.user} ${common.link}`}><a href="/alex">Alex</a></li>
      <li className={`${style.user} ${common.link}`}><a href="/steven">Steven</a></li>
    </ul>
  </>
}
```



如果需要使用全局样式

1. 写在全局普通样式文件中，如`common.css`
2. 写在全局css module文件中，如`common.module.css`
3. 使用`:global()`，如`:global(.clearfix)` => `:global()`函数可以跳过css module的样式编译流程



缺点:

1. 不支持为样式绑定状态值



### 样式继承

```css
.users {
  font-size: 20px;
}

.user {
  list-style: none;
}

.foo {
  /* 支持样式多继承 => 多个样式之间使用空格分割 */
  composes: users user;
  color: red;
}
```

编译后

```css
.style_users__Cc11J {
  font-size: 20px;
}

.style_user__f4uEk {
  list-style: none;
}

.style_foo__Z-wK- {
  color: red;
}
```

使用

```jsx
{/*
  样式本质是多个样式的叠加使用, 在本例中最终编译后的样式为:
  style_foo__Z-wK- style_users__Cc11J style_user__f4uEk
*/}
<div className={style.foo}>foo</div>
```



## React JSS

```shell
# 组件目录结构类似如下:
Footer # 组件名
  ├── index.jsx # 组件UI结构
  ├── style.js # 组件样式
```

```js
// @style.js
import { createUseStyles } from 'react-jss'

// 创建样式 => 返回值是一个hook函数
// 只有写在参数第一层的users和user才会被编译 => {users: 'users-0-2-6', user: 'user-0-2-7'}
const useStyle = createUseStyles({
  users: {
    listStyle: 'none'
  },

  user: {
    color: 'skyblue',
    fontSize: 20, // => 会自动添加px作为单位

    // 子元素样式必须通过&来表示 => 在本例中&会使用user编译后的结果替换
    // & a 编译后 .user-0-2-7 a
    '& a': {
      '&:hover': {
        background: 'orange'
      }
    }
  }
})

export default useStyle
```

```jsx
import useStyle from './style'

export default function Header() {
  // 通过hook获取需要使用的样式对象
  const style = useStyle()

  return <>
    <ul className={style.users}>
      <li className={style.user}><a href="/klaus">Klaus</a></li>
      <li className={style.user}><a href="/alex">Alex</a></li>
      <li className={style.user}><a href="/steven">Steven</a></li>
    </ul>
  </>
}
```



### 在类组件中使用

```jsx
import { PureComponent } from 'react'
import useStyle from './style'

// 使用HOC的方式，再类组件外包裹函数组件，并将样式作为props传入
// HOC是一种特殊的高阶函数，接收组件并返回一个新组件 「 两个条件需要同时满足 」
// HOC的本质是通过闭包机制实现组件代理
function withStyle(Cpn) {
  return function(props) {
    const style = useStyle()
    // 将props对象展开并依次作为props进行传递 
    return <Cpn {...props} {...style} />
  }
}

class Header extends PureComponent {
  render() {
    const { users, user } = this.props
    return <>
    <ul className={users}>
      <li className={user}><a href="/klaus">Klaus</a></li>
      <li className={user}><a href="/alex">Alex</a></li>
      <li className={user}><a href="/steven">Steven</a></li>
    </ul>
  </>
  }
}

export default withStyle(Header)
```



### 动态样式

`css in js`的一种实现方式，样式被写在JavaScript文件中，所以可以为样式绑定状态

```jsx
const style = useStyle({
  primaryColor: 'skyblue',
  hoverColor: 'red',
  baseFont: 20
})
```

```js
import { createUseStyles } from 'react-jss'

const useStyle = createUseStyles({
  users: {
    listStyle: 'none',
    // 非顶级key 只能返回具体的样式值 => props就是useStyle在被调用时传入的变量对象
    background: props => props.primaryColor
  },

  // 顶级key 可以返回样式对象 => props就是useStyle在被调用时传入的变量对象
  user: props => ({
    color: 'skyblue',
    fontSize: props.baseFont,

    '& a': {
      '&:hover': {
        background: props.hoverColor
      }
    }
  })
})

export default useStyle
```

以下使用方式是错误的

```jsx
const useStyle = createUseStyles({
  users: {
    listStyle: 'none',
    background: props => props.primaryColor
  },

  user: {
    color: 'skyblue',
    fontSize: 20,

    // & a 并不是顶级key，只能返回样式值，不能返回样式对象
    // 所以这种使用方式是不会生效的
    '& a': props => ({
      '&:hover': {
        background: props.hoverColor
      }
    })
  }
})
```



## styled-component

vscode需要语法提示，需要安装插件[vscode-styled-components](https://marketplace.visualstudio.com/items?itemName=styled-components.vscode-styled-components)

```js
import styled from 'styled-components'
// 引入全局样式变量
import { primaryColor, dangerColor } from '../common'

// styled.<组件名>` 样式 ` => 返回值是含有样式的样式组件
export const HeaderUl = styled.ul`
  list-style: none;

  /* 嵌套元素 */
  .user {
    font-size: 20px;

    a {
      display: block;
      color: ${dangerColor}; // 通过字符串拼接方式嵌入变量

      /* 伪类 */
      &:hover {
        color: ${primaryColor};
      }
    }
  }
`
```

```jsx
import { HeaderUl } from './style'

export default function Header(props) {
  return (
    <>
     {/* HeaderUl -> <ul class='sc-<hash值> <hash值>' >...</ul> */}
     <HeaderUl>
      <li className='user'><a href="/klaus">Klaus</a></li>
      <li className='user'><a href="/alex">Alex</a></li>
      <li className='user'><a href="/steven">Steven</a></li>
     </HeaderUl>
    </>
  )
}
```



### 样式继承

```js
// @common.js
import styled from 'styled-components'

export const primaryColor = '#337ecc'
export const dangerColor = '#f56c6c'

export const BaseUl = styled.ul`
  list-style: none;

  li {
    a {
      color: green;
    }
  }
`
```

```jsx
import styled from 'styled-components'
// 引入全局样式变量
import { primaryColor, dangerColor, BaseUl } from '../common'

// HeaderUl将继承BaseUl中存在的样式
export const HeaderUl = styled(BaseUl)`
  a {
    display: block;
    // 先生效HeaderUl 再生效BaseUl => BaseUl中对应样式的优先级更高
    color: ${dangerColor}!important;  // 通过字符串拼接方式嵌入变量

    &:hover {
      color: ${primaryColor};
    }
	}
`
```



### 默认值

```jsx
import styled from 'styled-components'

// 通过attrs设置props的默认值
// props传递进来后会先被attrs处理，再使用
export const HeaderUl = styled.ul.attrs(props => ({
  primaryColor: props.primaryColor ?? '#337ecc',
  dangerColor: props.dangerColor ?? '#f56c6c'
}))`
  list-style: none;

  .user {
    font-size: 20px;

    a {
      display: block;
      color: ${props => props.dangerColor}; // 使用传入的props值

      &:hover {
        color: ${props => props.primaryColor};
      }
    }
  }
`
```

```jsx
{/* 使用自定义props传递动态值 */}
<HeaderUl primaryColor="#67c23a">
  <li className='user'><a href="/klaus">Klaus</a></li>
  <li className='user'><a href="/alex">Alex</a></li>
  <li className='user'><a href="/steven">Steven</a></li>
</HeaderUl>
```



### 嵌套使用

```js
import styled from 'styled-components'

export const HeaderUl = styled.ul`
  list-style: none;
`

export const HeaderLi = styled.li`
  color: skyblue;
`
```

```jsx
<HeaderUl >
  <HeaderLi><a href="/klaus">Klaus</a></HeaderLi>
  <HeaderLi><a href="/alex">Alex</a></HeaderLi>
  <HeaderLi><a href="/steven">Steven</a></HeaderLi>
</HeaderUl>
```



## classnames

一种方便快捷管理class类的第三方库，vue在编写class样式时，底层集成的就是[classnames](https://www.npmjs.com/package/classnames)

```js
// 如果是普通值 => falsy值会自动过滤，只留truthy值
// 如果是对象 => 只留对象值是truthy值的key
classNames(null, false, 'bar', undefined, 0, 1, { baz: null, foo: true }, ''); 
// => 'bar foo 1'
```

```jsx
// 参数可以是数组语法，也可以是对象语法
// 多个参数之间会进行参数合并
classNames(
  ['foo'], 
  ['dv', 'lorem'], 
  {
  	bar: false,
  	baz: true
	}
) // =>  'foo dv lorem baz'
```









---

css module vscode 语法提示 插件
