## useMemo

`useMemo`实现类似于计算属性的功能 => 实现计算缓存

```jsx
import { useMemo, useState } from "react"

export default function Child(props) {
  const [x, setX] = useState(0)
  const [y, setY] = useState(0)
  const [z, setZ] = useState(0)

  // let state = useMemo(callback, 依赖数组)
  // + 首次渲染 => 执行callback => 将callback的返回值赋值给state，并缓存结果
  // + 后续更新 => 只有依赖数组中某个状态发生改变, 才会重新执行callback，并将新的返回值赋值给state并更新缓存
  const sum = useMemo(() => {
    console.log('memo')
    return x + y
  }, [x, y])

  return (
    <>
      <div>{x} + {y} = {sum}</div>
      <div>z: {z}</div>

      <div>
        <button onClick={() => setX(x + 1)}>add X</button>
        <button onClick={() => setY(y + 1)}>add Y</button>
        <button onClick={() => setZ(z + 1)}>add Z</button>
      </div>
    </>
  )
}
```



## useCallback

函数组件每次更新，都会产生新的函数执行上下文，并生成对应闭包

对于非状态更新函数，也就是那些自定义事件处理函数没有必要每次都重新创建一个

可以使用`useCallback`实现方法的缓存 

`useCallback(callback, [dependencies])` 

​	=> `[dependencies]` => 依赖数组

​	=> `useCallback`的使用方式和`useMemo`基本类似

​	=> `useCallback(callback)`将会在每次组件渲染时返回新的callback 

​		=> 此时和直接使用`callback`实现的效果是一致的 

​		=> 所以只要使用`useCallback`，就一定需要为其设置依赖数组

 ```jsx
 import { useCallback, useState } from "react"
 
 let prevFunc = null
 let prevCallback = null
 
 export default function Child(props) {
   const [count, setCount] = useState(0)
 
   function handle() {
     console.log('handle')
   }
 
   const callbackHandle = useCallback(handle, [])
 
   if (!prevFunc) {
     prevFunc = handle
     prevCallback = callbackHandle
   } else {
     console.log(prevFunc === handle) // => false
     console.log(prevCallback === callbackHandle) // => true
   }
 
   return (
     <>
       <div>{ count }</div>
       <button onClick={() => setCount(count + 1)}>click me</button>
     </>
   )
 }
 ```



对于组件内部的方法，如果这些方法没有被传递给子组件作为 props，那么使用 `useCallback` 缓存它们通常没有太大意义。因为每次渲染时生成新函数和查找缓存的开销差不多，而 `useCallback` 还会增加代码的复杂性。

「 此时创建新函数并不会导致UI的重新渲染 」



当函数作为 props 传递给子组件时，如果不使用 `useCallback`，每次父组件渲染时都会生成一个新的函数引用。这会导致子组件即使没有其他变化，也会因为 props 的变化而重新渲染。此时使用 `useCallback` 可以确保函数在依赖不变的情况下保持函数类型props的同一引用，进而避免子组件的无谓渲染。

「 此时创建新函数会导致UI的重新渲染 」



```jsx
import { memo, useCallback, useState } from "react"

// memo是一个高阶组件，参数是函数组件 => 实现类似于PureComponent的效果
const Count= memo(function({ count, increment, handle }) {
  console.log('render')

  return <>
     <div>{ count }</div>
     <button onClick={increment}>click me</button>
     <button onClick={handle}>handle</button>
  </>
})

export default function Child(props) {
  const [count, setCount] = useState(0)

  // 函数类型props
  // 如果不使用useCallback => 每次都是新引用地址 => 子组件SCU返回false => 子组件需要重新渲染
  // 如果使用useCallback包裹 => 引用地址相同 => 子组件SCU返回true => 子组件不需要重新渲染

  const handle = useCallback(() => console.log('handle'), [])

  // 如果存在状态，则需要在状态改变时，更新函数 => 以获取新执行上下文中对应新的状态值
  // 如果使用缓存，将导致内部状态获取到的是旧状态值 「 因为访问的是旧的闭包 」
  const increment = useCallback(() =>  setCount(count + 1), [count])

  return (
    <>
      <Count count={count} increment={increment} handle={handle} />
    </>
  )
}
```



```jsx
/*
  如果forwardRef 和 memo 同时使用
    => memo(forwardRef(（props, ref) => {})) => 可以确保ref被正常传递
    => forwardRef(memo(（props, ref) => {})))
       => ref被传递给了memo，但是memo没有传递给函数组件
       => 此时会导致ref传递的丢失
*/
const Count = memo(forwardRef((props, ref) => {
  return <div ref={ref}>count</div>
}))
```

