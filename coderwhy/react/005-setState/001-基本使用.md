setState是异步更新

1. 将多次修改合并在一起，存入更新队列中 「 存储的数据结构其实是队列 」以便于进行批处理更新，从而减少更新次数，提升性能
2. 确保在更新状态批处理后，立即调用render方法，从而确保传递给子组件的状态同步更新，避免父子组件状态不一致问题

```jsx
<Counter count={this.state.count} />
```

例如在上述例子中，如果state更新是同步的

会出现在父组件中，this.state.count的值是1

但是因为没有调用render方法，所以Counter组件中获取到的count prop的值还是0

从而出现父子组件状态不一致问题，不利于开发和调试



> 1. 通过setState更新后的状态 和 原始状态一致
> 2. 组件继承自Component，且没有实现自己的shouldComponentUpdate
>
> 依旧会触发新VDOM的生成，只不过DOM-DIFF后没有任何需要更新的内容



## 使用方法

`使用方法一 -- 传入对象，改对象会和this.state 执行Object.assign操作`

```jsx
// 假设this.state.count的初始值0

this.setState({
  count: this.state.count + 1 // 0 + 1 -> 1
})

this.setState({
  count: this.state.count + 1  // 0 + 1 -> 1
})

this.setState({
  count: this.state.count + 1 // 0 + 1 -> 1
})
```

 三次操作执行Object.assign得到 { count: 1 }

最后将{count: 1} 和 this.state 进行 Object.assign 操作 

得到最终结果 { count: 1 }



`使用方法二 - 传入函数` 

+ 第一个参数 --  旧的state
+ 第二个参数  -- this.props

传入函数的优点

1. 如果返回的状态需要经过某些运算，可以将这些运算写在函数中，以提升内聚度
2. 可以在保证状态异步更新的基础上，获取修改后的state值

```js
// 假设this.state.count的初始值0

// 第一次调用 state的值是this.state.count
this.setState((state, prop) => ({
  count: state.count + 1 // 0 + 1 -> 1
}))

// 第二次调用 state的值是 上一个函数返回值中的count值
this.setState((state, prop) => ({
  count: state.count + 1 // 1 + 1 -> 2
}))

this.setState((state, prop) => ({
  count: state.count + 1 // 2 + 1 -> 3
}))
```

所以最终的执行结果为 { count: 3 }



`使用方式三 -- 传入第二个回调函数`

```jsx
this.setState({
  count: this.state.count + 1
}, () => {
  // 第二个参数是回调函数，会在状态更新后立即回调
  // 这个回调函数会在componentDidUpdate回调调用之后被执行
  console.log('callback', this.state.count) // => 1
})

// 状态更新是异步操作，所以这里取到的count值是0
console.log('sync', this.state.count) // => 0
```



## 异步更新

18开始 所有的setState都是异步更新

18之前

1. 合成事件，生命周期等 react管控方法中的 setState 都是异步更新
2. 原生DOM事件，定时器，promise回调等 非react管控方法中的setState 都是同步更新



## flushSync

```jsx
import React, { PureComponent } from 'react'
// 这个方法来自于`react-dom`
import { flushSync } from 'react-dom'

export class App extends PureComponent {
  state = {
    count: 0
  }

  changeCount() {
    // 更新A
    this.setState({
      count: this.state.count + 1
    })

    // 更新B
    flushSync(() => {
      this.setState({
        count: this.state.count + 1
      })
    })

    // 更新C
    this.setState({
      count: this.state.count + 1
    })

    // flushSync将回调函数插入队列中，并立即更新状态更新
    console.log('count:', this.state.count) // => 1
  }

  render() {
    const { count } = this.state

    return (
      <>
        <div>{ count }</div>
        <button onClick={() => this.changeCount()}>click me</button>
      </>
    )
  }
}

export default App
```

上述写法等价于

```jsx
import React, { PureComponent } from 'react'
import { flushSync } from 'react-dom'

export class App extends PureComponent {
  state = {
    count: 0
  }

  changeCount() {
    // 更新A
    this.setState({
      count: this.state.count + 1
    })

    // 更新B
    this.setState({
      count: this.state.count + 1
    })

    // 回调是undefined，自动忽略
    // 直接同步更新状态
    flushSync()

    // 更新C
    this.setState({
      count: this.state.count + 1
    })

    // flushSync将回调函数插入队列中，并立即更新状态更新
    console.log('count:', this.state.count) // => 1 
  }

  render() {
    const { count } = this.state

    return (
      <>
        <div>{ count }</div>
        <button onClick={() => this.changeCount()}>click me</button>
      </>
    )
  }
}

export default App
```

