## 事件对象

```jsx
import { Component } from 'react'

export default class App extends Component {
  state = {
    count: 0
  }

  changeCount(e) {
    // React获取到的事件对象是合成事件对象，不是原生事件对象 -- 目的是为了避免不同浏览器之间事件的兼容问题
    console.log(e)
    console.log(e.nativeEvent) // 通过合成事件对象获取原生事件对象
  }

  render() {
    const { count } = this.state

    return (
      <>
        <div>{ count }</div>
        <button onClick={this.changeCount}>changeCount</button>
      </>
    )
  }
}
```



## 参数传递

`方式一 --- bind`

```jsx
import { PureComponent } from 'react'

export default class App extends PureComponent {
  // 修正this: const fn = fun.bind(...arg1)
  // 函数调用: fn(...arg2) --> 此时传入的主要是合成事件对象
  // 实际传入参数 ...[...arg1, ...arg2]
  handleClick(x, y, e) {
    console.log(x, y, e)
  }

  render() {
    return (
      <>
        <button onClick={this.handleClick.bind(this, 10, 20)}>click me</button>
      </>
    )
  }
}
```



`方式二 --- 类表达式`

```jsx
import { PureComponent } from 'react'

export default class App extends PureComponent {
  handleClick = (x, y, e) => {
    console.log(x, y, e)
  }

  render() {
    return (
      <>
        {/* 调用函数本质是箭头函数，所以bind的第一个参数没有意义, 可以使用null或undefined占位 */}
        <button onClick={this.handleClick.bind(null, 10, 20)}>click me</button>
      </>
    )
  }
}
```



`方式三 --- 箭头函数`

```jsx
import { PureComponent } from 'react'

export default class App extends PureComponent {
  handleClick(e, x, y) {
    console.log(x, y, e)
  }

  render() {
    return (
      <>
        {/* 此时e是我们主动获取并传递的，相当于搞了个中间层，所以可以自由控制事件对象的传递位置 */}
        <button onClick={(e) => this.handleClick(e, 10, 20)}>click me</button>
      </>
    )
  }
}
```

