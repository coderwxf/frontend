react中并没有插槽，但我们可以模拟实现相同功能

实现方式有以下两种

1. 通过子元素「children」实现
2. 通过props实现



`通过children实现`

```jsx
{/* 父组件 */}
<Child>
  <div>first</div>
  <div>second</div>
  <div>last</div>
</Child>
```

```jsx
{/* 子组件 */}
import React, { Children, Component } from 'react'

export class Child extends Component {
  render() {
    // 1. children会被挂载到this.props上
    // 2. Children.toArray会将children转换为数组 -- 避免null和JSX元素的情况
    const children = Children.toArray(this.props.children)

    return (
      <div>
        <h2>{children[0]}</h2>
        <h2>{children[1]}</h2>
        <h2>{children[2]}</h2>
      </div>
    )
  }
}

export default Child
```



`通过props实现`

```jsx
{/* 父组件 */}
<Child
  headerSlot = {<h2>Header</h2>}
  footerSlot = {<h2>Footer</h2>}
/>
```

```jsx
{/* 子组件 */}
import React, { Component } from 'react'
import PropTypes from 'prop-types'

export class Child extends Component {
  static propTypes = {
    headerSlot: PropTypes.element.isRequired,
    footerSlot: PropTypes.element.isRequired
  }

  render() {
    return (
      <div>
        {this.props.headerSlot}
        {this.props.footerSlot}
      </div>
    )
  }
}

export default Child
```



## 具名插槽

`父组件`

```jsx
<Child>
  {/* 这个slot是用户自定义属性 */}
  <div slot="first">first</div>
  <div>second</div>
  <div slot="last">last</div>
</Child>
```



`子组件`

```jsx
import React, { Children, Component } from 'react'

export class Child extends Component {
  render() {
    const children = Children.toArray(this.props.children)

    const childMap = {
      first: children.find(node => node.props.slot === 'first'),
      default: children.find(node => !node.props.slot),
      last: children.find(node => node.props.slot === 'last')
    }

    return (
      <div>
        <h2>{childMap.first}</h2>
        <h2>{childMap.default}</h2>
        <h2>{childMap.last}</h2>
      </div>
    )
  }
}

export default Child
```



## 插槽默认值

```jsx
<h2>{ children[0] ?? 'default value' }</h2>
```



## 作用域插槽

组件有自己的独立的作用域，组件和组件之间是相互独立的

但插槽是父组件传递给子组件的html片段 「 插槽是显示在子组件中，但是编译时在父组件中的 」

如果想在插槽中使用子组件数据，就需要使用作用域插槽 「 父传子模板的同时，子传父在模板中需要使用的数据 」



`基于props实现`

`父组件`

```jsx
<Child
  defaultSlot = {name => <h2>{name}</h2>}
/>
```



`子组件`

```jsx
import React, { Component } from 'react'
import PropTypes from 'prop-types'

export class Child extends Component {
  state = {
    name: 'child'
  }

  static propTypes = {
    defaultSlot: PropTypes.func.isRequired
  }

  render() {
    return (
      <div>
        {this.props.defaultSlot(this.state.name)}
      </div>
    )
  }
}

export default Child
```



`基于children实现`

`父组件`

```jsx
<Child>
  {
    name => <h2>{name}</h2>
  }
</Child>
```



`子组件`

```jsx
import React, { Component } from 'react'

export class Child extends Component {
  state = {
    name: 'child'
  }

  render() {
    // Children.toArray会处理如下情况:
    // 1. 如果children是一个数组，直接返回 children
    // 2. 如果children是一个JSX元素，返回 [children]
    // 3. 如果children是undefined, 返回 []

    // 在将children统一成数组的结果中，会确保数组中的每一项都是一个JSX元素
    // 如果传入的child不是JSX元素，会被直接过滤
    
    // 在本例中，父组件传入的是一个函数，用以实现作用域插槽
    // 所以不可以使用Children.toArray来处理children -- 会导致传入的函数被过滤

    return (
      <div>
        { this.props.children(this.state.name) }
      </div>
    )
  }
}

export default Child
```

