`context`是与 Vue 中的 `provide/inject` 功能相似的机制。它允许跨组件传递数据而不必通过每个层级显式传递 props



`context.js`

```js
import { createContext } from 'react'

// 上下文对象 即要在 生产者组件中使用，也要在消费者组件中使用，所以单独抽取出来，便于复用

// 创建出的context本质上也是一种功能对象，所以命名采用大驼峰写法
export const PointerContext = createContext()
```



`祖先组件`

```jsx
import React, { PureComponent } from 'react'
import { PointerContext } from './context'
import Child from './Child'

export class App extends PureComponent {
  render() {
    return (
      <>
        {/*
          1. 通过生产者为后代提供数据
          2. value就是需要提供的数据
          3. 一个 Provider 可以有多个消费者组件
          4. Provider相当于是其内部子组件的父元素，所以当value发生改变时，内部子组件都需要判断是否需要重新渲染
        */}
        <PointerContext.Provider value={{ x: this.props.x, y: this.props.y }}>
          <Child />
        </PointerContext.Provider>
      </>
    )
  }
}

export default App
```



`后代组件`

`类组件`

```jsx
import React, { PureComponent } from 'react'
import { PointerContext } from './context'

export class Cpn extends PureComponent {
  render() {
    return (
      <>
        {/*
          1. 通过消费者组件使用祖先组件传入的context
          2. 值通过函数型children来获取
        */}
        <PointerContext.Consumer>
          {
            value => {
              return (
                <div>
                  <h3>x: {value.x}</h3>
                  <h3>y: {value.y}</h3>
                </div>
              )
            }
          }
        </PointerContext.Consumer>
      </>
    )
  }
}

export default Cpn
```



`函数组件`

```jsx
import { PointerContext } from './context'

export default function Cpn(props) {
  return (
    <>
      <PointerContext.Consumer>
        {
           value => {
            return (
              <div>
                <h3>x: {value.x}</h3>
                <h3>y: {value.y}</h3>
              </div>
            )
          }
        }
      </PointerContext.Consumer>
    </>
  )
}
```



## contextType

`contextType`只能用于类组件，是类组件的静态属性

```jsx
import React, { PureComponent } from 'react'
import { PointerContext } from './context'

export class Cpn extends PureComponent {
  // 通过contextType这个静态属性 设置this.context的值应该是那个context生产者提供的值 「 生产者可能不止一个 」
  // contextType只能简化一个context生产者的用法，如果存在多个生产者，其余生产者依旧需要使用xxx.Consumer的形式去获取
  // 设置后，就可以在任何生命周期中通过this.context访问到它，包括在 render 函数中
  static contextType = PointerContext

  render() {
    return (
      <div>
        <h3>x: {this.context.x}</h3>
        <h3>y: {this.context.y}</h3>
      </div>
    )
  }
}

export default Cpn
```



## 嵌套使用

`context.js`

```jsx
import { createContext } from 'react'

export const PointerContext = createContext()
export const PositionContext = createContext()
```



`生产者`

```jsx
<PointerContext.Provider value={{ x: 10, y: 20 }}>
  <PositionContext.Provider value={{ x: 30, y: 40 }}>
    <Child />
  </PositionContext.Provider>
</PointerContext.Provider>
```



`消费者`

```jsx
import React, { PureComponent } from 'react'
import { PointerContext, PositionContext } from './context'

export class Cpn extends PureComponent {
  static contextType = PointerContext

  render() {
    return (
      <>
        <PositionContext.Consumer>
          {
            // 注意是 position => (...) 不是 position => { ... }
            // 消费者的children是一个返回可以被react渲染内容的函数
            // 而position => { ... } 表示返回的是一个对象，这是语法错误
            // 如果遇到了语法错误，直接什么都不显示，并不会报错
            position => (
              <div>
                <h3>point x: {this.context.x}</h3>
                <h3>point y: {this.context.y}</h3>

                <h3>position x: {position.x}</h3>
                <h3>position y: {position.y}</h3>
              </div>
            )
          }
        </PositionContext.Consumer>
      </>
    )
  }
}

export default Cpn
```



另一种使用方式

```jsx
<PointerContext.Consumer>
  {
    point => (
      <PositionContext.Consumer>
        {
          position => (
            <div>
              <h3>point x: {point.x}</h3>
              <h3>point y: {point.y}</h3>

              <h3>position x: {position.x}</h3>
              <h3>position y: {position.y}</h3>
            </div>
          )
        }
      </PositionContext.Consumer>
    )
  }
</PointerContext.Consumer>
```



## 默认值

在`createContext`调用的时候，可以传入默认值 --> `createContext(defaultValue)`

1. 这个默认值不是Provider没有设置value时，传递给后代组件的默认值
2. 而是某个组件并非是Provider的后代，但是在内部使用了Consumer时候，提供的默认值

所以 `defaultValue`是组件在顶层查找过程中没有找到对应的Provider，才会使用的默认值



`context.js`

```jsx
export const PointerContext = createContext({
  x: 0,
  y: 0
})
```



`使用`

```jsx
<>
  <PointerContext.Provider>
      {/* 子组件中 PointerContext.Consumer 提供的值是 undefined，因为Provider未传递 value */}
       {/* 如果没有提供默认值，那么默认 value 就是 undefined */}
      <Child />
  </PointerContext.Provider>

  {/* 子组件中 PointerContext.Consumer 提供的值是 { x: 0, y: 0 }，因为它没有被任何Provider包裹 */}
  <ChildComponent />
</>
```



## 就近原则

```jsx
import React, { createContext } from 'react';

// 创建一个Context对象
const MyContext = createContext();

// 祖先组件
function App() {
  return (
    <MyContext.Provider value={{ sharedValue: "value from outer provider" }}>
      <ComponentOne />
    </MyContext.Provider>
  );
}

// 中间组件
function ComponentOne() {
  return (
    <MyContext.Provider value={{ sharedValue: "value from inner provider" }}>
      <ComponentTwo />
    </MyContext.Provider>
  );
}

// 底层组件
function ComponentTwo() {
  return (
    // 如果父组件Provider被调用了多次，提供了多个value，则后边提供的value会覆盖前边提供的value
    <MyContext.Consumer>
      {context => <p>{context.sharedValue}</p>}
    </MyContext.Consumer>
  );
}

export default App;
```



## 事件传递

`祖先组件`

```jsx
import React, { PureComponent } from 'react'
import { PointerContext } from './context'
import Child from './Child'

// 将传递给子组件的状态和更新方法放在同一个组件中，方便维护和管理
export class App extends PureComponent {
  // 状态
  state = {
    x: 0,
  }

  // 更新状态
  updateX(x) {
    this.setState({ x })
  }

  render() {
    return (
      <>
        <PointerContext.Provider value={{ x: this.state.x, updateX: x => this.updateX(x) }}>
          <Child />
        </PointerContext.Provider>
      </>
    )
  }
}

export default App
```



`后代组件`

```jsx
import React, { PureComponent } from 'react'
import { PointerContext } from './context'

export class Cpn extends PureComponent {
  render() {
    return (
      <>
        <PointerContext.Consumer>
          {({ x, updateX }) => (
            <div>
              <h1>{x}</h1>
              <button onClick={() => updateX(x + 1)}>Increment</button>
              <button onClick={() => updateX(x - 1)}>Decrement</button>
            </div>
          )}
        </PointerContext.Consumer>
      </>
    )
  }
}

export default Cpn
```

