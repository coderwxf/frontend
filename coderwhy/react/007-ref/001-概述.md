在react中 不要通过原生方式 「 例如 querySelector 」去获取DOM元素

因为原生方式去获取DOM元素，是在全局进行查找和获取的

所以通过原生方式去获取的DOM元素可能并不是我们所需要的那个DOM元素

```jsx
import { PureComponent, createRef } from 'react'

export class App extends PureComponent {
  // 1. dom元素只是获取，一般不修改，即使修改了也需要rerender 所以不需要定义在state中
  // 2. createRef没有参数，返回结果默认值是 { current: null } -- 对应的dom元素会被挂载到current属性上
  dom3Ref = createRef()

  componentDidMount() {
    console.log(this.refs.dom1Ref) // 字符串形式的ref会被挂载到this.refs上
    console.log(this.dom2Ref)
    console.log(this.dom3Ref.current) 
  }

  render() {
    return (
      <>
        <div ref='dom1Ref'>dom1</div>
        <div ref={el => this.dom2Ref = el}>dom2</div>
        <div ref={ this.dom3Ref }>dom3</div>
      </>
    )
  }
}

export default App
```

```js
import { PureComponent, createRef, memo, forwardRef } from 'react'
import Cpn from './Cpn' // 假设Cpn是一个类组件

// forwardRef会给函数组件添加ref参数 -- 值会通过函数组件ref prop传递进来
const Child = memo(forwardRef((prop, ref) => {
  return (
    <div ref={ref}>Child</div>
  )
}))

export default class App extends PureComponent {
  classRef = createRef()
  funRef = createRef()

  componentDidMount() {
    // 类组件获取到的是组件实例 --- 且所有属性和方法都是公开可访问的
    console.log(this.classRef.current)
    // 函数组件没有组件实例 --- 必须将ref通过forwardRef转发到某个具体的DOM元素上
    console.log(this.funRef.current)
   }

  render() {
    return (
      <>
        <Child ref={this.funRef} />
        <Cpn ref={this.classRef} />
      </>
    )
  }
}
```



如果 `memo` 和  `forwardRef` 同时使用, 需要使用`memo(forwardRef(Component))`， 而不是`forwardRef(memo(Component))`

因为`forwardRef`需要给函数组件新增加一个`ref属性`

+ `memo(forwardRef(Component))`这种调用方式 `forwardRef`可以直接将ref传递给`Component`
+ `forwardRef(memo(Component))`这种调用方式 `forwardRef`将ref传递给了memo函数，但是memo并没有将该ref在传递给Component --- 这会导致ref转发失败

