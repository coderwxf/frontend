类型映射是指通过遍历现有类型的属性并应用特定规则来生成新类型。在 TypeScript 中，这通常通过使用 `in` 关键字来实现。

**语法：**  

```typescript
type NewType = {
  [Prop in keyof ExistingType]: NewTypeForProp;
};
```

- `keyof ExistingType`：获取类型 `ExistingType` 的所有属性名。
- `Prop`：循环变量，代表每个属性名。
- `NewTypeForProp`：新属性的类型。



```ts
type A = {
  foo: number;
  bar: number;
};

type B = {
  [prop in keyof A]: string;
};
// 结果：B 的每个属性类型都变成了 string
```



## 单个属性名映射

```ts
type MyObj = {
  [p in 'foo']: number;
};
// 结果：MyObj 只有一个属性 'foo'，类型为 number
```



## 字符串属性名映射

```ts
type MyObj = {
  [p in string]: boolean;
};
// 结果：MyObj 可以有任意字符串属性名，类型为 boolean
```



## 映射修饰符

**添加或移除修饰符：**

- `+?` 和 `-?`：用于添加或移除可选属性。
- `+readonly` 和 `-readonly`：用于添加或移除只读属性。

**注意：** `+` 是默认值，可以省略。



**将属性变为可选 => `Partial<T>`**

```ts
type Partial<T> = {
  [P in keyof T]?: T[P];
};
```



**将属性变为只读 => `Readonly<T>`**

```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```



## 键名重映射

**语法：**

```typescript
type NewType = {
  [Key in keyof OldType as NewKey]: ValueType;
};
```

- `Key` 是旧类型中的键名。
- `NewKey` 是经过 `as` 重映射后的新键名。



```ts
type User = {
  name: string;
  age: number;
};

// 只保留属性值为字符串的属性
type Filter<T> = {
  [K in keyof T as T[K] extends string ? K : never]: string;
};

type FilteredUser = Filter<User>;
// 结果：FilteredUser 只有 'name' 属性
```

```ts
type S = {
  kind: 'square';
  x: number;
  y: number;
};

type C = {
  kind: 'circle';
  radius: number;
};

type MyEvents<Events extends { kind: string }> = {
  [E in Events as E['kind']]: (event: E) => void;
};

// Events 的值是 S | C
type Config = MyEvents<S | C>;
/*
	`A | B extends C` 表示联合类型 `A | B` 的每个成员都必须满足 `C` 的约束条件
  
  type Config = {
    square: (event: S) => void;
    circle: (event: C) => void;
  }
*/
```



