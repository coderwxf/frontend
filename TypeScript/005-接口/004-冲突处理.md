## 属性冲突

```ts
interface Foo {
  id: string | number | boolean;
}

interface Bar {
  id: number;
}

// 同名属性id 
// 本质就类似于 将Baz.id 赋值给 Foo.id 以及将 Baz.id 赋值给 Bar.id
// 所以Baz.id 必须同时是 Foo.id 和 Bar.id 的子类型 -- 否则就会类型冲突
interface Baz extends Foo, Bar {
  id: number
  type: string;
}
```



## 方法冲突

方法冲突会构成方法重载

```ts
interface Cloner {
  clone(animal: Animal): Animal;
}

interface Cloner {
  clone(animal: Sheep): Sheep;
}

interface Cloner {
  clone(animal: Dog): Dog;
  clone(animal: Cat): Cat;
}

// 等同于
// 后面的定义比前面的定义具有更高的优先级，位于更前边
interface Cloner {
  clone(animal: Dog): Dog;
  clone(animal: Cat): Cat;
  clone(animal: Sheep): Sheep;
  clone(animal: Animal): Animal;
}
```



但如果有一个参数是字面量类型，字面量类型有更高的优先级

```ts
interface A {
  f(x:'foo'): boolean;
}

interface A {
  f(x:any): void;
}

// 等同于
interface A {
  f(x:'foo'): boolean;
  f(x:any): void;
}
```



如果两个 interface 组成的联合类型存在同名属性，那么该属性的类型也是联合类型

```ts
interface Circle {
  area: bigint;
}

interface Rectangle {
  area: number;
}

declare const s: Circle | Rectangle;

s.area;   // bigint | number
```

