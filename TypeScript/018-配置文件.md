`tsconfig.json` 是 TypeScript 项目的配置文件，用于指定 TypeScript 编译器（`tsc`）的配置。

通常放在项目的根目录。如果一个目录中存在 `tsconfig.json`，TypeScript 会将其视为项目的根目录。

如果没有配置，则使用默认配置。

如果即存在命令行传入配置，也存在配置文件中配置。命令行中配置优先级更高



使用 `tsc --init` 命令可以自动生成一个默认的 `tsconfig.json` 文件。

```ts
{
  "compilerOptions": {
    "outDir": "./built", // 输出目录
    "allowJs": true, // 允许编译JavaScript文件
    "target": "es5" // 编译为ES5版本的JavaScript
  },
  "include": ["./src/**/*"] // 包含src目录下的所有文件
}
```



可以使用预定义的 `tsconfig.json` 模板，这些模板以第三方库方式发布，以 `@tsconfig` 为前缀。

```ts
{
  "extends": "@tsconfig/recommended"
}
```



## ==`jsconfig.json`==

如果项目源码是 JavaScript，但希望用 TypeScript 工具处理，则使用 `jsconfig.json`

其配置方式与 `tsconfig.json` 相同。



## 一级属性

## include

1. 指定要编译的文件列表，支持通配符。
2. 文件路径相对于当前配置文件

**通配符**：

- `?`：匹配单个字符。

- `*`：匹配任意字符（不包括路径分隔符）。

- `**`：匹配任意目录层级。

- **默认文件类型**：如果不指定后缀名，默认包括 `.ts`、`.tsx` 和 `.d.ts` 文件。若开启 `allowJs`，还包括 `.js` 和 `.jsx` 文件。

- **示例**：

  ```json
  {
    "include": ["src/**/*", "tests/**/*"]
  }
  ```



## exclude

1. 从编译列表中排除指定的文件
2. 必须与 `include` 属性一起使用。
3. 规则和include一致

```ts
{
  "include": ["**/*"],
  "exclude": ["**/*.spec.ts"]
}
```

文件同时存在，以`exclude`中为主



## extends

1. 当前配置继承于另一个配置
2. 可以将多个项目的公共配置写在一个基础配置文件中（如 `tsconfig.base.json`），其他配置文件继承这个基础文件，便于维护。
3. 继承的配置文件会先加载，如果当前文件有相同的属性，当前文件的设置会覆盖继承的设置。

**本地继承**：

```json
{
  "extends": "../tsconfig.base.json"
}
```

当路径不以 `./` 或 `../` 开头时，编译器会在 `node_modules` 中查找。

```ts
{
  "extends": "@tsconfig/node12/tsconfig.json"
}
```



## files

+ 明确指定要编译的文件列表。
+ 是一个数组，必须列出每个文件
+ 文件不存在会报错。
+ 排在前面的文件先编译。
+ 文件多时使用 `include` 和 `exclude`，而不是 `files`。

```ts
{
  "files": ["a.ts", "b.ts"]
}
```



## references

`references` 属性非常适合用于 Monorepo 类型的项目

`extends`是基于配置文件进行修改

`references`是将多个配置文件进行整合管理

```shell
/monorepo
  ├── /packages
  │   ├── /pkg1
  │   │   └── tsconfig.json # 设叫 => 配置文件1
  │   ├── /pkg2
  │   │   └── tsconfig.json # 设叫 => 配置文件2
  └── tsconfig.json # 设叫 => 根配置文件
```



`根配置文件`

```ts
{
  "references": [
    // 值可以是具体的TS配置文件，也可以是文件夹「 TS会自动进行查找 」
    { "path": "./packages/pkg1" },
    { "path": "./packages/pkg2/tsconfig.json" }
  ]
}

```



`子配置文件`

```ts
{
  "compilerOptions": {
    // 子配置文件必须开始增量编译 『 开启后TS值会对编译部分进行检测，以提升性能 』
    "composite": true,
    // ...
  },
  // ...
}

```

> 设置 `composite: true` 的项目会生成额外的元数据文件（如 `.tsbuildinfo`），用于跟踪编译状态。



## compilerOptions

`compilerOptions` 是用于定制 TypeScript 编译行为的配置项。如果省略，编译器将使用默认设置。



## compilerOptions

### `allowJs`

- **作用**：允许 TypeScript 项目加载 JavaScript 文件。

- **效果**：编译时会将 JavaScript 文件一起拷贝到输出目录。

- **示例**：

  ```json
  {
    "compilerOptions": {
      "allowJs": true
    }
  }
  ```



### `allowSyntheticDefaultImports`

默认值 => `false`

- **开启时 (`true`)**：

  - 允许使用类似 ESM 的语法（例如 `import React from "react";`）来导入 CommonJS 模块，即使这些模块没有默认导出。
  - 编译器会生成适当的导入代码，以便在目标环境中正常工作。在支持 ESM 的环境中（如 Node.js 16+），可能会保持为 ESM 语法。

- **关闭时 (`false`)**：

  - 必须使用 CommonJS 风格的导入（如 `const React = require('react');`）或者 TypeScript 特定的导入方式（如 `import * as React from 'react';`）。
  - 如果尝试使用默认导入语法导入没有默认导出的模块，会导致编译错误。

  

### `baseUrl`

- **作用**：指定 TypeScript 项目的基准目录。设置 `baseUrl` 后，所有非相对模块导入都会基于这个路径进行查找。

- **默认行为**：以 `tsconfig.json` 的位置作为基准目录。

- **示例**：

  ```json
  {
    "compilerOptions": {
      "baseUrl": "./"
    }
  }
  ```

  这样，当遇到以下语句时，TypeScript 将以 `./` 为起点寻找 `hello/world.ts`：

  ```javascript
  import { helloWorld } from "hello/world";
  ```



### checkJs

- **作用**：对 JavaScript 文件进行类型检查。
- **效果**：会自动打开`allowJs` 并在在 JS 脚本头部添加 `// @ts-check`



### `composite`

- 开启`composite`后，该配置文件可以被父目录配置文件通过`references`选项进行引用
- 开启`composite`后，会自动开启`incremental` => 从而提升编译速度
- 开启`compostie`后，一般需要指定`rootDir`和`outDir` => 从而确保TS编译后的JS目录结构和源码的目录结构保持一致



### incremental

在 TypeScript 中，开启 `incremental` 编译选项后，编译器会生成一个 `.tsbuildinfo` 文件。

这个文件用于记录编译状态和依赖信息，以便在下次编译时能够识别哪些文件发生了变化，从而只重新编译这些修改过的文件。

这种增量编译方式可以显著提高大型项目的编译速度。



### `declaration`

- **作用**：为每一个TS文件生成对应的`d.ts`文件

- 可以结合其余配置项控制`d.ts`输出文件夹「 `declarationDir` 」和是否生成对应的map映射文件 「 declarationMap 」

- 默认情况下 ，会为每个TS文件生成d.ts文件。如果需要合并需要使用第三方插件

- **示例**：

  ```json
  {
    "compilerOptions": {
      "declaration": true
    }
  }
  ```



### emitDeclarationOnly

- **功能**：仅生成 `.d.ts` 声明文件，不生成 `.js` 文件。
- **用途**：在需要类型声明而不需要 JavaScript 输出的情况下使用，比如发布库时。



### forceConsistentCasingInFileNames

默认值true

引入文件时，对路径进行大小写区分处理



### exactOptionalPropertyTypes

- **功能**：设置可选属性不能显式赋值为 `undefined`。

- **示例**：

  ```typescript
  interface MyObj {
    foo?: 'A' | 'B';
  }
  
  let obj: MyObj = { foo: 'A' };
  obj.foo = undefined; // 报错
  ```



### `isolatedModules`

- **默认行为**：在 TypeScript 中，文件通常可以共享全局作用域的信息。
- **开启后**：
  - 每个 TypeScript 文件必须显式成为一个模块。这意味着每个文件需要通过导入或导出语句来标识自己。
  - 这有助于像 Babel 这样的工具正确处理每个文件，因为它们不能像 TypeScript 编译器那样访问全局类型信息。
- **限制**：
  - 某些 TypeScript 特性无法使用，例如命名空间，因为它们依赖于全局的类型合并。



### JSX

+ **preserve** => 默认值 「 TSX => JSX 」
+ **react** 「 TSX / JSX => `React.createElement` 」



### lib

`lib`值是一个数组，描述项目需要加载的 TypeScript [内置类型描述文件](https://github.com/microsoft/TypeScript/tree/main/src/lib)

跟三斜线指令`/// <reference lib="" />`作用相同。

```ts
{
  "compilerOptions": {
    "lib": ["dom", "es2021"]
  }
}
```

如果不指定，TS编译器会自动根据去加载需要使用的类型声明文件

而如果指定了`lib`，那么TS编辑器就会关闭自动加载行为，此时需要手动列出所有需要使用的类型声明文件



### target

指定编译输出的 JavaScript 版本。

设置完`target`后，会自动设置`module` 「 编译输出的模块格式。 」

而`module`又会自动设置`moduleResolution` 「 模块的自动加载规则 」

推荐设置为`ESNext`，而JS版本降级工作可以交给babel等其余工具来完成

> 虽然TS会实现类似于`polyfill`的功能
>
> 一些新增语法特性「 Proxy、Reflect 」等
>
> 老版本根本没有，也无法模拟实现 「 运行环境就不支持 」
>
> 此时如果`target`指定的版本较低，这些API就无法使用，使用编译就会报错



### moduleSuffixes

设置引入文件默认加载的后缀名

```ts
{
  "compilerOptions": {
    "moduleSuffixes": [".ios", ".native", ""]
  }
}
```

此时TS编译器会自动加载

1. `xxx.ios.ts` 和 `xxx.ios.tsx`
2. `xxx.native.ts` 和 `xxx.native.tsx`
3. `xxx.ts` 和 `xxx.tsx`



### noEmit

**概念**：`noEmit`决定是否输出编译结果。

+ 默认值是false

- 如果设置为`true`，TypeScript编译器只进行类型检查，不生成任何编译后的文件。



### noEmitOnError

**概念**：`noEmitOnError`决定是否在编译出错时生成编译文件。

- 默认值为`false`，即使有错误也会生成文件。



### noEmitHelpers

TS会被编译为`<taeget>`版本的JS版本文件

此时如果target中某些JS语法不支持，TS会注入辅助函数「 helper 」函数帮助我们实现 「 功能类似于polyfill 」

但默认情况下，这些helper方法会直接编译到对应文件中，可以设置`noEmitHelpers`, 告诉TS编译器不要

将helper注入对应JS文件中，我将对应`helper`方法放到了`tslib`这个库中，你直接从这里引入即可

所以这种情况下，需要手动安装库``tslib`



#### 示例

```ts
class Animal {
  move() {}
}

class Dog extends Animal {
  bark() {}
}
```

假设`noEmitHelpers`的值是`false`, 会注入类似于如下的`helper`方法

```ts
var __extends = (this && this.__extends) || function (d, b) { /* implementation */ };
```

而`noEmitHelpers`的值为`true`的时候

```ts
import { __extends } from 'tslib';
```



### noFallthroughCasesInSwitch

+ 默认值`false`
+ 如果代码出现case穿透，TS会给对应case分支报错

```ts
function example(flag: number) {
  switch (flag) {
    case 1:
      console.log("Case 1");
      // break; // 如果noFallthroughCasesInSwitch为true，这里会报错
    case 2:
      console.log("Case 2");
      break;
    default:
      console.log("Default case");
  }
}
```



#### `noImplicitAny`

- **功能**：控制是否允许隐式的 `any` 类型。
- **默认值**：`true`。
- **作用**：如果编译器无法推断出具体类型且没有明确的类型描述，就会报错。



### `outDir`

- **功能**：指定编译后文件的存放目录。

- **作用**：组织编译输出，通常用于将所有编译结果放在一个特定的文件夹中。

- **例子**：

  ```json
  {
    "compilerOptions": {
      "outDir": "./dist"
    }
  }
  ```

  这会将编译后的文件放在 `dist` 目录中。



### resolveJsonModule

**作用**：允许使用 `import` 导入 JSON 文件。这在处理配置文件或数据文件时非常有用。



### strict

`strict` 是一个总开关，用于开启 TypeScript 的严格检查模式。开启后，相当于同时激活一系列更严格的类型检查选项。

默认值是false

```ts
{
  "compilerOptions": {
    // strict是一系列选项总开关
    // 开启所有严格检测功能，但关闭其中某一个具体项
    "strict": true,
    "alwaysStrict": false
  }
}
```



### `alwaysStrict`

- **作用**：确保脚本以 ECMAScript 严格模式进行解析。
- **默认值**：`true`，因此脚本头部不用写 `"use strict"`。
- **意义**：严格模式可以帮助捕捉一些常见错误，提升代码的安全性。



### strictPropertyInitialization

类的实例属性必须通过类成员表达式或在构造函数中被赋予初始值

除非该实例属性可选属性 「 或某个值和undefined的联合 」，或使用了非空断言

```ts
// strictPropertyInitialization: true
class User {
  // 报错，属性 username 没有初始化
  username: string;
}
```



### suppressExcessPropertyErrors

是否开启对象字面量的多余属性检测

默认值true



### useUnknownInCatchVariables

默认情况下，catch捕获的错误类型是`any`

开启`useUnknownInCatchVariables`后，错误的类型会变成`unknown`



### rootDir

指定源码所在目录

TS会编译源码中的TS文件，并按照相同的目录结构输出编译后的JS文件

```ts
{
  "compilerOptions": {
    "rootDir": "src"
  }
}
```



### strictBindCallApply

`strictBindCallApply` 关闭时， `call()`、`bind()`、`apply()` 方法中的`this`类型是`any`

```ts
function fn(x: string) {
  return parseInt(x);
}

// strictBindCallApply: false
const n = fn.call(undefined, false); // 不报错
```

开启`strictBindCallApply`后，TS才会对修正的this进行类型检测



### `strictFunctionTypes`

关闭`strictFunctionTypes` => 函数参数只要满足类型兼容性就能通过

开启`strictFunctionTypes` => 函数参数必须严格一致，才能通过校验

```ts
function fn(x: string) {
  console.log('Hello, ' + x.toLowerCase());
}

type StringOrNumberFunc = (ns: string | number) => void;

// 打开 strictFunctionTypes，下面代码会报错 => 没有处理number情况下的业务逻辑
let func: StringOrNumberFunc = fn;
```

