## 实例属性

类的属性可以在顶层声明，也可以在构造方法内部声明

```ts
class Point {
  x:number; // 定义实例属性
  y = 0; // 赋初始值，自动类型推断
}
```

```ts
class A {
  constructor(public id: string) {
    this.id = 'bar'; // 正确
  }
}
```



`strictPropertyInitialization`

1. TS配置选项 -- 默认值是`true`
3. 开启后，实例属性必须在定义时被初始化，或使用非空断言

```ts
class Point {
  x!:number;
  y = 0; 
}
```



## readonly

类只读属性初始化有两个地方

1. 构造函数
2. 类表达式

```ts
class Point {
  // 设置位置1
  readonly x: number = 2;
  readonly y: number = 3;

  constructor() {
    // 设置位置2 -- 两者冲突以构造函数中的为准 「 构造函数可以修改readonly成员的初始值 」
    this.y = 5;
  }
}
```



## 方法

类中方法类型定义和普通方法类型完全一致

```ts
class Point {
  x:number;
  y:number;

 	// 唯一的区别是 构造方法不能有返回值类型
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }

  // Point 表示类的实例成员类型
  add(point:Point) {
    return new Point(
      this.x + point.x,
      this.y + point.y
    );
  }
  
  // 方法重载
  print(x: number):void;
  print(x: number, y: number):void;
  print(x: number, y?: number) {
    console.log(x, y)
  }
}
```



## 存取器

1. 只有getter 没有setter， 属性会变成只读属性

```ts
class C {
  _name = 'foo';

  get name() {
    return this._name;
  }
}

```



2. 在TypeScript 5.1之前，getter的返回值必须是setter参数的子类型

   ```ts
   class C {
     _name = '';
     get name():string {
       return this._name;
     }
     set name(value:number|string) { // value的类型必须是string的子类型
       this._name = String(value);
     }
   }
   ```

   TypeScript5.1之后，这个限制被取消了

   ```ts
   class C {
     _name = '';
     get name():string { 
       return this._name;
     }
     set name(value:number) { // success
       this._name = String(value);
     }
   }
   ```

3. `get`方法与`set`方法的可访问性必须一致，要么都为公开方法，要么都为私有方法



## 索引类型

```ts
class MyClass {
  // 方法是特殊属性，所以索引类型中，必须包含所有的方法类型
  [s:string]: boolean | ((s:string) => boolean);

  get(s:string) {
    return this[s] as boolean;
  }
  
  // 存储器 视为特殊属性 而不是方法
   get isInstance() {
    return true;
  }
}
```

