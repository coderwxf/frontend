## 基本使用

属性的类型可以用分号结尾，也可以用逗号结尾, 也可以不以任何符号结尾

```ts
type Point = {
  x:number;
  y:number;
};

type Point = {
  x:number,
  y:number,
};

type Point = {
  x:number
  y:number
}
```



除了使用类型别名定义对象结构，也可以通过接口定义对象结构

```ts
type Point = {
  x:number;
  y:number;
}

interface Point {
  x: number;
  y: number;
}
```



TypeScript 不区分对象自身的属性和继承的属性，只要可以通过赋值的对象获取到对应属性且类型正确即可

```ts
interface MyInterface {
  toString(): string; // 继承的属性
  prop: number; // 自身的属性
}

const obj: MyInterface = { // 正确
  prop: 123,
}
```



## 方法定义

```ts
type Point = {
  x:number;
  y:number;
  add(x:number, y:number): number; // 方式一
  sub: (x:number, y:number) => number; // 方式二
}
```



对象类型可以使用方括号读取属性的类型。

```ts
type User = {
  name: string,
  age: number
};
type Name = User['name']; // string
```



## 可选属性

```ts
const Point: {
  x: number;
  y?: number;
} = { x: 1, y: undefined }; // 可选属性可以赋值为undefined
```

可选属性与允许设为`undefined`的必选属性是不等价的

```ts
type A = { x:number, y?:number };
type B = { x:number, y:number|undefined };

const ObjA:A = { x: 1 }; // 正确
const ObjB:B = { x: 1 }; // 报错
```



TypeScript 提供编译设置`ExactOptionalPropertyTypes`，开启后将不允许给可选属性显示赋值为`undefined`

必须同时开启 `ExactOptionalPropertyTypes` 和 `strictNullChecks`，这样才能确保在可选属性中不能显式地使用 `undefined`，并且 `undefined` 不能因为是其他类型的子类型而被赋值。

```ts
// 打开 ExactOptionsPropertyTypes 和 strictNullChecks
const obj: {
  x: number;
  y?: number;
} = { x: 1, y: undefined }; // 报错
```



## 只读属性

只读属性只能在对象初始化期间赋值，此后就不能修改该属性。

```ts
type Point = {
  readonly x: number;
  readonly y: number;
};

let p:Point = { x: 0, y: 0 };

p.x = 100; // 报错
```



如果属性值是一个对象，`readonly`修饰符并不禁止修改该对象的属性，只是禁止完全替换掉该对象。

这和const的功能是一致的

```ts
interface Home {
  readonly resident: {
    name: string;
    age: number
  };
}

const h:Home = {
  resident: {
    name: 'Vicky',
    age: 42
  }
};

h.resident.age = 32; // 正确

// 报错
h.resident = { 
  name: 'Kate',
  age: 23 
} 
```



如果一个对象有两个引用，其中一个变量是可写的，另一个变量是只读的，那么从可写变量修改属性，会影响到只读变量。

```ts
interface Person {
  name: string;
  age: number;
}

interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}

let w:Person = {
  name: 'Vicky',
  age: 42,
};

let r:ReadonlyPerson = w;

w.age += 1;
r.age // 43
```



只读断言可以将对象变成字面量类型，也可以实现类似于readonly关键字的功能

```ts
const myUser = {
  name: "Sabrina",
} as const;

myUser.name = "Cynthia"; // 报错
```

```ts
// 通过as const 生成了一个 对象字面量
// 将对象字面量类型赋值给了{ name: string } 
// 最终 类型依旧是 { name: string } 
const myUser:{ name: string } = {
  name: "Sabrina",
} as const;

myUser.name = "Cynthia"; // 正确
```



## 索引类型

用来定义一系列属性及其类型

对象索引类型的属性名的类型只能是 `string | number | symbol`

```ts
type MyObj = {
  // 属性名表达式: 类型 -- property是属性名，可以随便起
  [property: string]: string
};

const obj:MyObj = {
  foo: 'a',
  bar: 'b',
  baz: 'c',
};
```



对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索引

其中数值索引签名的值类型必须是字符串索引签名的值类型的子类型或相同类型 「 即需要实现类型兼容 」

因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名。

```ts
interface Example {
  [key: string]: string | number;  // 字符串索引签名
  [index: number]: number;  // 数值索引签名
}
```



在 TypeScript 中，`symbol` 类型的属性名和 `string` 类型的属性名是相互独立的，它们不会互相转换，也不要求它们之间的值类型具有兼容性。



在 TypeScript 中，单个属性的类型检查取决于属性名的类型。

+ 如果属性名是 `string` 或 `number`，那么该属性的值类型必须兼容字符串索引签名的值类型。

+ 如果属性名是 `symbol`，那么该属性的值类型必须兼容 `symbol` 索引签名的值类型。



## 解构

```ts
let { x: foo, y: bar }: { x: string; y: number } = obj;
```



## 严格字面量检查

赋值字面量时，会触发严格字面量检查

TypeScript 对字面量进行严格检查的目的，主要是防止拼写错误。一般来说，字面量大多数来自手写，容易出现拼写错误。

```ts
const point:{
  x:number;
  y:number;
} = {
  x: 1,
  y: 1,
  z: 1 // 报错 --- 不能存在多余属性
};
```



如果等号右边不是字面量，而是一个变量，就会走结构性原则，而不是严格字面量检查

```ts
const myPoint = {
  x: 1,
  y: 1,
  z: 1
};

const point:{
  x:number;
  y:number;
} = myPoint; // 正确
```



规避严格字面量检查方法

1. 使用中间变量
2. 使用索引签名
3. 使用类型断言
4. 关闭`suppressExcessPropertyErrors`
   + `suppressExcessPropertyErrors`用于控制是否开启多余属性检查



特例，如果变量的类型是`Object`或`object`，将不会有严格字面量检查

但因为`Object`或`object`只能调用对象的公共属性和公共方法，所以依旧无法调用用户自定义属性



## 最小可选属性规则 

如果某个类型的所有属性都是可选的，那么该类型的对象必须至少存在一个可选属性，不能所有可选属性都不存在。这就叫做“最小可选属性规则”。

```ts
type Options = {
  a?:number;
  b?:number;
  c?:number;
};

const opts = { d: 123 };

const obj:Options = opts; // 报错
```



如果想强制使用没有任何属性的对象，可以采用下面的写法。

```ts
interface WithoutProperties {
  [key: string]: never;
  [key: symbol]: never;
}
```
