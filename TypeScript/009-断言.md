## 自动类型推导

TypeScript 会根据变量的初始值自动推断其类型

```ts
let foo = 'a'; // TypeScript 推断 foo 为 string 类型
```



但在某些场景下，自动类型推导可能会识别错误

此时可以使用类型断言，告诉编译器某个值的具体类型，以绕过默认的类型推断



类型断言有两种语法：

- `<Type>value`：不能在 JSX 中使用。
- `value as Type`：推荐使用。

```ts
const username = document.getElementById('username'); // 推断为 Element

if (username) {
  (username as HTMLInputElement).value; // 正确
}
```



在 TypeScript 中，使用类型断言时需要满足以下条件：

- `expr as T` 中，`expr` 必须是 `T` 的子类型，或者 `T` 是 `expr` 的子类型。
- 如果这两个类型完全无关，就需要使用`any` 或 `unknown` 作为中介类型

```ts
const n = 1;
const m: string = n as unknown as string; // 使用 unknown 作为中介
```



## 常量断言 `as const`

在TypeScript中, 使用 `let` 声明的变量通常会被推断为基本类型。

- 例如，`let s = 'JavaScript'` 会被推断为 `string` 类型。

在TypeScript中，使用 `const` 声明的变量则会被推断为字面量类型。

- 例如，`const s = 'JavaScript'` 会被推断为类型 `"JavaScript"`。



`as const` 可以用于将变量的类型从更宽泛的类型缩小到具体的字面量类型。

它只能用于字面量，而不能用于变量或复杂表达式。

```ts
let s = 'JavaScript' as const; // s 的类型为 "JavaScript"

const v = {
  x: 1,
  user: { name: 'Klaus' },
} as const;
// v 的类型为 { readonly x: 1; readonly user: { readonly name: 'Klaus' } }

const nums = [1, 2, 3] as const; // nums 的类型为 readonly [1, 2, 3]

enum Foo {
  X,
  Y,
}

let e1 = Foo.X; // e1 的类型是 Foo
let e2 = Foo.X as const; // e2 的类型为 Foo.X
```



**类型声明优先**：

- 如果明确声明了类型，即使使用 `as const`，也会以声明的类型为准。

```typescript
const myUser: { name: string } = {
  name: "Sabrina",
} as const;

myUser.name = "Cynthia"; // 正确
```





## 非空断言 ！

非空断言用于告诉 TypeScript 编译器某个变量不会是 `null` 或 `undefined`，从而避免不必要的类型检查警告。

通常在变量使用时添加 `!`，表示该变量一定存在

非空断言在 `strictNullChecks` 编译选项开启时才有效。未开启时， `undefined` 或 `null`会作为除`never`类型外其余任意类型的子类型，所以此时编译器不会进行空值检测

```ts
class Point {
  x!: number; // 非空断言
  y!: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

const root = document.getElementById('root')!; // 断言 root 不会为 nullish值

let x: number | null = 2;
console.log(x!.toFixed()); // 断言 x 不会为 null
```



非空断言可能导致运行时错误，因为它假设值一定存在。通过类型缩小来进行类型保护通常更为的安全

```ts
const root = document.getElementById('root');

if (root === null) {
  throw new Error('Unable to find DOM element #root');
}

root.addEventListener('click', e => {
  // 处理事件
});
```



## 断言函数 assert function

断言函数是一种用于确保函数参数符合特定类型的特殊函数。

如果参数不符合要求，函数会抛出错误并中断执行；如果符合要求，代码将继续正常运行。

这本质上告诉 TypeScript 类型检测系统，类型会在运行时得到有效检测，可以安全地进行类型缩小。



**断言函数**使用 `asserts` 关键字，表示如果函数没有抛出错误，则参数是某种特定类型

1. `asserts x`：用于确保 `x` 不为 `null` 或 `undefined`。

2. `asserts x is Type`：用于断言 `x` 是某个特定类型 `Type`。



```ts
type AssertIsNumber = (value: unknown) => asserts value is number;

// 类型保护函数返回一个布尔值，用于在条件判断中缩小类型范围
const assertIsNumber: AssertIsNumber = (value) => {
  if (typeof value !== 'number') {
    throw new Error('Not a number');
  }
};

function toUpper(x: string | number) {
  assertIsNumber(x);
  return x.toFixed(); // 这里 x 被缩小为 number 类型
}
```

```ts
// NonNullable<T> 用于从泛型T中剔除nullish值
function assertIsDefined<T>(value: T): asserts value is NonNullable<T> {
  if (value === undefined || value === null) {
    throw new Error(`${value} is not defined`);
  }
}

// 简化版
function assert(x: unknown): asserts x {
  if (value === undefined || value === null) {
    throw new Error(`${value} is not defined`);
  }
}
```

