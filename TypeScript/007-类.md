在 TypeScript 中，可以在类中声明属性的类型：

```ts
class Point {
  x: number; // 显示声明类型为 number
  y = 2; // 自动推导类型为 number
}
```



启用 `strictPropertyInitialization` 时，类的属性必须在声明时或构造函数中初始化。

```ts
class Point {
  x = 2; // 初始化成功
  y: number; // 错误：未初始化
  z!: number; // 使用非空断言，表示此属性不会为空
}
```



`readonly` 修饰符用于声明只读属性，只能在声明或构造函数中赋值。

```ts
class A {
  readonly id: string = 'foo';

  constructor() {
    this.id = 'bar'; // 正确
  }
}

const a = new A();
console.log(a.id); // 输出: bar
// a.id = 'baz'; // 报错：只读属性不能被修改
```



类中可以定义方法，并使用重载来定义不同的参数类型，但只有一个实现。

```ts
class Point {
  x: number;
  y: number;

  constructor(x: number, y = 0) {
    this.x = x;
    this.y = y;
  }

  add(a: number, b: number): number;
  add(a: string, b: string): string;
  add(a: any, b: any): any {
    if (typeof a === 'number' && typeof b === 'number') {
      return a + b;
    } else if (typeof a === 'string' && typeof b === 'string') {
      return a + b;
    }
    throw new Error('Invalid arguments');
  }
}
```



存取器用于在获取或设置属性时执行自定义逻辑：

```ts
class C {
  private _name = '';

  get name(): string {
    return this._name;
  }

  set name(value: string) {
    this._name = value;
  }
}

const c = new C();
c.name = 'Alice'; // 调用 setter
console.log(c.name); // 调用 getter，输出: Alice
```



属性索引允许定义动态属性，支持不同类型的值：

```ts
class MyClass {
  [s: string]: boolean | ((s: string) => boolean);

  get(s: string) {
    return this[s] as boolean;
  }
}
```



## implements

`implements` 用于类实现接口或对象类型别名。实现接口后，类必须实现接口中定义的属性和方法。

```ts
interface Country {
  name: string;
  capital?: string; // 可选属性
}

class MyCountry implements Country {
  name = ''; // 必须实现 name 属性
  code = 1; // 可以存在额外属性
}
```



在实现接口的方法时，参数类型可以是接口中定义类型的父类型。

这样就可以确保实现类对应实例可以赋值给对应接口

```ts
interface A {
  foo(name: string): boolean;
}

class B implements A {
  foo(s: unknown) { 
    return true;
  }
}

const b = new B()
console.log(b.foo(1)) // success

let a: A = b
console.log(a.foo('Hello')) // success
console.log(a.foo(1)) // error
```



当使用 `implements` 关键字实现一个类时，TypeScript 会将该类的公共接口（公共属性和方法）视为接口

```ts
class Car {
  id: number = 1;
  move(num: number): void {};
}

class MyCar implements Car {
  id = 2;
  move(): void {};
}
```



如果类中有私有属性或方法，其他类无法实现它，因为私有成员不能在类外部访问。

```ts
class Car {
  private id: number = 1;
  move(num: number): void {}
}

class MyCar implements Car {
  // 无法实现，因为 id 是私有的
  id = 2; // 错误：'id' 属性在 'Car' 中是私有的
  move(): void {}
}
```



受保护属性可以在子类中访问，但不能通过 `implements` 来实现，只能通过继承 (`extends`)。

在这种情况下，`implements` 是多余的，因为子类继承了所有的公共和受保护成员。

```ts
class Car {
  protected id: number = 1;
  move(num: number): void {}
}

class MyCar extends Car {
  // 可以通过继承访问受保护属性
  move(): void {
    this.id = 2; // 合法
  }
}
```



接口只能定义类的公共接口，不能包含私有或受保护的成员。

```ts
interface Foo {
  // private member: {}; // 报错
}
```



使用 `implements` 关键字，类可以实现一个或多个接口，但需要避免属性冲突。

```ts
interface MotorVehicle {
  drive(): void;
}

interface Swimmable {
  swim(): void;
}

class AmphibiousCar implements MotorVehicle, Swimmable {
  drive() {}
  swim() {}
}
```



**简化方式**：

- 使用类继承来组合功能。
- 通过接口继承创建更大的接口。

```ts
interface SuperVehicle extends MotorVehicle, Swimmable {}

class AdvancedCar implements SuperVehicle {
  drive() {}
  swim() {}
}
```



当类和接口同名时，接口的属性和方法会合并到类中。「 不推荐 」

```ts
class A {
  x: number = 1;
}

interface A {
  y: number;
}

let a = new A();

// 合并只影响类型，不影响实例化时的属性初始化
console.log(a.y); // undefined
a.y = 10; // 可以为 y 赋值
```

这种方式只能确保`a.y`只能憋赋值为数值类型值。

但并不影响初始值，且在使用 `a.y` 时，不需要进行类型缩小，因为类型系统已经将 `y` 视为 `number`



##  类类型与构造函数类型

- **实例类型**：当你实例化一个类时，实例的类型就是这个类的类型。

- **构造函数类型**：类本身的类型是构造函数类型，表示如何创建实例。

  ```ts
  const green: Color = new Color('green');
  // green 的类型是 Color
  // 类的类型是 typeof Color，即 new (name: string) => Color
  ```



## 兼容性

TypeScript 使用结构类型系统来判断兼容性，这意味着只关心数据的结构，而不关心其具体类型。只要两个对象的结构相同，它们就是兼容的。

```ts
class Foo {
  id: number;
}

function fn(arg: Foo) { }

const bar = {
  id: 10,
  amount: 100,
};

fn(bar); // 正确
```

```ts
class Person {
  name: string;
}

class Customer {
  name: string;
}

const cust: Customer = new Person(); // 正确
```



静态成员和构造函数不影响实例的兼容性检查

只要 `p` 对象有 `x` 和 `y` 属性，它就是 `Point` 类型兼容的，即使 `Point` 类有静态成员 `t` 和构造函数。

```ts
class Point {
  x!: number;
  y!: number;
  static t: number;
  constructor(x: number) {}
}

const p = {
  x: 1, 
  y: 2, 
  z: 3
}

const point: Point = p; // 正确
```



私有和保护成员的兼容性要求类之间有继承关系。

- **私有成员**：

  ```ts
  class A {
    private name = 'a';
  }
  
  class B extends A {}
  
  const a: A = new B(); // 正确
  ```

- **保护成员**：

  ```ts
  class A {
    protected name = 'a';
  }
  
  class B extends A {
    protected name = 'b';
  }
  
  const a: A = new B(); // 正确
  ```



在 TypeScript 中，子类的实例可以赋值给父类的变量。这是因为子类继承了父类的属性和方法，因此它们符合父类的类型要求。

```ts
class A {}

class B extends A {}

const b = new B();
const a: A = b; // 子类实例赋值给父类类型的变量
```



子类可以重写父类的方法，但 TypeScript 要求子类的方法签名必须与父类的相同或更宽松。

```ts
class A {
  greet() {
    console.log('Hello, world!');
  }
}

class B extends A {
  // 报错：参数不兼容
  greet(name: string) {
    console.log(`Hello, ${name}`);
  }
}
```



TypeScript 允许使用动态表达式来决定继承哪个类，只要结果是一个构造函数。

```ts
class A {
  name = 'Klaus';
}

class B {
  age = 23;
}

function getClass(flag: boolean) {
  return flag ? A : B;
}

// TS 可以推导出 getClass的返回值是 typeof A | typeof B
class C extends getClass(true) {}

// 所以TS知道 typeof c => A | B
const c = new C();

// 通过类型缩小确定具体类型
if ('name' in c) {
  console.log(c.name);
} else if ('age' in c) {
  console.log(c.age);
}
```



## override

使用 `override` 关键字可以明确表示某个方法是对基类方法的覆盖。

如果基类中没有相应的方法，使用 `override` 会导致编译错误。这有助于防止拼写错误或误用。



`noImplicitOverride` 是 TypeScript 的一个编译选项。

当启用时，所有子类中覆盖基类的方法都必须使用 `override` 关键字。这可以防止无意中覆盖基类的方法。

```ts
class A {
  hide() {
    // ...
  }
}

class B extends A {
  override show() { // error: 基类中没有 `show` 方法
    // ...
  }
  override hide() { // success: 正确覆盖基类的 `hide` 方法
    // ...
  }
}
```



##  成员修饰符

1. **public**

- 成员可以从任何地方访问。
- 如果没有指定修饰符，默认为 `public`。



2. **private**

- 成员只能在类内部访问。

- 实例和子类无法访问这些成员。

- 虽然可以通过方括号或 `in` 运算符访问私有成员，但这不是推荐的做法。

- 推荐使用 `#propName` 来实现真正的私有成员。

```ts
class A {
  private x = 1;
}

const a = new A();
console.log(a['x']); // 输出 1，不推荐

if ('x' in a) {
  // ...
}
```



3. **protected**

- 成员在类内部和子类中可访问，但实例无法访问。

- 子类可以实现父类 `protected` 同名属性，修饰符必须一致或更宽松。

```ts
class A {
  protected x: string = '';
  protected y: string = '';
  protected z: string = '';
}

class B extends A {
  public x: string = '';  // 正确
  protected y: string = '';  // 正确
  private z: string = '';  // 报错
}
```



成员修饰符可以用于修饰静态成员

```ts
class A {
  public static x = 1;
  protected static y = 1;
}

class B extends A {
  static getY() {
    return B.y;
  }
}

B.x; // 1
B.getY(); // 1
```



**示例**

单例模式确保一个类只有一个实例，并提供一个全局访问点。

```ts
class Singleton {
  private static instance?: Singleton;

  private constructor() {}

  static getInstance() {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}

const s = Singleton.getInstance();
```



### 简写方式

TypeScript 提供了一种简写形式，可以在构造函数中直接声明和初始化属性。

在构造函数参数中直接使用访问修饰符（`public`、`protected`、`private`）可以自动声明和初始化类的属性。

```ts
class A {
  constructor(
    // 此时可以确保属性在初始化实例时一定会被初始化
    // 因此不会触发strictPropertyInitialization的报错
    public readonly x: number,
    protected readonly y: number,
    private readonly z: number
  ) {}
}
```

#### 

## 泛型类

泛型类允许使用类型参数来定义类的属性和方法，从而使类能够处理多种类型。

```typescript
class Box<Type> {
  contents: Type;

  constructor(value: Type) {
    this.contents = value;
  }
}

const b: Box<string> = new Box('hello!');
```



### 静态成员与泛型

由于静态成员属于类本身，而不是某个实例，因此不能使用类的泛型类型参数。

```typescript
class Box<Type> {
  // static defaultContents: Type; // 这会报错，因为静态成员不能使用实例的泛型参数
}
```

可以通过定义泛型方法来处理不同类型的数据，而不依赖于类的泛型参数。

```typescript
class Box<Type> {
  contents: Type;

  constructor(value: Type) {
    this.contents = value;
  }

  static create<T>(value: T): Box<T> {
    return new Box(value);
  }
}

const stringBox = Box.create('hello!');
```

#### 

## 抽象类

抽象类使用 `abstract` 关键字定义，不能直接实例化，只能作为其他类的基础模板。

1. 抽象成员只能存在于抽象类中，不能在普通类中定义。
2. 抽象成员不能有具体实现。
3. 抽象成员不能使用 `private` 修饰符。
4. 子类只能继承一个抽象类（单继承模式）。

```typescript
abstract class A {
  id = 1;
}

// const a = new A(); // 报错
```

### 

抽象类只能作为基类使用，子类可以继承抽象类并实现其抽象成员。

```typescript
abstract class A {
  abstract amount: number;
  id = 1;
}

class B extends A {
  amount = 100;
}

const b = new B();
console.log(b.id); // 1
console.log(b.amount); // 100
```



抽象类可以继承其他抽象类。

```typescript
abstract class A {
  foo: number;
}

abstract class B extends A {
  bar: string;
}
```



## this

TypeScript 允许在函数中声明 `this` 参数，用于指定 `this` 的类型，以约束函数的调用方式。

这一参数不会在编译后的 JavaScript 中出现，因此必须作为第一个参数存在。

```ts
class A {
  name = 'A';

  getName(this: A) {
    return this.name;
  }
}

const a = new A();
const b = a.getName;

// b(); // 报错，因为 `this` 类型不匹配
```



### `noImplicitThis`

启用 `noImplicitThis` 编译选项后，如果 `this` 的值推断为 `any` 类型，会报错。

```typescript
class Rectangle {
  constructor(
    public width: number,
    public height: number
  ) {}
  
  getWidth() {
    return this.width;
  }

  getAreaFunction() {
    return function () {
      return this.width * this.height; // 报错，`this` 是 `any`
    };
  }
}
```



### `this` 作为类型

在类内部，`this` 可以用作类型，表示当前类的实例对象。

```typescript
class Box {
  contents: string = '';

  set(value: string): this {
    this.contents = value;
    return this;
  }
}
```



### 静态成员中的 `this`

`this` 类型不能用于静态成员，因为静态成员不属于实例对象。

```typescript
class A {
  // static a: this; // 报错
}
```



### `this is Type`

在 TypeScript 中，`x is Type` 是一种类型谓词，用于类型保护。

`this is Type` 是一种特殊的类型谓词形式，用于在类方法中进行类型保护。

```typescript
class FileSystemObject {
  isFile(): this is FileRep {
    return this instanceof FileRep;
  }

  isDirectory(): this is Directory {
    return this instanceof Directory;
  }

  // ...
}
```



## 顶层属性初始化问题

**初始化方式**：

1. **定义时初始化**：直接在属性声明时进行初始化。
2. **构造函数中初始化**：在构造函数中进行初始化。

**处理方式的变化**：

- **TS早期标准**：顶层属性的初始化延迟到构造函数中进行。

  - 「 因为当时 JavaScript 还没有明确的类字段初始化标准 」

- **ES2022标准**：顶层属性在声明时立即初始化，然后再运行构造函数。

  

```ts
class User {
  age = this.currentYear - 1998;

  constructor(private currentYear: number) {
    console.log('Current age:', this.age);
  }
}

const user = new User(2023);
```

- **ES2022之前**：`age` 的值是 `25`，因为初始化在构造函数中完成。
- **ES2022及以后**：`age` 的值是 `NaN`，因为 `currentYear` 在属性初始化时为 `undefined`。



### `useDefineForClassFields` 编译选项

为解决上述不一致，TypeScript 3.7 引入了 `useDefineForClassFields` 编译选项：

- **true**：使用 ES2022 标准，立即初始化。
- **false**：使用 TypeScript 早期方法，延迟初始化。

默认值与 `target` 属性有关，`target` 为 `ES2022` 或更高时，默认值为 `true`。



### 稳健性建议

为了避免不一致并保证代码的稳健性，建议将所有属性的初始化放入构造函数中：

```typescript
class User {
  age: number;

  constructor(private currentYear: number) {
    this.age = this.currentYear - 1998;
    console.log('Current age:', this.age);
  }
}

const user = new User(2023);
```

这样可以确保在任何环境下，代码的行为都是一致的。



或使用`declare`关键字

在 TypeScript 中，当你在子类中重新声明一个属性时，这个属性会被编译为实例属性，并默认初始化为 `undefined`

```ts
interface Animal {
  animalStuff: any;
}

interface Dog extends Animal {
  dogStuff: any;
}

class AnimalHouse {
  resident: Animal;

  constructor(animal: Animal) {
    this.resident = animal;
  }
}

class DogHouse extends AnimalHouse {
	// 会被编译为实例属性，并被赋值为undefined
	resident: Dog;

  constructor(dog: Dog) {
    super(dog);
  }
}

const dog = { animalStuff: 'animal', dogStuff: 'dog' };
const dogHouse = new DogHouse(dog);

console.log(dogHouse.resident);  // undefined
```

使用 `declare` 关键字告诉 TypeScript 这个属性存在，但不在这里实现。这意味着它不会在编译后的 JavaScript 中生成实例属性的初始化代码

```ts
interface Animal {
  animalStuff: any;
}

interface Dog extends Animal {
  dogStuff: any;
}

class AnimalHouse {
  resident: Animal;

  constructor(animal: Animal) {
    this.resident = animal;
  }
}

class DogHouse extends AnimalHouse {
  // 这里只是告诉TS，有这个属性，只是没有在这里定义 => TS在运行时会将其类型擦除
  declare resident: Dog;

  constructor(dog: Dog) {
    super(dog);
  }
}

const dog = { animalStuff: 'animal', dogStuff: 'dog' };
const dogHouse = new DogHouse(dog);

console.log(dogHouse.resident); 
/*
  {
    "animalStuff": "animal",
    "dogStuff": "dog"
  } 
*/
```

