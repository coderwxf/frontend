```ts
type MyObj = {
  x:number; // 以分号或逗号分割
  y:number; 
  // 函数表达式 定义类型
  add: (x:number, y:number) => number; 
  // 函数声明式 定义类型
  sub(x:number, y:number): number // 最后一个可以省略
};

// 成员属性
type x = MyObj['x'] // => number
```

一旦赋值对象类型，则确定了对象结构

1. 不能随意增加和删除属性
2. 不能访问不存在的属性
3. 赋值时，结构也必须保持一致



TS判断类型时，底层会通过属性名去获取对应的属性值类型，所以对象成员类型只要在原型链上实现即可

```ts
interface MyInterface {
  toString(): string; // 继承的属性
  prop: number; // 自身的属性
}

const obj:MyInterface = { 
  prop: 123,
}; // 正确
```



```ts
type Point = {
  readonly x: number; // 只读属性
  y?: number; // 可选属性
}
```



1. 如果同时开启 `ExactOptionalPropertyTypes` 和  `strictNullChecks`, 可选属性就不能被显示赋值为`undefined`