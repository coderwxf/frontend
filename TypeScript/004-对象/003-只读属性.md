```ts
type Point = {
  readonly x: number;
  readonly y: number;
};

const p: Point = { x: 0, y: 0 }; // 只读属性只能在对象初始化期间赋值，此后就不能修改该属性

p.x = 100; // 报错
```

1. 通过`readonly`设置属性是只读的
2. `readonly`的规则和`const`类似，锁死的是地址，地址对应的值依旧可以修改



如果一个对象有两个引用，即两个变量对应同一个对象，其中一个变量是可写的，另一个变量是只读的，那么从可写变量修改属性，会影响到只读变量

```ts
interface Person {
  name: string;
  age: number;
}

interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}

let w:Person = {
  name: 'Vicky',
  age: 42,
};

let r:ReadonlyPerson = w;

w.age += 1;
r.age // 43
```



## as const 

除了`readonly`可以设置属性只读，也可以使用`as const`只读断言设置整个对象都是只读的

`as const`本质是将对象转换为字面量类型，所以其是深层只读的，readonly只是锁死其修饰的那个属性

```ts
const myUser = {
  name: "Sabrina",
} as const;

myUser.name = "Cynthia"; // 报错
```



`as const`断言本质是一种特殊的类型推导，如果显示指定类型，`as const`断言会静默失效

```ts
const myUser:{ name: string } = {
  name: "Sabrina",
} as const;

myUser.name = "Cynthia"; // 正确
```

