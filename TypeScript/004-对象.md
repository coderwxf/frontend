在 TypeScript 中，可以使用大括号 `{}` 来描述对象的结构，指定每个属性的类型

属性可以用分号 `;`、逗号 `,` 或仅使用换行符分隔

```ts
type MyObj = {
  x: number;
  y: number;
};
```



在一个定义好的对象结构中：

1. 不能操作不存在的属性。
2. 不能删除声明中必须存在的属性（可选属性除外）。

```typescript
type MyObj = {
  x: number;
  y: number;
  z?: number; // 可选属性
};

let obj: MyObj = { x: 1, y: 2 };
delete obj.x; // 错误
```



可以为对象方法添加类型注解以明确方法的参数和返回值类型。

```typescript
type Add = {
  x: number;
  y: number;
  add(x: number, y: number): number; // 定义方式一
  sub: (x: number, y: number) => number; // 定义方式二
}
```



TypeScript 认为对象的属性无论是自身的还是继承的，只要满足类型约束就视为兼容。

```typescript
interface MyInterface {
  toString(): string; // 继承的属性
  prop: number; // 自身的属性
}

const obj: MyInterface = { 
  prop: 123,
}; // 正确
```

即使没有显式定义 `toString` 方法，`obj` 仍然满足 `MyInterface`。



## 对象值类型

使用方括号 `[]` 可以查询对象属性的类型。

```typescript
type User = {
  name: string;
  age: number;
};

type Name = User['name']; // string
```



## 可选属性

- 在 TypeScript 中，属性名后加问号 `?` 表示该属性是可选的。
- 可选属性的效果类似于该属性的类型和 `undefined` 的联合类型

```ts
type User1 = {
  firstName: string;
  lastName?: string; // lastName 可以不传，或传 undefined 或字符串类型值
};

type User2 = {
  firstName: string;
  lastName: string | undefined; // lastName 可以传 undefined 或字符串，但不能不传
};
```



### ExactOptionalPropertyTypes

当同时开启 `ExactOptionalPropertyTypes` 和 `strictNullChecks`，可选属性将不能再被显示赋值为`undefined` 「 要么传，要么不传 」

> 和`null`或`undefined`相关的配置时，一定先要开启`strictNullChecks`
>
> 如果关闭了`strictNullChecks`, 则会导致`null` 和 `undefined` 会被视为任意类型的子类型，这会导致赋值满足类型兼容性需求。此时开启其余配置都将没有任何意义



## 只读属性

- 在属性名前加 `readonly`，表示该属性为只读，不能修改。

- 只读属性只能在对象初始化时赋值，之后不能修改。

  1. 是在构造函数中进行初始化
  2. 是在定义成员变量的时候进行初始化
  3. 构造方法赋值的优先级比成员变量赋值的优先级高

- readonly是浅层只读，而只读断言是深层只读

- readonly只是类型约束，不影响JavaScript运行时行为

  ```ts
  interface Person {
    name: string;
    age: number;
  }
  
  interface ReadonlyPerson {
    readonly name: string;
    readonly age: number;
  }
  
  let w: Person = {
    name: 'Vicky',
    age: 42,
  };
  
  let r: ReadonlyPerson = w;
  
  w.age += 1;
  console.log(r.age); // 43
  ```

  

## 对象索引类型

+ 索引类型用于定义对象中可能存在的属性及其类型
+ 定义语法是 使用方括号 `[]` 语法
+ 索引类型应该是 `string`、`number` 或 `symbol`中的一种或几种。

```ts
type MyObj = {
  [property: string]: string;
};

const obj: MyObj = {
  foo: 'a',
  bar: 'b',
  baz: 'c',
};
```



- 当对象同时存在数值和字符串索引时，称为混合索引。
- 数值索引对应的值类型必须是字符串索引对应值类型的子类型，因为数值属性名会自动转换为字符串。
- 单个属性值也必须满足字符串索引的类型要求。

```ts
type MixedIndex = {
  [key: string]: string; // 字符串索引
  [index: number]: 'a' | 'b'; // 数值索引，值类型必须是字符串索引值类型的子类型
};

const example: MixedIndex = {
  0: 'a', // 数值索引，自动转换为字符串 '0'
  1: 'b',
  foo: 'hello', // 字符串索引
  bar: 'world',
};

// 错误示例
const invalidExample: MixedIndex = {
  0: 'c', // Error: 'c' 不是 'a' | 'b' 类型
  foo: 'hello',
};
```



在 TypeScript 中，`symbol` 类型的索引是独立的，不受 `string` 和 `number` 索引的限制

```ts
const sym1 = Symbol('sym1');
const sym2 = Symbol('sym2');

type SymbolIndex = {
  [key: string]: string; // 字符串索引
  [index: number]: string; // 数值索引
  [sym1]: number; // Symbol 索引
  [sym2]: boolean; // Symbol 索引
};

const example: SymbolIndex = {
  foo: 'hello',
  0: 'world',
  [sym1]: 42,
  [sym2]: true,
};
```



## 对象解构

在 TypeScript 中，解构时可以为对象属性指定类型

```typescript
const obj = { x: 10, y: 20 };
let { x: foo, y: bar }: { x: number; y: number } = obj;
```

注意：类型指定的是原始属性，而不是重命名后的变量名。

```ts
const obj = { x: 10, y: 20 };
let { x: foo, y: bar }: { foo: number; bar: number } = obj; // error
```



## 多余属性检测

如果将对象字面量赋值给对象类型，TypeScript会要求对象必须严格符合定义的结构。

不允许对象字面量中存在多余或缺少的属性。这种行为被称之为**多余属性检测**「 严格类型检测 （strict object literal checking） 」

```ts
type MyObj = {
  x: number;
  y: number;
};

const o1: MyObj = { x: 1 }; // 错误：缺少属性 y
const o2: MyObj = { x: 1, y: 1, z: 1 }; // 错误：多余属性 z
```

规避方法: 

1. 类型断言
2. 中间变量
3. 索引类型

可以通过关闭`suppressExcessPropertyErrors`配置项，来关闭TS的多余属性检测



## 最小可选属性规则

如果一个对象的所有属性都是可选的，那么理论上任何类型都可以被赋值给该对象

此时该对象的类型和any没啥区别，此时为了避免这种情况，TypeScript 引入了最小可选属性规则。

即：如果一个类型的所有属性都是可选的，那么赋值给该类型的对象必须至少存在一个可选属性。

```ts
type Options = {
  a?: number;
  b?: number;
  c?: number;
};

const opts = { d: 123 };
const obj: Options = opts; // 报错，因为没有 `a`, `b`, 或 `c`
```

规避方法:

1. 类型断言
2. 索引签名

```ts
type Options = {
  a?: number;
  b?: number;
  c?: number;
  [key: string]: unknown;
};

const opts = { d: 123 };
const obj: Options = opts; // 合法，因为类型允许任意键
```



## 空对象类型

在 TypeScript 中，`{}` 表示一个空对象类型，但它实际上可以接受任何值，因为它没有指定任何属性

空对象类型`{}`  本质是`Object`的简写 「 尽管 `{}` 看似表示空对象，但实际上它是一个宽泛的类型 」

空对象类型只能调用对象上的公共属性和公共方法



比较特殊的是，TypeScript认为空对象类型是所有类型的父类型，所以空对象类型没有多余属性检测

```ts
let d: {};

d = {}; // 正确
d = { x: 1 }; // 正确
d = 'hello'; // 正确
```



所以需要定义真正意义上的无属性对象，需要借助索引类型

```ts
interface WithoutProperties {
  [key: string]: never;
}

const a: WithoutProperties = {}; // 正确
const b: WithoutProperties = { prop: 1 }; // 报错
```



