## 特点

1. 所有成员的类型必须相同
2. 成员数量是不确定的，可以是无限数量的成员，也可以是零成员



## 定义方式

数组的类型有两种写法



第一种写法是在数组成员的类型后面，加上一对方括号。

```ts
let arr:number[] = [1, 2, 3];
```

如果数组成员的类型比较复杂，可以写在圆括号里面。
```ts
let arr:(number|string)[];
```



第二种写法是使用 TypeScript 内置的 Array 接口。

```ts
let arr:Array<number> = [1, 2, 3];
```

这种写法对于成员类型比较复杂的数组，代码可读性会稍微好一些。

```ts
let arr:Array<number|string>;
```



## 基本使用

由于成员数量可以动态变化，所以 TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。

```ts
let arr:number[] = [1, 2, 3];
let foo = arr[3]; // 正确
```



TypeScript 允许使用方括号读取数组成员的类型。

```ts
type Names = string[];
type Name = Names[0]; // string
```



由于数组成员的索引类型都是`number`，所以读取成员类型也可以写成下面这样。

```ts
type Names = string[];
type Name = Names[number]; // string
```



## 类型推导

如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型

```ts
const arr = []; // 推断为 any[]

arr.push(123);
arr // 推断类型为 number[]

arr.push('abc');
arr // 推断类型为 (string|number)[]
```

上面示例中，数组变量`arr`的初始值是空数组，然后随着新成员的加入，TypeScript 会自动修改推断的数组类型。



但是，类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。

```ts
// 推断类型为 number[]
const arr = [123];

arr.push('abc'); // 报错
```



## 只读数组

JavaScript 规定，`const`命令声明的数组变量是可以改变成员的。

```ts
const arr = [0, 1];
arr[0] = 2;
```



但是，很多时候确实有声明为只读数组的需求，即不允许变动数组成员。

TypeScript 允许声明只读数组，方法是在数组类型前面加上`readonly`关键字。

```ts
const arr: readonly number[] = [0, 1];

arr[1] = 2; // 报错
arr.push(3); // 报错
delete arr[0]; // 报错
```



其中，`number[]` 是 `readonly number[]`的子类型

子类型继承了父类型的所有特征，并加上了自己的特征

只读数组没有`pop()`、`push()`之类会改变原数组的方法，

所以`number[]`的方法数量要多于`readonly number[]`，

这意味着`number[]`其实是`readonly number[]`的子类型。



注意，`readonly`关键字不能与数组的泛型写法一起使用。

```ts
// 报错
const arr:readonly Array<number> = [0, 1];
```

实际上，TypeScript 提供了两个专门的泛型，用来生成只读数组的类型。

```ts
const a1:ReadonlyArray<number> = [0, 1];

const a2:Readonly<number[]> = [0, 1];
```

只读数组还有一种声明方法，就是使用“const 断言”。

```ts
const arr = [0, 1] as const;

arr[0] = [2]; // 报错 
```



## 多维数组

TypeScript 使用`T[][]`的形式，表示二维数组，`T`是最底层数组成员的类型。

```ts
let multi:number[][] = [[1,2,3], [23,24,25]];
```

`number[][]`本质是`(number[])[]` 即`Array<number[]>`

