## 值类型

只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。

```ts
let x:'hello';

x = 'hello'; // 正确
x = 'world'; // 报错
```

TypeScript 推断类型时，**遇到`const`命令声明的基本数据变量**，如果代码里面**没有注明类型**，就会推断该变量是值类型

```ts
// x 的类型是 "https"
const x = 'https';

// y 的类型是 string
const y:string = 'https';
```

注意，`const`命令声明的变量，如果赋值为对象，并不会推断为值类型。

因为 JavaScript 里面，`const`变量赋值为对象时，属性值是可以改变的。

```js
// x 的类型是 { foo: number }
const x = { foo: 1 };
```

如果要获取对象的值类型，可以使用`as const`断言

```js
// x 的类型是 { foo: 1 }
const x = { foo: 1 } as const;
```

运算得到的结果，类型不会为值类型，例如`4 + 1`的类型是`number`类型，不是值类型`5`

```ts
const x:5 = 4 + 1; // 报错
```



## 联合类型

联合类型`A|B`表示，任何一个类型只要属于`A`或`B`，就属于联合类型`A|B`。

例如: `true|false`其实就是布尔类型`boolean`。



联合类型的第一个成员前面，也可以加上竖杠`|`，这样便于多行书写。

```ts
let x:
  | 'one'
  | 'two'
  | 'three'
  | 'four';
```



使用联合类型之前，需要先经过类型缩小

“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。

实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing）。

```ts
function getPort(
  scheme: 'http'|'https'
) {
  switch (scheme) {
    case 'http':
      return 80;
    case 'https':
      return 443;
  }
}
```



## 交叉类型

交叉类型`A&B`表示，任何一个类型必须同时属于`A`和`B`，才属于交叉类型`A&B`，即交叉类型同时满足`A`和`B`的特征。

```ts
let x:number&string;
```

上面示例中，变量x同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为x的类型实际是never。



交叉类型的主要用途是表示对象的合成, 即用来为对象类型添加新属性。

```ts
type A = { foo: number };

// type B -> { foo: number; bar: number; }
type B = A & { bar: number };
```



## 类型兼容性 

TypeScript进行兼容性检测，基于结构性原则

根据“结构类型”原则，TypeScript 检查某个值是否符合指定类型时，并不是检查这个值的类型名（即“名义类型”），而是检查这个值的结构是否符合要求（即“结构类型”）。

如果类型`A`的值可以赋值给类型`B`，那么类型`A`就称为类型`B`的子类型（subtype）

子类型满足父类型的所有结构特征，同时还具有自己的特征。

凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型。「 子给父原则 」

```ts
let x: 5 = 5; // type x -> 5
let y: number = 4 + 1; // type y -> number

x = y; // 报错
y = x; // 正确
```

```ts
type myObj = {
  x: number,
  y: number,
};

function getSum(obj:myObj) {
  let sum = 0;

  // obj 可能是myObj的子类型，即除了x和y之外还有其余属性
  // obj[n]得结果不一定是number，也可能是string，因此最终会被推导为any
  for (const n of Object.keys(obj)) {
    const v = obj[n]; // 报错
    sum += Math.abs(v);
  }

  return sum;
}
```



## 块级类型声明

TypeScript的类型声明作用域和变量作用域一样，存在全局声明，函数声明和块级声明

```ts
if (true) {
  type T = number;
  let v:T = 5;
} else {
  type T = string;
  let v:T = 'hello';
}
```



## 类型别名

`type`命令用来定义一个类型的别名。

`type`命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。

1. 别名不允许重名。
2. 别名允许嵌套 「 可以在定义一个别名时，使用另一个别名 」
3. 别名支持表达式
4. 别名一般首字母大写 「 约定规则 」

```ts
type World = "world";
type Greeting = `hello ${World}`;
```



## typeof

TypeScript 将`typeof`运算符移植到了类型运算，它的操作数依然是一个值，

但是返回的不是字符串，而是该值的 TypeScript 类型。

```ts
const a = { x: 0 };

// type <类型别名> = typeof <值>
type T0 = typeof a;   // { x: number }
type T1 = typeof a.x; // number
```



也就是说，同一段代码可能存在两种`typeof`运算符，

一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分

它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。



编译时不会进行 JavaScript 的值运算，所以TypeScript 规定，typeof 的参数只能是标识符，不能是需要运算的表达式。

```ts
type T = typeof Date(); // 报错
```