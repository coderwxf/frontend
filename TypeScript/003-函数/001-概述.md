```ts
// arg不能省略 -- string => void 本质是 (string: any) => void
// 类型形参名 和 实际形参名 不需要保持一致
type Fun = (arg:string) => void

// txt:string -- 参数类型 void -- 返回值类型
const hello = function(txt:string) :void {
  console.log('hello ' + txt);
}
```

1. 参数类型和返回值类型可以省略 --- 类型推断 -- 推断失败，默认类型是any
2. 有时候出于文档目的，或者为了防止不小心改掉返回值 --- 依旧显示添加返回值类型



参数少的函数 可以赋值给 参数多的函数 --- 参数多定义了可以不用

```ts
let x = (a:number) => 0;
let y = (b:number, s:string) => 0;

y = x; // 正确
x = y; // 报错
```



## 函数对象

函数可以作为对象看待，可以存在对象写法 -- 即可以执行，也存在对应属性

```ts
interface myfn {
  (a:number, b:number): number; // 使用:分割，不使用=>分割
  version: string
}
```



## Function

Function 本质是`(...args: any[]) => any`的简写

1. 任何函数类型的父类型
2. 参数个数任意，类型是any
3. 函数返回值的类型也是any



## 可选参数

在参数名后面加问号表示可选参数 --- 类似于和undefined的联合，但实际还是有区别



1. 可选可以不显示传入undefined，联合undefined则必须传入undefined

```ts
function foo(a?: number) {}

foo() // success
foo(undefined) // success
foo(2) // success
```

```ts
function foo(a: number | undefined) {}

foo() // error
foo(undefined) // success
foo(2) // success
```



2. 可选类型表示可以省略，必须位于参数列表的最后, 联合undefined，可以在参数序列的任意位置

   ```js
   function sum1(num1: number, num2?: number) {} // 可以省略的参数，需要位于最后
   
   // 联合undefined可以位于任何位置，调用时显示传入undefined即可
   function sum2(num1: number | undefined, num2: number) {} 
   ```

   

可选类型 和 联合undefined的共同点是 在实际使用前都需要判断值为undefined的情况

```ts
let sum: (a:number, b?:number) => number; 

sum = function (x, y) {
  if (y === undefined) {
    return x;
  }
  return x + y;
}
```



## 默认值

1. 不需要设置参数类型 -- 可以通过默认值推导
2. 默认值和可选 不能同时存在
3. 不传值 或 值显示传递为undefined 时 会触发默认值

```ts
function createPoint( x = 0, y = 0 ) {
  return [x, y];
}
```



## 参数解构

```ts
type Ponit = {
  x: number;
  y: number;
}

function printPoint({ x, y }: Point) {}
```



## 剩余参数 

1. ... 表示剩余参数 又叫reset参数
2. 剩余参数 必须结合 数组或元组 一起使用

```ts
function repeat(...[str, times]: [string, number]):string {
  return str.repeat(times);
}
```



## void

void表示没有返回值

```ts
// strictNullChecks: false
function f():void {
  return null; // 正确
}

function f():void {
  return undefined; // 正确
}

// --------------------------------

// strictNullChecks: true
function f():void {
  return null; // 错误
}

function f():void {
  return undefined; // 正确
}
```



### 类型兼容性

```ts
type voidFunc = () => void;

// 有返回值的函数 可以赋值给 没有返回值的函数 -- 返回值可以存在，不使用即可 「类型兼容性」
const f:voidFunc = () => 123
```

```ts
// 显示声明void 就不能返回除undefined之外的值
function f(): void {
  return true; // 报错
}
```



函数抛出异常，函数的返回值可以是void 也可以是never

```ts
function throwErr():void {
  throw new Error('something wrong');
}
```



## never

1. 函数显示抛出异常
2. 死循环函数

```ts
// 抛出错误 -- 返回值是never
function fail(msg: string): never {
  throw new Error(msg);
}

// ---------------------------

// 返回实际错误，返回值是Error -- 不能是never
function fail():Error {
  return new Error("Something failed");
}
```

```ts
// 函数返回值是 number | never -- 通常可以简写为 number
function sometimesThrow():number {
  if (Math.random() > 0.5) {
    return 100;
  }

  throw new Error('Something went wrong');
}
```



## 局部类型

类型定义遵循块级作用域，所以函数内部定义的类型是局部类型

```ts
function hello(txt:string) {
  type message = string;
  let newTxt:message = 'hello ' + txt;
  return newTxt;
}

const newTxt:message = hello('world'); // 报错
```



## 函数重载

1. 函数名相同
2. 参数类型或个数不同

表现为 `同一个函数，传入不同的参数，执行不同的逻辑`

这种行为被称之为函数重载（function overload）

```ts
// 函数重载声明 -- 从上到下匹配第一个满足条件的类型
function reverse(str:string):string;
function reverse(arr:any[]):any[];
// 函数实现
// 1. 重载的各个类型描述与函数的具体实现之间，不能有其他代码，否则报错
// 2. 函数本身的类型声明，它必须与前面已有的重载声明兼容
// 3. 虽然函数的具体实现里面，有完整的类型声明。但是，函数实际调用的类型，以前面的类型声明为准
function reverse(stringOrArray:string|any[]):string|any[] {
  if (typeof stringOrArray === 'string')
    return stringOrArray.split('').reverse().join('');
  else
    return stringOrArray.slice().reverse();
}
```



一般来说，优先推荐使用联合类型，除非参数和返回值之间存在某种特定联系，才使用函数重载

```ts
function createElement(tag:'a'):HTMLAnchorElement;
function createElement(tag:'canvas'):HTMLCanvasElement;
function createElement(tag:'table'):HTMLTableElement;

function createElement(tag:string): HTMLElement {
 return document.createElement(tag)
}
```



## 构造函数

```ts
// 函数F 即可以作为构造函数使用，也可以作为普通函数使用
type F = {
  new (s:string): object;  // new关键字 表示这是一个构造函数
  (n?:number): number; // 这个一个普通函数
}
```

