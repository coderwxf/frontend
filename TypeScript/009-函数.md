```ts
function hello(txt:string): void {
  console.log('hello ' + txt);
}
```



如果不指定参数类型，TypeScript 就会推断参数类型，如果缺乏足够信息，就会推断该参数的类型为`any`。

如果不指定返回值，一般情况下，TypeScript 自己会推断出来 「 有时候出于文档目的，或者为了防止不小心改掉返回值，还是会写返回值的类型 」



```ts
let f:(x:number) => number;
 
f = function (y:number) {
  return y;
};
```

1. 类型里面的参数名（本例是`txt`）是必须的。

   如果写成`(string) => void`，TypeScript 会理解成函数有一个名叫 string 的参数，并且这个`string`参数的类型是`any`。

2. 函数类型里面的参数名与实际参数名，可以不一致



函数的实际参数个数，可以少于类型指定的参数个数，但是不能多于，即 TypeScript 允许省略参数。

因为 JavaScript 函数在声明时往往有多余的参数，实际使用时可以只传入一部分参数

```ts
let myFunc: (a:number, b:number) => number;

myFunc = (a:number) => a; // 正确

myFunc = (
  a:number, b:number, c:number
) => a + b + c; // 报错
```



函数类型还可以采用对象的写法。

```ts
let add:{
  (x:number, y:number): number
  version: string
};
 
```

这种写法的函数参数与返回值之间，间隔符是冒号`:`，而不是正常写法的箭头`=>`，因为这里采用的是对象类型的写法，对象的属性名与属性值之间使用的是冒号

这种写法平时很少用，除非函数作为对象使用，并具有别的额外属性



## Function

Function 类型的函数可以接受任意数量的参数，每个参数的类型都是`any`，返回值的类型也是`any`

所以不建议使用这个类型



## 可选参数

```ts
function f(x?:number) {
  return x;
}

f() // 正确
f(undefined) // 正确
```

```ts
function f(x:number|undefined) {
  return x;
}

f() // 报错
f(undefined) // 正确
```



函数的可选参数只能在参数列表的尾部，跟在必选参数的后面。

如果前部参数有可能为空，这时只能显式注明该参数类型可能为`undefined`。

函数体内部用到可选参数时，需要判断该参数是否为`undefined`。



## 参数默认值

设置了默认值的参数，就是可选的。如果不传入该参数「即值为undefined时」，它就会等于默认值

可选参数与默认值不能同时使用。

设有默认值的参数，如果传入`undefined`，也会触发默认值。

具有默认值的参数如果不位于参数列表的末尾，调用时不能省略，如果要触发默认值，必须显式传入`undefined`。

```ts
function add(
  x:number = 0,
  y:number
) {
  return x + y;
}

add(1) // 报错
add(undefined, 1) // 正确
```



## 参数解构

```ts
function f(
  [x, y]: [number, number]
) {
  // ...
}

function sum(
  { a, b, c }: {
     a: number;
     b: number;
     c: number
  }
) {
  console.log(a + b + c);
}
```



## rest 参数

rest 参数 就是 剩余参数

```ts
// rest 参数为数组
function joinNumbers(...nums:number[]) {
  // ...
}

// rest 参数为元组
function f(...args:[boolean, number]) {
  // ...
}
```

```ts
// ...[str, times] 得到的是由str和times构成的变量列表
function repeat(
  ...[str, times]: [string, number]
):string {
  return str.repeat(times);
}

// 等同于
function repeat(
  str: string,
  times: number
):string {
  return str.repeat(times);
}
```



## void

void 类型表示函数没有返回值。

void 类型允许返回`undefined`或`null`。

如果打开了`strictNullChecks`编译选项，那么 void 类型只允许返回`undefined`

```ts
function f():void {
  console.log('hello');
}
```



函数赋值时，可以赋值有返回值的函数。「 因为不用返回值，所以它的返回值不重要，或者不产生作用。 」

```ts
type voidFunc = () => void;

const f: voidFunc = () => {
  return 123;
};
```



函数的运行结果如果是抛出错误，也允许将返回值写成`void`。「 推荐写成never 」

```ts
function throwErr():void {
  throw new Error('something wrong');
}
```



## never

`never`类型表示肯定不会出现的值。它用在函数的返回值，就表示某个函数肯定不会返回值，即函数不会正常执行结束。

1. 抛出异常
2. 死循环



如果显式用`return`语句返回一个 Error 对象，返回值就不是 never 类型。

```ts
function fail():Error {
  return new Error("Something failed");
}
```



一个函数如果某些条件下有正常返回值，另一些条件下抛出错误，这时它的返回值类型可以省略`never`。

`never`是 TypeScript 的唯一一个底层类型，所有其他类型都包括了`never`

```ts
function sometimesThrow():number {
  if (Math.random() > 0.5) {
    return 100;
  }

  throw new Error('Something went wrong');
}

const result = sometimesThrow();
```



## 函数重载

有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。

这种根据参数类型不同，执行不同逻辑的行为，称为函数重载（function overload）。



重载声明的排序很重要，因为 TypeScript 是按照顺序进行检查的，一旦发现符合某个类型声明，就不再往下检查了，所以类型最宽的声明应该放在最后面，防止覆盖其他类型声明。

```ts
// 函数重载
function add(
  x:number,
  y:number
):number;

function add(
  x:any[],
  y:any[]
):any[];

// 函数实现
// 1. 必须与前面已有的重载声明兼容
// 2. 实际类型以函数重载类型为准
function add(
  x:number|any[],
  y:number|any[]
):number|any[] {
  if (typeof x === 'number' && typeof y === 'number') {
    return x + y;
  } else if (Array.isArray(x) && Array.isArray(y)) {
    return [...x, ...y];
  }

  throw new Error('wrong parameters');
}
```



对象的方法也可以使用重载。

```ts
class StringBuilder {
  #data = '';

  add(num:number): this;
  add(bool:boolean): this;
  add(str:string): this;
  add(value:any): this {
    this.#data += String(value);
    return this;
  }

  toString() {
    return this.#data;
  }
}
```



函数重载，也可以用对象表示。

```ts
function createElement(tag:'a'): HTMLAnchorElement;
function createElement(tag:'canvas'): HTMLCanvasElement;
function createElement(tag:'table'): HTMLTableElement;

function createElement(tag:string): HTMLElement {
  // ...
}
```

可以简写为

```ts
type CreateElement = {
  (tag:'a'): HTMLAnchorElement;
  (tag:'canvas'): HTMLCanvasElement;
  (tag:'table'): HTMLTableElement;
  (tag:string): HTMLElement;
}

function createElement(tag:string): HTMLElement {
  return document.createElement(tag)
}
```



重载是一种比较复杂的类型声明方法，为了降低复杂性，一般来说，如果可以的话，应该优先使用联合类型替代函数重载，除非多个参数之间、或者某个参数与返回值之间，存在对应关系。



## 构造函数

构造函数的类型写法，就是在参数列表前面加上`new`命令。

```ts
// 假设存在类Animal - 类即是值也是类型
type AnimalConstructor = new () => Animal;
```

构造函数还有另一种类型写法，就是采用对象形式。

```ts
type F = {
  new (s:string): object;
};
```



某些函数既是构造函数，又可以当作普通函数使用。

```ts
type F = {
  new (s:string): object;
  (n?:number): number;
}
```

上面示例中，F 既可以当作普通函数执行，也可以当作构造函数使用。