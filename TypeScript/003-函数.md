## 概述

在 TypeScript 中，可以为函数的参数和返回值指定类型：

```typescript
function hello(txt: string): void {
  console.log('hello ' + txt);
}
```

- **参数类型**：指定为 `string`
  - 如果不指定，TypeScript 会尝试推断类型
  - 信息不足时，类型会被视为 `any`。
- **返回值类型**：通常可以省略，TypeScript 会自动推断。



**参数名不能省略**：例如，`(txt: string)` 是有效的，而 `(string)` 会被识别为`(string: any)`



函数的参数是逆变的，不是协变的，也就是说实际参数可以少于类型定义的参数，但不能多于

```ts
let myFunc: (a: number, b: number) => number;

myFunc = (a: number) => a; // 正确
myFunc = (a: number, b: number, c: number) => a + b + c; // 报错
```



## 调用签名

适用于函数本身有属性的情况：

```typescript
type Func = {
  (x: number, y: number): number; // 调用签名
  version: string; // 额外属性
};
```



## Function 类型

- **Function** 是所有函数类型的父类型。
- **Function** 没有任何自定义的属性和方法，只能调用通用属性和方法。

```typescript
let fun: Function;

fun = () => {}; // success
fun = () => 1; // success
fun = (num1: number, num2: number) => num1 + num2; // success
```

### 



## 可选类型

在 TypeScript 中，函数的某个参数可以通过在参数名后加问号来标记为可选：

```typescript
function f(x?: number) {
  // ...
}

f();    // OK
f(10);  // OK
```

- **可选参数**：`x` 是可选的，类型实际上类似于 `number | undefined`。
- 可以显式传入 `undefined`：

```typescript
function f(x?: number) {
  return x;
}

f(); // 正确
f(undefined); // 正确
```

- 如果参数类型显式包含 `undefined`，则该参数不能省略：

```typescript
function f(x: number | undefined) {
  return x;
}

f(); // 报错
f(undefined); // 正确
```



### 参数顺序

可选参数必须在必选参数之后，剩余参数之前

```typescript
let myFunc: (a?: number, b: number) => number; // 报错
```

如果前面的参数可能为空，需显式注明类型包含 `undefined`：

```typescript
let myFunc: (a: number | undefined, b: number) => number;
```



## 参数默认值

参数默认值的写法与 JavaScript 一致，设置了默认值的参数是可选的：

```typescript
function createPoint(x: number = 0, y: number = 0): [number, number] {
  return [x, y];
}

createPoint(); // [0, 0]
```



如果有默认值，类型可以省略，TypeScript 会自动推断：

```typescript
function createPoint(x = 0, y = 0) {
  return [x, y];
}
```



注意事项：

1. 参数设置了可选就不能再设置默认值。
2. 只有传入 `undefined` 才会触发默认值。
3. 有默认值参数应在必选参数之后，除非显式传入 `undefined` 「 推荐规则 」

```typescript
function add(x = 0, y: number) {
  return x + y;
}

add(1);              // 报错
add(undefined, 1);   // 正确
```



## 参数解构

在函数参数中使用解构时，可以直接在参数列表中指定类型：

```typescript
function f([x, y]: [number, number]) {
  // 使用 x 和 y
}

function sum({ a, b, c }: { a: number; b: number; c: number }) {
  console.log(a + b + c);
}
```



## 剩余参数

Rest 参数用于表示函数的剩余参数，可以是数组或元组：

```typescript
function f(...args: [boolean, ...string[]]) {
  // args 是一个元组，第一个是布尔值，后面是字符串数组
}
```

```typescript
function repeat(...[str, times]: [string, number]): string {
  return str.repeat(times);
}

// 等同于
function repeat(str: string, times: number): string {
  return str.repeat(times);
}
```



## readonly

`readonly` 关键字只能用于数组和元组类型的参数，以防止在函数内部修改参数：

```typescript
function arraySum(arr: readonly number[]) {
  // arr[0] = 0; // 报错
}
```



## 局部类型

局部类型只能在函数内部或对应代码块中使用 「 一般不推荐使用局部类型 」

```typescript
function hello(txt: string) {
  type message = string;
  let newTxt: message = 'hello ' + txt;
  return newTxt;
}

const newTxt: message = hello('world'); // 报错
```



## 构造函数

```typescript
class Animal {
  numLegs: number = 4;
}

const animal = new Animal();
```

- 此时 `animal` 的类型是 `Animal`。
- 类 `Animal` 的类型是 `new () => Animal` 「 即 `typeof Animal` 」



## 函数重载

函数重载是指在同一个作用域中，多个函数可以具有相同的名称，但参数类型、数量或返回值类型不同。

函数重载允许我们根据传入参数的不同，来执行不同的逻辑。

```ts
// 函数重载签名
function createElement(tag: 'a'): HTMLAnchorElement;
function createElement(tag: 'canvas'): HTMLCanvasElement;
function createElement(tag: 'table'): HTMLTableElement;

// 函数实现 「 函数体实现中的参数和返回值必须兼容所有重载签名的参数和返回值类型 」
function createElement(tag: string): HTMLElement {
  // 函数体的实现
  return document.createElement(tag);
}
```

当调用 `createElement('a')` 时，TypeScript 会自动推断返回类型为 `HTMLAnchorElement`。



TypeScript 会从上到下匹配重载签名，找到第一个符合条件的签名。如果签名顺序不当，可能导致不正确的类型推断。所以推荐将类型最宽泛的声明应该放在最后



类中的方法也可以使用函数重

```ts
class StringBuilder {
  #data = '';

  // add方法返回了 this => add方法可以链式调用
  add(num: number): this;
  add(bool: boolean): this;
  add(str: string): this;
  add(value: any): this {
    this.#data += String(value);
    return this;
  }

  toString() {
    return this.#data;
  }
}
```



一般情况下，联合类型可以替代函数重载，除非参数和返回值之间存在特定关联。否则其余情况下，优先使用联合类型，而不是函数重载

```ts
function add(value: number | boolean | string): void {
  console.log(value);
}
```

