## Awaited

`Awaited<Type>` 是一个 TypeScript 内置的工具类型，用于提取 `Promise` 的返回值类型



`Promise<string>`表示 如果异步执行成功，得到的值是字符串类型值

```ts
// string
type A = Awaited<Promise<string>>;

// number
type B = Awaited<Promise<Promise<number>>>;

// number | boolean
type C = Awaited<boolean | Promise<number>>;

// boolean
type D = Awaited<boolean>;

// { name: 'Klaus' }
type E = Awaited<{ name: 'Klaus' }>
```



### 伪代码实现

1. 只要正确实现了then方法就认为是promise实例
2. 通过infer关键字推导出参数value的类型
3. promise可以状态传递，所以通过`MyAwaited<V>` 实现递归，知道返回非promise类型
4. 如果泛型传入联合类型，会依次使用联合成员进行类型求值，并将对应返回值组合成新的联合类型

```ts
type Awaited<T> = 
	T extends {  then(onfulfilled: (value: infer V) => void): void } 
		? MyAwaited<V> 
		: T
```



## 类相关

### ConstructorParameters

`ConstructorParameters<Type>` 是一个 TypeScript 工具类型，用于提取构造函数的参数类型，并将其组成一个元组类型返回。

```ts
type T1 = ConstructorParameters<
  new (x: string, y: number) => object
>; // [x: string, y: number]

type T2 = ConstructorParameters<
  new (x?: string) => object
>; // [x?: string | undefined]
```

如果无法提取，直接报错

```ts
type T1 = ConstructorParameters<string>; // 报错 「 泛型约束不满足 」

// 「 Function是通用函数类型，不一定能是构造函数 」
type T2 = ConstructorParameters<Function>; // 报错 
```



**特殊情况**：

```typescript
// infer推导时，只能知道是剩余参数，但不知道具体类型，所以返回了unknown[] 「 参考伪代码实现 」
type T1 = ConstructorParameters<any>;  // unknown[]

type T2 = ConstructorParameters<never>; // never
```



#### 伪代码

1. 这里加上了`abstract` 
   + **加上 `abstract`**：可以处理抽象类和普通类。
   + **不加 `abstract`**：只能处理普通类。

```ts
type ConstructorParameters<T extends abstract new (...args: any[]) => unknown> 
  = T extends abstract new (...args: infer P) => unknown ? P : never
```



### InstanceType

`InstanceType<Type>` 是一个 TypeScript 工具类型，用于提取构造函数的实例类型。

```ts
class C {
  x = 0;
  y = 0;
}

type T = InstanceType<typeof C>; // C
```

```ts
type T1 = InstanceType<string>; // 报错

type T2 = InstanceType<any>; // any
type T3 = InstanceType<never>; // never
```



#### 伪代码

```ts
type InstanceType<
  T extends abstract new (...args: unknown[]) => unknown
> = T extends abstract new (...args: unknown[]) => infer R ? R : any;
```

---

1. 为什么要abstract



### ThisParameterType

`ThisParameterType<Type>` 是一个工具类型，用于提取函数类型中 `this` 参数的类型。

```ts
function toHex(this: number) {
  return this.toString(16);
}

type T = ThisParameterType<typeof toHex>; // number
```



#### 伪代码

1. 如果函数没有 `this` 参数，则返回 `unknown`。

```ts
type ThisParameterType<T> =
  T extends (this: infer U, ...args: any[]) => any ? U : unknown;
```



### OmitThisParameter

`OmitThisParameter<Type>` 是一个工具类型，用于从函数类型中移除 `this` 参数。

```ts
function toHex(this: Number) {
  return this.toString(16);
}

type T = OmitThisParameter<typeof toHex>; // () => string
```



#### 伪代码

```ts
type OmitThisParameter<T> =
  unknown extends ThisParameterType<T> ? T :
  T extends (...args: infer A) => infer R ?
  (...args: A) => R : T;
```



## 联合类型

### Exclude<UnionType, ExcludedMembers>

`Exclude` 用于从联合类型 `UnionType` 中排除某些类型 `ExcludedMembers`，返回剩余的类型。



**简单排除**:

```ts
type T1 = Exclude<'a' | 'b' | 'c', 'a'>; // 'b' | 'c'

type T2 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>; // 'c'
```



**复杂类型排除**:

```ts
type T3 = Exclude<string | (() => void), Function>; // string

// unknown[] => 元素不确定类型的数组 「 有元素 」
// [] <=> never[] => 空数组 「 不能有元素 」=> 空数组是所有数组的子元素
type T4 = Exclude<string | string[], unknown[]>; // string
```



**排除的是两个类型交集的部分**

```ts
type T5 = Exclude<200 | 400, 200 | 201>; // 400
```



**如果无法排除，静默失效**

```ts
type T6 = Exclude<number, boolean>; // number
```



#### 伪代码

1. 联合类型会自动取联合成员并依次进行类型判断
2. 如果存在于U类型中，则返回never
3. 因为never是任意类型子类型，不会体现在具体类型中 「 string 本质是 string | never 」
4. 从而实现类型剔除的效果

```ts
type Exclude<T, U> = T extends U ? never : T;
```



### Extract<UnionType, Union>

`Extract` 用于从联合类型 `UnionType` 中提取某些类型 `Union`，返回这些类型。

操作正好和`Exclude`相反

```ts
type T1 = Extract<'a' | 'b' | 'c', 'a'>; // 'a'
type T2 = Extract<'a' | 'b' | 'c', 'a' | 'b'>; // 'a' | 'b'
type T3 = Extract<'a' | 'b' | 'c', 'a' | 'd'>; // 'a'
type T4 = Extract<string | number, boolean>; // never
```



#### 伪代码

```ts
type Extract<T, U> = T extends U ? T : never;
```



### NonNullable

`NonNullable<Type>` 是一个工具类型，用于从联合类型中删除 `null` 和 `undefined`，返回非空类型版本。

```ts
type T1 = NonNullable<string[] | number | null | undefined>; // string[] | number
type T2 = NonNullable<boolean>; // boolean
type T3 = NonNullable<null | undefined>; // never
```



#### 伪代码

```ts
type NonNullable<T> = T extends null | undefined ? never : T;
```



## 对象相关

### Pick

`Pick<Type, Keys>` 是一个工具类型，用于从对象类型 `Type` 中选择指定的属性 `Keys`，返回一个新的对象类型。

```ts
interface A {
  x: number;
  y: number;
}

type T1 = Pick<A, 'x'>; // { x: number }
type T2 = Pick<A, 'x' | 'y'>; // { x: number; y: number }

type T3 = Pick<A, 'z'>; // 报错
type T4 = Pick<A, 'x' | 'y' | 'z'> // 报错
```



#### 伪代码

1. `[P in K]` 遍历 `K` 中的每个键 => P就是每一个key
2. `T[P]` 获取 `T` 中对应键的类型 => 如果P不在T中，返回unknown
3. `K extends keyof T`
   + `T` 必须是一个对象
   + `K` 是T的key中的一个

```ts
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};
```



### Omit

`Omit<Type, Keys>` 是一个工具类型，用于从对象类型 `Type` 中删除指定的属性 `Keys`，返回一个新的对象类型。

```ts
interface A {
  x: number;
  y: number;
}

type T1 = Omit<A, 'x'>; // { y: number }
type T2 = Omit<A, 'x' | 'y'>; // { }
type T3 = Omit<A, 'z'>; // { x: number; y: number }
```



#### 伪代码

```ts
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```



### Partial

`Partial<Type>` 是一个工具类型，用于将类型 `Type` 的所有属性变为可选属性

```ts
interface A {
  x: number;
  y: number;
}

type T = Partial<A>; // { x?: number; y?: number; }
```



#### 伪代码

```ts
type Partial<T> = {
  [P in keyof T]+?: T[P];
};
```



### Readonly

`Readonly<Type>` 是一个工具类型 => 所有属性只读

```ts
interface A {
  x: number;
  y?: number;
}

type T = Readonly<A>; // { readonly x: number; readonly y?: number; }
```



#### 伪代码

```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```



### Required

`Required<Type>` 将类型 `Type` 的所有属性变为必选属性。

```ts
interface A {
  x?: number;
  y: number;
}

type T = Required<A>; // { x: number; y: number; }
```



#### 伪代码

```ts
type Required<T> = {
  [P in keyof T]-?: T[P];
};
```



### Record

`Record<Keys, Type>` 是一个工具类型，用于创建一个对象类型，其中键为 `Keys`，值为 `Type`。

```ts
// 单个键名
type T1 = Record<'a', number>; // { a: number }

// 联合类型作为键名
type T2 = Record<'a' | 'b', number>; // { a: number; b: number }

// 联合类型作为键值
type T3 = Record<'a', number | string>; // { a: number | string }
```



#### 伪代码

```ts
type Record<K extends string | number | symbol, T> = {
  [P in K]: T;
};
```



### ReadonlyArray

`ReadonlyArray<Type>` 是一个工具类型，用于创建一个只读数组类型，数组的元素类型为 `Type`。

```ts
const values: ReadonlyArray<string> = ['a', 'b', 'c']; // values的类型是 readonly string[]
```



#### 伪代码

```ts
interface ReadonlyArray<T> {
  readonly length: number;
  readonly [n: number]: T;
}
```



## 函数相关

### Parameters

`Parameters<Type>` 是一个工具类型 => 获取函数参数类型并形成元组

主要用于从外部模块提供的函数类型中获取参数类型

```ts
type T1 = Parameters<() => string>; // []
type T2 = Parameters<(a: number, b: number) => number>; // [a: number, b: number]
type T3 = Parameters<(x: { a: number; b: string }) => void>; // [x: { a: number, b: string }]

// 泛型会被认为是unknown类型值
type T4 = Parameters<<T>(arg: T) => T>; // [arg: unknown]

type T5 =  Parameters<string>; // 报错
type T6 = Parameters<Function> // 报错 => 不满足类型兼容性

type T7 = Parameters<any>; // unknown[]
type T8 = Parameters<never>; // never
```



#### 伪代码

```ts
type Parameters<T extends (...args: any) => unknown> = 
  T extends (...args: infer P) => any ? P : never;
```



### ReturnType

`ReturnType<Type>` 是一个工具类型，用于获取函数的返回值类型

```ts
type T1 = ReturnType<() => { a: string; b: number }>; // { a: string; b: number }
type T2 = ReturnType<() => () => any[]>; // () => any[]

// 泛型没约束返回unknown，有约束返回约束
type T3 = ReturnType<<T>() => T>; // unknown
type T4 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]

type T5 = ReturnType<boolean>; // 报错

// Function 是 (...args: any) => unknown 的父类 => 父类不兼容子类 => 不满足类型兼容性
type T6 = ReturnType<Function> // 报错

type T7 = ReturnType<any>; // any
type T8 = ReturnType<never>; // never
```



#### 伪代码

1. 只能使用`(...args: any) => unknown>`, 不能使用`(...args: unknown[]) => unknown>`

   => `unknown[]`表示是未知类型的数组 => TS进行类型推导的时候，会将函数参数推导为元组

   => 元组和数组类型不兼容 => 导致报错

   所以这里只能是any表示任意类型，不进行任何类型判断

```ts
type ReturnType<T extends (...args: any) => unknown> = 
  T extends (...args: any) => infer R ? R : any;
```



## 字符串相关

字符串相关类型工具 => TS底层通过JS提供的API来完成，从而实现在类型层面的字符串格式转换



`Uppercase<StringType>` => 转大写

```ts
type A = 'hello';
type B = Uppercase<A>; // "HELLO"
```



`Lowercase<StringType>` => 转小写

```ts
type A = 'HELLO';
type B = Lowercase<A>; // "hello"
```



`Capitalize<StringType>` => 首字母大写

```ts
type A = 'hello';
type B = Capitalize<A>; // "Hello"
```



`Uncapitalize<StringType>` => 首字母小写

```ts
type A = 'HELLO';
type B = Uncapitalize<A>; // "hELLO"
```

