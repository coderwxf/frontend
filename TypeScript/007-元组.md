元组（tuple）是 特殊的数组，具有如下特点:

1. 长度固定
2. 各个成员的类型固定

```ts
const s:[string, string, boolean] = ['a', 'b', true];
```



使用元组时，必须明确给出类型声明，不能省略，否则 TypeScript 会把一个值自动推断为数组。

```ts
// a 的类型被推断为 (number | boolean)[]
let a = [1, true];
```



元组成员的类型可以添加问号后缀（`?`），表示该成员是可选的。

注意，问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后。

```ts
let a:[number, number?] = [1];
```



元组的长度是确定的，访问越界的成员会报错。

```ts
let x: [string, string] = ['a', 'b'];

x[2] = 'c'; // 报错
```



使用扩展运算符（`...`），可以表示不限成员数量的元组。

```ts
type NamedNums = [
  string,
  ...number[]
];

const a:NamedNums = ['A', 1, 2];
const b:NamedNums = ['B', 1, 2, 3];
```

扩展运算符（`...`）用在元组的任意位置都可以，它的后面只能是一个数组或元组。

```ts
type t1 = [string, number, ...boolean[]];
type t2 = [string, ...boolean[], number];
type t3 = [...boolean[], string, number];
```



元组的成员可以添加成员名，这个成员名是说明性的，可以任意取名，没有实际作用。

```ts
type Color = [
  red: number,
  green: number,
  blue: number
];

const c:Color = [255, 255, 255];
```



元组可以通过方括号，读取成员类型。

```ts
type Tuple = [string, number];
type Age = Tuple[1]; // number
```

```ts
type Tuple = [string, number, Date];
type TupleEl = Tuple[number];  // string|number|Date
```



## 只读元组

只读元组是普通元组的父类型

```ts
// 写法一
type t1 = readonly [number, string]

// 写法二
type t2 = Readonly<[number, string]>

// 写法三 type t3 -> readonly [3, 4] 
// readonly [3, 4] 是一个只读值类型 既可以看成是只读元组，也可以看成是只读数组
type t3 = [3, 4] as const
```



## 成员数量

1. 如果没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）
2. 如果包含了可选成员，TypeScript 会推断出可能的成员数量
3. 如果使用了扩展运算符，TypeScript 就无法推断出成员数量



扩展运算符（`...`）将数组（注意，不是元组）转换成一个逗号分隔的序列，

这时 TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。

```ts
const arr = [1, 2];

function add(x:number, y:number){
  // ...
}

add(...arr) // 报错
```

解决这个问题的一个方法，就是把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。

```ts
const arr:[number, number] = [1, 2];

function add(x:number, y:number){
  // ...
}

add(...arr) // 正确
```

另一种写法是使用`as const`断言。

```ts
const arr = [1, 2] as const;
```