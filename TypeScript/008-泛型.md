**泛型（Generics）**是 TypeScript 中的一种特性, 简单来说泛型就是**类型变量**

泛型一般使用一个大写字母表示，例如`T`，`K`, `V`



泛型通常用于描述多个地方的类型关系，所以一般同一个泛型变量会出现至少两次及以上

如果只有某个泛型变量只出现了一次，该泛型变量往往是没有意义的

因为泛型虽然灵活，但可能增加代码复杂性。所以尽量减少使用不必要的泛型参数，以提升代码的可读性



调用时，TypeScript 会自动推导出泛型类型

```ts
function getFirst<T>(arr: T[]): T {
  return arr[0];
}

getFirst([1, 2, 3]); // 推导为 number
getFirst(['a', 'b', 'c']); // 推导为 string
```



有时 TypeScript 无法自动推导出泛型类型，此时需要手动指定

```ts
function comb<T>(arr1: T[], arr2: T[]): T[] {
  return arr1.concat(arr2);
}

comb<number | string>([1, 2], ['a', 'b']); // 合并数字和字符串数组
```



可以在一个函数或接口中指定多个泛型

```ts
class Pair<K, V> {
  constructor(public key: K, public value: V) {}
}

// 使用示例
let pair = new Pair('key', 123);
```



TypeScript 提供了许多内置泛型接口，如 `Array<T>`、`Map<K, V>`、`Set<T>` 和 `Promise<T>`

```typescript
let numbers: Array<number> = [1, 2, 3];
let promise: Promise<string> = new Promise((resolve) => resolve('Hello'));
```



## 默认值

在 TypeScript 中，泛型可以有默认值。当类型推导无法确定类型时，使用默认值。

```ts
class Generic<T = string> {
  list: T[] = [];

  add(t: T) {
    this.list.push(t);
  }
}

const g1 = new Generic();
g1.add('hello'); // 正确
// g1.add(4); // 错误，T 默认为 string

const g2 = new Generic<number>();
g2.add(4); // 正确
// g2.add('hello'); // 错误，T 被指定为 number
```



泛型参数不像函数参数，不能通过传入 `undefined` 来触发默认值。

因此，带有默认值的泛型参数必须放在没有默认值的参数后面，以确保默认值有意义

```ts
// 错误示例
// <T = boolean, U> // 错误

// 正确示例
<T, U = boolean> // 正确
```



## 泛型约束

在 TypeScript 中，使用 `extends` 可以对泛型进行约束，限制泛型变量可以接受的类型。

```ts
function comp<T extends { length: number } = { length: 2 }>(a: T, b: T): T {
  return a.length >= b.length ? a : b;
}
```



## 多个类型参数的引用

类型参数可以引用其他参数，但不能形成循环约束。

```ts
// 合法的引用
<T, U extends T>

// 也可以这样
<T extends U, U>
  
<T extends T>               // 错误
<T extends U, U extends T>  // 错误
```

