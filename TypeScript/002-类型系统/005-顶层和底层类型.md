## 顶层类型

### any

`any` 是 TypeScript 中的顶层类型「 超类型 」，表示没有任何类型限制，相当于关闭了类型检测

应尽量避免使用 `any`，以免失去 TypeScript 的类型安全

唯一合理的使用场景是逐步迁移旧的 JavaScript 项目。避免一堆类型推导报错，而临时使用一下`any`



如果无法推断出类型，TypeScript 会将变量类型视为 `any`

开启 `noImplicitAny` 后，TypeScript 会对无法推断类型的变量进行报错，从而避免隐式的 `any` 类型。

但有一个例外， **使用 `let` 和 `var` 声明变量但不赋值时，即使开启了 `noImplicitAny`，也不会报错**。

```ts
var x; // 不报错
let y; // 不报错

// const声明时必须初始化 => 不可能存在隐式any
const z = 2

y = 1 // success
y = 'Hello' // success
```

所以在使用 `let` 和 `var` 声明变量时，如果不赋值，应该显式声明类型以避免安全隐患



#### 类型污染

类型不仅会关闭当前变量的类型检测，如果将`any` 类型赋值给任何其他类型，会导致其他类型的类型检测一并关闭，这种行为被称为“类型污染”

```ts
let x: any = 'hello';
let y: number;

y = x; // 不报错
y * 123; // 不报错
y.toFixed(); // 不报错
```



### unknown

`unknown` 是 TypeScript 中的另一个顶层类型，类似于 `any`，可以被赋值为任意类型的值。

```typescript
let x: unknown;
x = true;          // 正确
x = 42;            // 正确
x = 'Hello World'; // 正确
```



然而，与 `any` 不同的是：

1. `unknown` 类型的变量只能赋值给 `unknown` 或 `any` 类型的变量，不能直接赋值给其他类型。
2. 无法直接访问 `unknown` 类型变量的属性或方法。



使用 `unknown` 可以强制开发者在使用变量之前进行类型检查。确保开发者通过类型缩小将 `unknown` 转换为更具体的类型后，才能进行操作。

所以 `unknown` 可以进行的操作非常有限，只能使用 取反操作，比较运算，`typeof` ，`instanceof`等类型缩小使用到的操作符，其余操作符一律不能使用



`unknown` 可以被视为类型安全的 `any`，通常建议优先使用 `unknown` 而非 `any`。

```typescript
function processValue(value: unknown) {
  if (typeof value === 'string') {
    // 类型缩小为 string，可以安全地调用 string 方法
    console.log(value.toUpperCase());
  } else if (typeof value === 'number') {
    // 类型缩小为 number，可以进行算术运算
    console.log(value + 1);
  } else {
    console.log('Unsupported type');
  }
}
```



## 底层类型

`never` 类型「 空类型 」表示一个不包含任何值的类型。这意味着它是一个空集合，没有任何可能的值。

`never` 是所有类型的子类型，可以赋值给任何其他类型

然而除了 `never` 类型的变量本身，没有其他类型的变量可以赋值给 `never`



### 使用场景

1. **不可能有返回值的函数**

   - 死循环函数

   - 抛出异常的函数

2. **用于保证类型运算的完整性**

   ```ts
   function checkType(x: string | number): boolean {
     if (typeof x === "string") {
       return true;
     } else if (typeof x === "number") {
       return false;
     } else {
       // 这个分支永远不应该被执行, 所以这个分支中的x的类型应该是never
       const check: never = x;
     }
   }
   ```

   