枚举「 Enum 」是一组相关常量的集合，用于给这些常量赋予更具可读性的名字。

TypeScript 中的枚举只能是数值型或字符串型。



## 数值枚举

```typescript
enum Color {
  Red,     // 默认值 0
  Green,   // 默认值 1
  Blue     // 默认值 2
}
```

- 默认情况下，枚举成员从 0 开始递增。
- 可以手动指定初始值，后续成员会在此基础上递增。



数值枚举在获取值的时候，支持双向映射

```typescript
let c1 = Color.Green;  // 正向映射，结果为 1
let c2 = Color[1];     // 反向映射，结果为 'Green'
```



可以为枚举成员显式赋值，后续成员从该值开始递增：

```typescript
enum Color {
  Red,           // 0
  Green = 2,     // 2
  Blue           // 3
}
```



枚举成员的值可以是任意数值，但不能是 BigInt：

```typescript
enum Color {
  Red = 90,
  Green = 0.5,
  Blue = 7n  // 报错
}
```



枚举值可以相同，但没有实际意义：

```typescript
enum Color {
  Red = 0,
  Green = 0,
  Blue = 0
}
```



枚举值可以是合法的 JavaScript 表达式：

```typescript
enum Permission {
  UserRead = 1 + 2,          // 3
  UserWrite = Math.random()  // 运行时计算
}
```



枚举成员是只读的，不能重新赋值：

```typescript
enum Color {
  Red,
  Green,
  Blue
}

// Color.Red = 4; // 报错
```



## 字符串枚举

在 TypeScript 中，字符串枚举的每个成员都必须显式设置值，因为字符串无法像数值一样递增。

```ts
enum Foo {
  A, // 0
  B = 'hello',
  C // 报错，因为没有显式赋值
}
```



如果枚举值同时存在字符串和数值，这类枚举被叫做异构枚举

```ts
enum Enum {
  One = 'One',
  Two = 'Two',
  Three = 3,
  Four = 4,
}
```



在 TypeScript 中，枚举类型是严格的。即使枚举成员的值是字符串，也不能直接用字符串字面量来代替枚举类型的值。

```ts
enum MyEnum {
  One = 'One',
  Two = 'Two',
}

function f(arg: MyEnum) {
  return 'arg is ' + arg;
}

// f('One'); // 报错，因为 'One'是字符串类型 不是 MyEnum 类型
```



字符串枚举和数值枚举不同，字符串枚举不能使用表达式为字符串枚举成员赋值

```ts
enum MyEnum {
  A = 'one',
  // B = ['T', 'w', 'o'].join('') // 报错
}
```



字符串枚举不支持反向映射，因为编译后只有单向映射：

```typescript
enum MyEnum {
  A = 'a',
  B = 'b'
}

// 编译后
var MyEnum;
(function (MyEnum) {
    MyEnum["A"] = "a";
    MyEnum["B"] = "b";
})(MyEnum || (MyEnum = {}));
```



## 枚举类型和枚举值类型

在 TypeScript 中，枚举既是类型也是值：

- **类型**：可以用作变量的类型。
- **值**：编译后变为 JavaScript 对象。

```typescript
let c: Color = Color.Green; // 类型为 Color => 本质是枚举值构成的联合类型
let n: number = Color.Green; // 类型为 number
```



## 编译结果

TypeScript 编译器会将枚举编译为 JavaScript 对象：

```javascript
"use strict";
var Color;
(function (Color) {
    Color[Color["Red"] = 0] = "Red";
    Color[Color["Green"] = 1] = "Green";
    Color[Color["Blue"] = 2] = "Blue";
})(Color || (Color = {}));
```



#### 注意事项

- 枚举在编译后会成为常驻对象，不能与其他变量同名，否则会报错。

```typescript
enum Color {
  Red,
  Green,
  Blue
}

const Color = 'red'; // 报错
```

- 常量枚举也不能与其他变量同名。「 即使常量枚举编译后会直接将值注入，而不是生成常驻对象 」

```typescript
const enum Color {
  Red,
  Green,
  Blue
}

const Color = 'red'; // 报错
```



#### 替代方案：常量对象

可以使用常量断言来实现类似枚举的功能：

```typescript
const Color = {
  Red: 0,
  Green: 1,
  Blue: 2,
  0: 'Red',
  1: 'Green',
  2: 'Blue'
} as const;

console.log(Color.Red);  // 输出 0
console.log(Color[0]);   // 输出 'Red'
```



## 常量枚举

TypeScript 编译器会将枚举编译为常驻对象注入JavaScript的运行时中

而常量枚举在编译后只保留使用到的枚举值，进而提升性能

```ts
const enum Color {
  Red,
  Green,
  Blue
}

const x = Color.Red;  // 0
```

编译结果：

```javascript
"use strict";
const x = 0 /* Color.Red */;
```

可以通过 `preserveConstEnums` 配置项保留常量枚举，但通常没有必要。



## 枚举合并

在 TypeScript 中，多个同名的枚举（Enum）可以自动合并。这对于扩展外部定义的枚举结构非常有用。

```ts
enum Foo {
  A,
}

enum Foo {
  B = 1,
}

enum Foo {
  C = 2,
}

// 合并后的枚举等同于：
enum Foo {
  A,
  B = 1,
  C = 2
}
```



### 规则限制

1. **初始值限制**
   + 只能有一个枚举的首成员可以省略初始值。
   + 因为省略初始值的成员会自动从 `0` 开始递增，多个省略会导致重复值。

```ts
enum Foo {
  A,
}

enum Foo {
  B, // 报错
}
```



2. **同名成员限制**：同名成员会导致编译错误，因为 TypeScript 无法确定成员的唯一性

```ts
enum Foo {
  A,
  B = 5
}

enum Foo {
  B = 1, // 报错
  C
}
```



3. **const 枚举限制**：所有合并的枚举必须同为 `const` 或非 `const`，不能混合。

因为`const enum` 是 TypeScript 的一种优化手段，编译时会被内联，而普通枚举在合并后会形成常驻对象被注入JavaScript运行时中，因此不能与普通枚举混合使用。

```ts
// 正确
enum E {
  A,
}
enum E {
  B = 1,
}

// 正确
const enum E {
  A,
}
const enum E {
  B = 1,
}

// 报错
enum E {
  A,
}
const enum E {
  B = 1,
}
```



## 提取枚举信息

### keyof typeof <枚举> 

```ts
enum MyEnum {
  A = 'a',
  B = 'b'
}

// keyof typeof MyEnum => 获取的是枚举的所有成员名，并将其作为联合类型返回
type Foo = keyof typeof MyEnum // 'A' | 'B'

// keyof MyEnum => 获取的是枚举编译后对象的所有属性键
type Bar = keyof MyEnum
```



### in 操作符

`in` 运算符可以用于创建一个对象类型，其中键是枚举的成员值

```ts
enum MyEnum {
  A = 'a',
  B = 'b'
}

// key 可以是任意变量名
// [key in MyEnum] 遍历枚举的所有成员值，创建一个对象类型
// 其中每个成员值作为键，类型为 unknown 「 注意: key是枚举成员值，不是枚举成员名 」
type Foo = { [key in MyEnum]: unknown }; // { a: unknown, b: unknown }
```

