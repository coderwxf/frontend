## keyof

`keyof` 是 TypeScript 中的一个关键字，用于获取对象类型中所有键名组成的联合类型

```ts
type MyObj = {
  foo: number;
  bar: string;
};

type Keys = keyof MyObj; // 'foo' | 'bar'
```



对于任意对象，键名的类型可以是 `string`、`number` 或 `symbol`

```typescript
type K = keyof any; // string | number | symbol
```



如果对象类型没有自定义键名，`keyof` 返回 `never`。

```typescript
type KeyT = keyof object; // never
```



对于交叉类型，`keyof` 返回所有键名的联合。

```ts
type A = { name: string; age: number };
type B = { age: number; gender: string };

type C = A & B; // 交叉类型

type KeysOfC = keyof C; // "name" | "age" | "gender"
```



对于联合类型，`keyof` 返回成员共有的键名。

```ts
type A = { name: string; age: number };
type B = { age: number; gender: string };

type D = A | B; // 联合类型

type KeysOfD = keyof D; // "age"
```



`keyof` 会返回数组的所有键名，包括数字索引和继承的属性 『 数组被作为特殊对象处理 』

```typescript
type Result = keyof ['a', 'b', 'c'];
// 返回 number | "0" | "1" | "2" | "length" | "pop" | "push" | ...
```



通过 `keyof` 可以结合 索引访问操作符 `[]`  提取对象中所有值的类型。

```typescript
type MyObj = {
  foo: number;
  bar: string;
};

type Keys = keyof MyObj;
type Values = MyObj[Keys]; // number | string
```

`MyObj[Keys]` 实际上是 `MyObj['foo'] | MyObj['bar']`，即 `number | string`



## `in` 运算符

在 JavaScript 中，`in` 运算符用于检查某个属性是否存在于对象中。它返回一个布尔值。

```js
const obj = { name: 'Alice', age: 30 };

console.log('name' in obj); // true
console.log('gender' in obj); // false
```



在 TypeScript 中，`in` 运算符常用于映射类型中，用于遍历联合类型的键名。这种用法通常用于构造新的类型。

```ts
type U = 'a' | 'b' | 'c';

type Foo = {
  [Prop in U]: number;
};

// 等同于
type Foo = {
  a: number;
  b: number;
  c: number;
};
```

在这个例子中，`[Prop in U]` 遍历联合类型 `U` 中的每个成员，并为每个成员生成一个属性，类型为 `number`。最终得到的 `Foo` 类型具有 `a`、`b` 和 `c` 三个属性，类型均为 `number`。



## 索引访问操作符

在 TypeScript 中，索引访问操作符 `[]` 用于获取对象属性的类型。

通过 `T[K]` 语法，获取对象 `T` 中属性 `K` 的类型

```ts
type Person = {
  age: number;
  name: string;
  alive: boolean;
};

// 获取单个属性的类型
type Age = Person['age']; // number

// 获取多个属性的联合类型
type T = Person['age' | 'name']; // number | string

// 获取所有属性的联合类型
type A = Person[keyof Person]; // number | string | boolean

// 访问不存在的属性会导致编译错误
// type T = Person['notExisted']; // 报错
```



方括号参数可以是属性名的索引类型。

```ts
type Obj = {
  [key: string]: number;
};

// 获取所有可能的属性类型
type T = Obj[string]; // number
```



所以对于数组，可以使用 `number` 作为索引，获取数组元素的类型。

```typescript
const MyArray = ['a', 'b', 'c'];

// 获取数组元素的类型
type Element = typeof MyArray[number]; // string
```



方括号内只能是字面量值，不能是JavaScript表达式，否则会报错

```ts
const key = 'age';
// type Age = Person[key]; // 报错

// type Age = Person['a' + 'g' + 'e']; // 报错
```



## 条件类型

在 TypeScript 中，条件类型是强大的工具，用于根据类型关系进行类型推断和转换

```typescript
T extends U ? X : Y
```

- **T** 和 **U** 是任意类型。
- 如果类型 **T** 可以赋值给类型 **U**（即 **T** 是 **U** 的子类型），则返回类型 **X**。否则，返回类型 **Y**。

```ts
type T = 1 extends number ? true : false; // 结果为 true
```



### 泛型中的条件类型

在泛型中使用 `extends` 时，如果类型参数是联合类型，条件运算符会对每个部分单独计算：

```typescript
type Cond<T> = T extends U ? X : Y;

type MyType = Cond<A | B>; 
// 等同于 Cond<A> | Cond<B>
// 即 (A extends U ? X : Y) | (B extends U ? X : Y)
```



如果不希望联合类型被展开，可以使用方括号：

```ts
// 联合类型展开
type ToArray<Type> = Type extends any ? Type[] : never;
// 结果为 string[] | number[]
type T1 = ToArray<string | number>;

// 防止展开
type ToArray<Type> = [Type] extends any ? Type[] : never;
// 结果为 (string | number)[]
type T2 = ToArray<string | number>;
```



### 嵌套条件类型

条件类型可以嵌套使用，用于多重判断：

```typescript
type LiteralTypeName<T> =
  T extends undefined ? "undefined" :
  T extends null ? "null" :
  T extends boolean ? "boolean" :
  T extends number ? "number" :
  T extends bigint ? "bigint" :
  T extends string ? "string" :
  never;

// 用法示例
type Result1 = LiteralTypeName<123n>; // 结果为 "bigint"
type Result2 = LiteralTypeName<true | 1 | 'a'>; // 结果为 "string" | "number" | "boolean"
```



## infer

`infer` 是 TypeScript 中用于在条件类型中进行类型推断的关键字。它允许我们在类型条件中捕获并命名一个类型，以便在返回类型中使用。

```typescript
type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;

type Str = Flatten<string[]>; // 推断为 string
type Num = Flatten<number>;   // 推断为 number
```



`infer` 也可以用于从字符串类型中提取模板字符串的部分。

```typescript
type Str = 'foo-bar';
type Bar = Str extends `foo-${infer Rest}` ? Rest : never; // Bar 的类型为 'bar'
```



## 类型谓词

在 TypeScript 中，`is` 运算符用于定义类型谓词（type predicate），帮助进行类型保护。

类型谓词用于在运行时检查类型，并在编译时提供类型信息。

类型谓词本质是一种特殊的断言

```typescript
function isFish(pet: Fish | Bird): pet is Fish {
  return 'swim' in pet
}
```

1. **`函数参数 is Type`**：这种写法用于表示函数的返回值类型。
2. **返回布尔值**：函数需要返回一个布尔类型值。
3. **类型保护**：如果函数返回 `true`，参数类型就是 `Type`；如果返回 `false`，参数类型就不是 `Type`。



类型谓词也可以用于判断类方法中 `this` 的类型。

```typescript
class Teacher {
  teach() {
    console.log('Teaching');
  }

  isStudent(): this is Student {
    return false;
  }
}

class Student {
  study() {
    console.log('Studying');
  }

  isStudent(): this is Student {
    return true;
  }
}

function performAction(person: Teacher | Student) {
  if (person.isStudent()) {
    person.study(); // 正确，因为 person 被判断为 Student 类型
  } else {
    person.teach(); // 正确，因为 person 被判断为 Teacher 类型
  }
}

// 示例用法
const teacher = new Teacher();
const student = new Student();

performAction(teacher); // 输出: Teaching Math
performAction(student); // 输出: Studying in grade 10
```



## 模板字符串类型

在 TypeScript 中，模板字符串类型允许我们通过字符串模板语法基于现有类型生成新类型。

模板字符串类型的基本用法是使用反引号（`` ` ``）和插值表达式（`${}`）来生成新的字符串类型

```typescript
type World = "world";
type Greeting = `hello ${World}`; // 结果类型为 "hello world"
```



模板字符串可以使用除`symbol`外的所有基本数据类型 和 枚举类型



模板字符串类型可以展开联合类型，生成新的联合类型。

```typescript
type T = 'A' | 'B';
type U = `${T}_id`; // 结果类型为 "A_id" | "B_id"
```



当模板字符串中引用多个联合类型时，会交叉展开这些类型：

```typescript
type T = 'A' | 'B';
type U = '1' | '2';
type V = `${T}${U}`; // 结果类型为 'A1' | 'A2' | 'B1' | 'B2'
```

这里，`V` 类型是通过交叉组合 `T` 和 `U` 的每个成员生成的。



## satisfies

`satisfies` 运算符允许我们确保一个值符合某个特定的类型约束，而不改变该值的原始类型推断。

`V satisfies F` 表示值 `V` 仅仅在此处需要必须满足类型 `F` 的约束条件

```ts
type Colors = "red" | "green" | "blue";
type RGB = [number, number, number];

const palette = {
  red: [255, 0, 0],
  green: "#00ff00",
  bleu: [0, 0, 255] // 属性名拼写错误
} satisfies Record<Colors, string | RGB>;
```

仅在给`palette`赋初始值时，需要满足类型是`Record<Colors, string | RGB>`

其余情况下，`palette`的类型依旧是

```ts
{
  red: [number, number, number];
  green: string;
  bleu: number[];
}
```



## typeof

**JavaScript 的 `typeof`**：用于运行时检查变量的类型。

**TypeScript 的 `typeof`**：用于编译时获取变量的类型信息

在编译后，TypeScript 的 `typeof` 会被类型擦除，而 JavaScript 的 `typeof` 会被保留。

```ts
const a = { x: 0 };

type T0 = typeof a;   // { x: number }
type T1 = typeof a.x; // number
```



TypeScript 中的 `typeof` 只能用于标识符，不能用于类型或表达式

```typescript
type T = typeof Date(); // 错误，Date() 是运行时计算
type Age = number;
type MyAge = typeof Age; // 错误，Age 是类型，不是标识符
```



