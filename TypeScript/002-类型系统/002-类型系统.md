## 继承自JavaScript的类型

JavaScript 将值分为八种基本类型，TypeScript 继承了 JavaScript 的基本类型，并在此基础上进行了额外扩展

1. **boolean**: 代表真或假。

   ```typescript
   let isDone: boolean = false;
   ```

2. **string**: 代表文本数据。

   ```typescript
   let name: string = "Alice";
   ```

3. **number**: 代表数字（整数和浮点数）。

   ```typescript
   let age: number = 30;
   ```

4. **bigint**: 用于表示大整数，超出 `number` 能表示的范围。

   + `bigint`和`number`属于不同的类型，它们之间并不兼容

   ```typescript
   let bigNumber: bigint = 123456n;
   ```

5. **symbol**: 用于创建唯一的标识符。

   ```typescript
   let uniqueId: symbol = Symbol("id");
   ```

6. **object**: 包括所有对象、数组和函数。

   ```typescript
   let user: object = { name: "Alice", age: 30 };
   ```

7. **undefined**: 表示未定义的值。

   ```typescript
   let notDefined: undefined = undefined;
   ```

8. **null**: 表示空值。

   ```typescript
   let empty: null = null;
   ```



## 类型初始化

TypeScript 要求变量在使用前必须赋值，否则会报错。

这是因为 TypeScript 的类型系统需要确保变量在使用时具有确定的类型。

可以简单理解为 变量默认值是undefined，和变量的类型不兼容了

```ts
 let x: number;  // 类型注解为 number
 // console.log(x); // 报错：变量 'x' 在赋值前使用
 x = 5; // 正确赋值后可以使用
 console.log(x); // 输出: 5
```



## 编译选项

### `noImplicitAny`

如果开启这个选项，TypeScript 会在无法推断出具体类型时报错, 而不是使用`any`



### `strictNullChecks`

`strictNullChecks`用于控制是否允许 `null` 和 `undefined` 作为其他类型的值

默认情况下，`null` 和 `undefined`是除`never`外任意类型的子类型，所以可以赋值给除`never`之外的任意类型

```ts
let age: number = 24;

age = null;      // 正确
age = undefined; // 正确
```



但`null`和`undefined`往往是容易出现bug的地方，我们应该对其进行检测

可以通过开启`strictNullChecks`选项，让`null`和`undefined`变为独立类型，不再是其它类型的子类型

开启后， `undefined` 和 `null` 只能赋值给自身类型，或 `any` 和 `unknown` 类型

```ts
// strictNullChecks 开启

let age: number = 24;

age = null;      // 报错
age = undefined; // 报错

let x: undefined = null; // 报错
let y: null = undefined; // 报错

let m: any = undefined;
let n: unknown = null;
```



#### void

在TypeScript中，函数的返回值声明为`void`意味着函数没有返回值

为了保持和JavaScript语法的一致性，在TypeScript中，无论是否开启`strictNullChecks`，`undefined`都永远是`void`的子类型

```ts
function logMessage(message: string): void {
  console.log(message);
  return undefined // success
}
```



## 类型关系

如果类型 A 可以赋值给类型 B，那么 A 是 B 的子类型，B 是 A 的父类型。

子类型继承了父类型的所有特征，因此可以在需要父类型的地方使用。但子类型可能有父类型没有的特征，所以反过来使用可能导致不安全。

```ts
 interface Animal {
   name: string;
 }
 
 interface Dog extends Animal {
   breed: string;
 }
 
 const myDog: Dog = {
   name: "Buddy",
   breed: "Golden Retriever"
 };
 
 const myAnimal: Animal = myDog; // 合法
```



### 鸭子类型

TypeScript 的类型系统是基于“结构化类型系统”（Structural Typing）的，也称为“鸭子类型”。

这意味着 TypeScript 会根据对象的实际属性和方法来判断类型兼容性，而不是依赖于名义类型（Nominal Typing）。

所谓名义类型，就是基于显式声明的类型关系来描述父子类型。例如在Java中，必须通过继承才能确定父子关系

```ts
 interface Bird {
   fly(): void;
 }
 
 class Sparrow {
   fly() {
     console.log("Flying");
   }
 }
 
 const bird: Bird = new Sparrow(); // 合法，因为 Sparrow 具有 fly 方法
```



### 协变和逆变

协变（Covariance）： 

子类型可以赋值给父类型，通常用于返回类型。

```ts
 class Animal {}
 class Dog extends Animal {}
 
 function getAnimal(): Animal {
   return new Dog(); // 合法，因为 Dog 是 Animal 的子类型
 }
```



逆变（Contravariance）

父类型可以赋值给子类型，通常用于函数参数。

```ts
 function treatAnimal(animal: Animal) {}
 
 const treatDog: (dog: Dog) => void = treatAnimal; // 合法
```



双向协变

在某些情况下，TypeScript 允许双向协变，但这可能导致类型不安全，因此应谨慎使用。



### 多态

通过父类型接口引用不同的子类型对象。

```ts
 let animal: Animal
 let dog: Dog
 let cat: Cat
 
 // 其中 Cat和Dog 是 Animal的子类型
 animal = dog // success
 animal = cat // success
```
