## 类型兼容性

更宽泛的类型 被称之为 父类型（supertype）或 基类型（base type）

更严谨的类型 被称之为 子类型（subtype）

凡是可以使用父类型的地方，都可以使用子类型。但反之不可以

也就是说 子类型 可以赋值(兼容) 父类型，反之不可以

```ts
type T = number | string;

// number 是 number | string 的子类型
let a: number = 1;
let b: T = a;
```



## 逆变 / 协变

逆变 => 父类型 可以赋值给 子类型，反之不行

协变 => 子类型 可以赋值给 父类型， 反之不行

双向协变 => 既支持 逆变，也支持 协变 => 父类型可以赋值给子类型，子类型也可以赋值给父类型



TS是一个支持协变的类型系统，并不支持逆变

```ts
interface Animal {
  eat(): void;
}

interface Dog extends Animal {
  bark(): void;
}

let animal: Animal = {
  eat() {}
};

let dog: Dog = {
  eat() {},
  bark() {}
};

animal = dog; // 子类 -> 父类 OK
dog = animal; // 父类 -> 子类 ERROR
```



但有一个特例，就是在处理函数兼容性的时候 「即在函数赋值的时候」

```ts
interface Animal {
  eat(): void;
}

interface Dog extends Animal {
  bark(): void;
}

let animalHandler = (animal: Animal) => {
  animal.eat();
};

let dogHandler = (dog: Dog) => {
  dog.bark();
};

// 如果 strictFunctionTypes 为 false
// 函数在赋值的时候，参数的兼容性 满足 双向协变
animalHandler = dogHandler; // 子类 -> 父类 OK
dogHandler = animalHandler; // 父类 -> 子类 OK
```



如果将`strictFunctionTypes`开启，则函数在赋值的时候，函数参数的兼容性，将严格保证为`逆变`，而非`双向协变`

```ts
interface Animal {
  eat(): void;
}

interface Dog extends Animal {
  bark(): void;
}

let animalHandler = (animal: Animal) => {
  animal.eat();
};

let dogHandler = (dog: Dog) => {
  dog.bark();
};

// 如果 strictFunctionTypes 为 true -- 注意: 这里是逆变，不是协变，也不是双向协变
dogHandler = animalHandler; // 父类 -> 子类 OK
animalHandler = dogHandler; // 子类 -> 父类 ERROR
```



开发中，一般设置为`strict: true`，所以`strictFunctionTypes`的值 在绝大多数情况下为`true`

