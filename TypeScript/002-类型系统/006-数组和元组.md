## 数组

数组元素成员数量是不固定的，可以是空数组或无限数量的成员。

所以数组的长度可以动态变化，TypeScript 不会检查越界访问



两种主要写法：

- 方括号写法：`let arr: number[] = [1, 2, 3];`
- 泛型写法：`let arr: Array<number> = [1, 2, 3];`



### 复杂类型

使用圆括号来定义复杂类型的数组，例如包含多种类型：

```typescript
let arr: (number | string)[] = [1, "two", 3]; // 数值和字符串构成的数组
```

如果不使用括号，TypeScript 会将其解释为多种类型的数组，而不是单个元素的联合类型。

```ts
let arr: number | string[] = ['one', 'two'] // 数字 或 字符串构成的数组
```



### 读取数组成员类型

```ts
type Strings = string[];
type FirstString = Strings[0]; // string => 通过属性名去获取属性值类型
type AnyString = Strings[number]; // string => 通过索引类型去获取属性值类型
```



### 类型推断

如果数组初始化为空，TypeScript 会推断为 `any[]`，并根据后续操作缩小类型。

```ts
const arr = []; // 推断为 any[]
arr.push(123);  // 推断为 number[]
arr.push('abc'); // 推断为 (string | number)[]
```

而如果数组初始值并不为空，TypeScript会根据初始值推断类型，不会动态更新

```ts
const arr = [123]; // 推断为 number[]
arr.push('abc'); // 报错：类型不匹配
```



### 只读数组

普通数组可以看成是只读数组的子类型

1. 使用 `readonly` 关键字创建只读数组 「 ``readonly` 不能与泛型一起使用    」

```ts
const arr: readonly number[] = [0, 1];
```

2. 使用 `ReadonlyArray<T>` 或 `Readonly<T[]>` 创建泛型只读数组

```ts
const a1: ReadonlyArray<number> = [0, 1];
const a2: Readonly<number[]> = [0, 1];
```



和只读断言 「 const断言 」不同，`readonly`只是浅层只读，而`只读断言`是深层只读

```ts
const users: ReadonlyArray<{ name: string, age: number }> = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
  { name: 'Charlie', age: 35 }
];


users[0].name = 'Klaus'
console.log(users[0].name) // 'Klaus'
```



### const 断言

使用 `as const` 将数组或对象声明为只读常量。

```ts
const colors = ['red', 'green', 'blue'] as const;
const point = { x: 10, y: 20 } as const;
```

只读断言是递归的，意味着内部的对象或数组也会被视为只读。

```ts
const users = [{ name: 'Klaus' }, { name: 'Alex' }] as const;
// users[0].name = 'Alice'; // error

const point = { x: 10, y: 20, colors: ['red', 'green', 'blue'] } as const;
// point.colors[1] = 'orange'; // error
```



### 多维数组

- 多维数组可以使用 `T[][]` 表示，其中 `T` 是最底层数组元素的类型。

  ```typescript
  const multi: number[][] = [
    [1, 2, 3],
    [23, 24, 25]
  ];
  ```



## 元组

元组是 TypeScript 中的一种特殊数组

- **长度明确**: 元组的长度是固定的，可以是定长或不定长 「 包含可选成员和剩余参数 」
  - 元组会检测越界元素
- **元素类型固定**: 每个位置上的元素类型是固定的。



默认情况下，TypeScript 会将其推断为普通数组，因此需要显式声明为元组。

```ts
const s: [string, string, boolean] = ['a', 'b', true];
```



可选成员必须位于固定元素之后，剩余参数之前

```ts
type NamedNums = [string, number?, ...number[]];
const a: NamedNums = ['Klaus', 23, 1, 2];
```



元组的成员类型可以通过索引访问。

```typescript
type Tuple = [string, number];
type Age = Tuple[1]; // number
```



元组的成员可以有说明性的成员名，但这些名字仅供备注使用，没有实际作用。「 很少使用 」

```ts
type Color = [red: number, green: number, blue: number];
const c: Color = [255, 255, 255];
```



### 只读元组

元组和数组一样，可以被定义为只读的。只读元组是普通元组的父类型。

- 使用 `readonly` 关键字：

  ```typescript
  const readonlyTuple: readonly [number, string] = [1, 'hello'];
  ```

- 使用 `Readonly` 泛型：

  ```typescript
  const readonlyTuple: Readonly<[number, string]> = [1, 'hello'];
  ```



### 元组成员数量推导

1. 没有可选成员和扩展运算符时，TypeScript 可以准确推断元组的长度
   + `[number, number]` => 长度为2

2. 包含可选成员时，TypeScript 会推断出可能的长度范围
   + ` [number, number?, number?]`  => 长度为 `1 | 2 | 3`

3. 使用扩展运算符后，TypeScript 无法推断元组的具体长度，会将其视为数组处理
   + 扩展运算符（`...`）用于将可迭代对象转换为**逗号分隔的参数序列**
   + ` [...string[]] ` => 当做字符串数组处理 => 不检测越界元素



```ts
const arr = [1, 2];

function add(x: number, y: number) {
  // ...
}

add(...arr); // 报错，因为数组长度可能变化
```

函数的参数类型为`[number, number]`, 而`arr`的类型为`number[]` => 这就导致了类型兼容性错误



解决方法

1. 将`arr`显示声明为元组

   ```ts
   const arr: [number, number] = [1, 2];
   
   function add(x: number, y: number) {
     // ...
   }
   
   add(...arr); // 正确
   ```

2. 使用常量断言

   ```ts
   const arr = [1, 2] as const;
   
   function add(x: number, y: number) {
     // ...
   }
   
   add(...arr); // 正确
   ```

   