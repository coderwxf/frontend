### 包装类型

在 JavaScript 中，在原始类型（primitive types）上调用方法时，原始类型会自动转换为对应包装类

其中`null` 和 `undefined` 没有包装类，而其他原始类型都有对应的包装类



也可以显示创建包装类对象

```javascript
const str1 = String('hello'); // 'hello'
const str2 = new String('hello'); // String object

console.log(typeof str1); // 'string'
console.log(typeof str2); // 'object'
```

- 使用 `new` 调用时，返回包装对象。
- 不使用 `new` 调用时，返回原始类型的值。



TypeScript 中，大写和小写类型用于区分字面量和包装对象。

- **大写类型**（如 `String`、`Number`、`Boolean`）：包含包装对象和字面量。
- **小写类型**（如 `string`、`number`、`boolean`）：仅包含字面量。

示例：

```typescript
const s1: String = 'hello'; // 正确
const s2: String = new String('hello'); // 正确

const s3: string = 'hello'; // 正确
const s4: string = new String('hello'); // 报错
```

> **建议**：尽可能使用全小写类型，因为在大多数情况下，你只需要字面量类型。



### `BigInt` 和 `Symbol`

- `BigInt` 和 `Symbol` 不是包装类函数，而是用于生成 `bigint` 和 `symbol` 类型值的函数。
- 可以通过 `Object` 方法获取 `bigint` 和 `symbol` 类型值的包装类，但一般没有实际意义，因为它们没有属性和方法。

示例：

```typescript
let a: Symbol = Object(Symbol());
let b: BigInt = Object(BigInt(2));
```



### `Object` 和 `object`

- **`Object`（广义对象）**：包括所有可以转换为对象的值，除 `null` 和 `undefined` 外的所有值。
- **`object`（狭义对象）**：仅包括对象、数组和函数，不包括基本数据类型。

> **建议**：优先使用 `object`，因为它更符合直觉，通常只需要对象、数组和函数。



`object` 和 `Object`都表示通用对象，所以只能使用 JavaScript 内置对象的原生属性和方法，不能使用用户自定义属性和方法

```typescript
const o1: Object = { foo: 0 };
const o2: object = { foo: 0 };

o1.toString(); // 正确
o1.foo; // 报错

o2.toString(); // 正确
o2.foo; // 报错
```

