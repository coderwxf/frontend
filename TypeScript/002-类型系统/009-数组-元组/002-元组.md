```ts
// 数组
let a:number[] = [1];

// 元组
let t:[number] = [1];
```



元组类型必须显示指定，否则会优先被推导为数组

```ts
// a 的类型被推断为 (number | boolean)[]
let a = [1, true];
```



## 可选成员

1. 通过? 表示 可选成员
2. 所有可选成员必须在必选成员之后

```ts
type myTuple = [
  number,
  number,
  number?,
  string?
];
```



## 不限长元组

1. 通过 展开运算符 将数组转换为 逗号分割的序列 --- `... 后边只能是 数组 或 元组`
2. 将这个序列插入到元组中，此时这个元组就是不限长元组
3. 和可选成员不同的是，这个序列可以插入到数组中的任何位置中

```ts
type NamedNums = [
  string,
  ...number[]
];

const a:NamedNums = ['A', 1, 2];
const b:NamedNums = ['B', 1, 2, 3];
```



## 越界元素

1. 限长元组 --- 绝大多数情况下 --- 元组长度固定，元素越界会报错

   ```ts
   let x:[string, string] = ['a', 'b'];
   
   x[2] = 'c'; // 报错
   ```

2. 不限长元组，可能存在以下情况

   + 有可选成员的元组 --- 推导出的元组长度是联合类型

     ```ts
     type point = [number, number?, number?] // 元组的长度为 1 | 2 | 3
     ```

     

   + 有插入展开序列的元组 --- 长度无法固定，无法准确推导出元组的长度

     ```ts
     type point = [number, ...string[]] // 一种特殊数组，第一个元素是number，后续元素都是string
     ```

     

## 元组成员说明

```ts
type Color = [
  red: number, // 可以给元组成员添加描述性信息 -- 只是为了可读性 -- 无法使用，一般没啥实际意义
  green: number,
  blue: number
];

const c:Color = [255, 255, 255];
```



## 成员类型

```ts
type Tuple = [string, number];
type Age = Tuple[1]; // number
```

```ts
type Tuple = [string, number, Date];
type TupleEl = Tuple[number];  // string|number|Date
```



## 只读元组

只读元组是元组的父类型，元组是只读元组的子类型

```ts
// 写法一
type t = readonly [number, string]

// 写法二
type t = Readonly<[number, string]>
```



## 扩展运算符和成员数量

扩展运算符（`...`）将数组或不固定长度元组 转换成一个逗号分隔的 长度不确定的 序列

```ts
const arr = [1, 2];

function add(x:number, y:number){
  // ...
}

add(...arr) // 报错 ...arr => 是一个长度为number的 逗号分割的序列
```

扩展运算符（`...`）将固定长度元组 转换成一个逗号分隔的 长度确定的 序列

```ts
const arr:[number, number] = [1, 2];

function add(x:number, y:number){
  // ...
}

add(...arr) // 正确 => ...arr 序列的长度是2
```

