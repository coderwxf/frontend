## 基本使用

写法一：

```ts
let arr:number[] = [1, 2, 3];

// | 优先级比 [] 低 --- 需要加上小括号
let arr:(number|string)[];
```



写法二:

```ts
let arr: Array<number> = [1, 2, 3];

let arr:Array<number|string>;
```



数组成员长度是不固定的，所以元素越界不报错

```ts
let arr:number[] = [1, 2, 3];
let foo = arr[3]; // 正确 typeof foo => number
```



## 成员类型

数组是特殊对象，所以获取成员类型的本质就是通过对象的key，去获取属性值

```ts
type Names = string[];
type Name = Names[0]; // string
```

```ts
type Names = string[];
type Name = Names[number]; // string --- 通过索引类型，获取属性值
```



## 类型推断

如果数组初始化值空数组，且使用类型推导，数组的类型会根据后续具体赋值，进行更进一步的类型缩小

```ts
const arr = []; // arr推断为 any[]

arr.push(123); // arr推断类型为 number[]

arr.push('abc'); // arr推断类型为 (string|number)[]
```

如果初始值不是空数组，数组类型将被直接具体化，无法后续细化

```ts
// 推断类型为 number[]
const arr = [123];

arr.push('abc'); // 报错
```



## 只读数组

只读数组是数组的父类型，数组是只读数组的子类型



方式一 ---  readonly关键字

```ts
const arr:readonly number[] = [0, 1];

arr[1] = 2; // 报错
arr.push(3); // 报错
delete arr[0]; // 报错
```



方式二 ---- 泛型方式

```ts
// readonly不可以与 泛型方式 联用
const arr:readonly Array<number> = [0, 1]; // 报错

// ReadonlyArray<T>
const a1:ReadonlyArray<number> = [0, 1];

// Readonly<T[]>
const a2:Readonly<number[]> = [0, 1];
```



方式三 --- as const

`as const`推导出的类型 即是 只读数组 也是 只读元组

```ts
const arr = [0, 1] as const; // typeof arr => readonly [0, 1]

arr[0] = [2]; // 报错 
```





## 多维数组

`number[][]` 

1. 一个数组
2. 这个数组的成员都是 `number[]`

```ts
let multi:number[][] = [[1,2,3], [23,24,25]];
```

