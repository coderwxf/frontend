TS的基本数据类型和JS一致

- boolean => type boolean = true | false
- string => 所有类型的字符串
- number => 所有类型的数值
- bigint => 所有的大整数
- symbol => 所有symbol类型值
- object => 所有对象 = 普通对象 + 数组 + 函数
- undefined => 定义未赋值
- null => 值为空 => 一般用于表示空对象 即没有对象

1. 类型名都是全小写的 ，不是`Boolean`、`String`等首字母大写的形式 
2. null 和 undefined 是两种特殊类型 => 类型和值 同名



## bigint

1. bigint 指代所有的大整数 => 与number类型不兼容 => 两者存储机制完全不同
2. bigint在ES2020引入 => 编译target必须大于等于es2020



## null / undefined

宽松情况下， null / undefined 是其它任何类型的子类型 => 和JavaScript行为保持一致

```ts
// 因为null/undefined可以赋值给其余任何类型 --- 无法进行更具体的类型推断
let a = undefined;   // any
const b = undefined; // any

let c = null;        // any
const d = null;      // any
```



开启`strictNullChecks`, null / undefined 只能被赋值给 null / undefined 自身，当然也可以赋值给 any / unknown

```ts
// 打开编译设置 strictNullChecks

// null/undefined不能作为其余类型子类型 --- 可以推导出具体类型
let a = undefined;   // undefined
const b = undefined; // undefined

let c = null;        // null
const d = null;      // null
```



## 包装类

JavaScript的基本数据类型中

1. null / undefined --- 特殊类型 没有对应包装类
2. symbol / bigint --- Symbol / BigInt 只能作为函数调用，不能作为构造函数  --- 无法获取对应包装类

string / number / boolean --- 都存在对应的包装类类型 String / Number / Boolean

```ts
const s1 = new String('hello'); // typeof s1 => String

// 没有通过new调用 --- 兼容处理 --- 返回的就是字符串类型
const s2 = String('world') // typeof s2 => string
```



其中  `String / Number / Boolean` 是 包装类类型 ，而 `string / number / boolean` 是字面量类型

包装类类型同时包含`包装对象和字面量`两种情况，而 字面量类型 `只包含字面量，不包含包装对象`

```ts
const s1:String = 'hello'; // 正确
const s2:String = new String('hello'); // 正确

const s3:string = 'hello'; // 正确
const s4:string = new String('hello'); // 报错
```

> 推荐: 永远使用字面量类型，尽可能不要使用包装类类型



## Object / object

Object --- 广义对象

1. 广义对象 表示那些可以被转换为对象的值
2. 广义对象 = 普通对象 + 数组  + 函数 + 基本数据类型值 => 基本上，除 null 和 undefined外 都是 Object类型
3. `{}` 是 Object类型的简写形式

object --- 狭义对象

1. 狭义对象 --- 可以通过字面量形式直接表示的对象
2. 协议对象 = 普通对象 + 数组 + 函数 => 不包含原始数据类型

> 1. 描述对象结构应该使用接口或类型别名，而不是object或Object
> 2. object 和 Object 中 优先推荐使用object ，而不是Object
> 3. 无论object还是Object 只表示是对象，但没有指定对象结构 => 只能调用对象上通用的属性和方法，无法调用自定义属性和方法

```ts
const o1:Object = { foo: 0 };
const o2:object = { foo: 0 };

o1.toString() // 正确
o1.foo // 报错

o2.toString() // 正确
o2.foo // 报错
```



## 字面量类型

字面量类型 又叫做 值类型

字面量类型一般很少单独使用，而是作为联合类型的一部分进行使用

```ts
let x: 'hello';

x = 'hello'; // 正确
x = 'world'; // 报错
```



满足如下条件，变量类型会被自动推导为字面量类型

1. 通过类型推导确定类型
2. 推导的变量是基本数据类型

```ts
// x 的类型是 "https" --- 常量值不能二次修改，推导为字面量类型
const x = 'https';

// y 的类型是 string
const y:string = 'https';

// x 的类型是 { foo: number } --- 对象不会被推导为字面量类型
const x = { foo: 1 };
```



```ts
// ts是静态类型检测 --- 不会进行四则运算「值运算」 --- typeof 4 + 1 => number
// 5 是 更具体的子类型，number 是 更宽松的父类型 => 子类型可以赋值给父类型，反之不可以
const x:5 = 4 + 1;
```

