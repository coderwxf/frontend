在 TypeScript 中，文件默认被视为全局脚本文件，除非包含 `import` 或 `export` 语句。

这意味着所有定义的变量和类型在全局范围内共享。

为了避免这种情况，可以通过在文件头添加 `export {}` 来将文件标识为模块。

```ts
// 将文件标识为模块
export {}

// 现在可以在此文件中定义模块范围内的变量和类型
let localVariable = 'This is local to the module';
```



##  导入类型

在 TypeScript 中，可以在一条 `import` 语句中同时导入类型和接口



### 具名导入

```typescript
// 导入类型和接口

// 支持省略 `.ts` 后缀
import { type A, a } from './a';

// 或者分开导入
import type { A } from './a'; // 仅用于类型
import { a } from './a'; // 用于值
```



### 默认导入

```ts
// moduleA.ts => 导出默认类型
export default interface DefaultType {
  name: string;
  age: number;
}

// moduleB.ts => 导入默认类型
import type DefaultType from 'moduleA';
```



### 导入为对象 「 命令空间 」

```ts
// moduleA.ts => 导出多个类型
export interface TypeOne {
  id: number;
}

export interface TypeTwo {
  title: string;
}

// moduleB.ts => 导入所有类型到一个命名空间
import type * as TypeNS from 'moduleA';

const itemOne: TypeNS.TypeOne = { id: 1 };
const itemTwo: TypeNS.TypeTwo = { title: 'Hello World' };
```



## 导出类型

TypeScript 提供了使用 `type` 关键字导出类型的功能，这可以使代码更具可读性。

```typescript
// 导出类型别名
export type Bool = true | false;

// 或者分两行写
type Bool = true | false;
export { Bool };
```



这种语法明确地表示导出的是类型，而不是值或其他实体。

```ts
// 方法一
export { type A, type B };

// 方法二
export type { A, B };
```

```ts
// module.ts
class Point {
  x: number;
  y: number;
}

export type { Point };

// main.ts => Point只能作为类型，不能作为值使用
import type { Point } from './module';

const p: Point = { x: 0, y: 0 };
```



## importsNotUsedAsValues

`importsNotUsedAsValues`控制在编译为 JavaScript 时，如何处理类型导入语句。这个选项有三个可能的值：

1. `remove`
2. `preserve`
3. `error`



#### `remove`

- **功能**：这是默认选项。类型导入语句在编译成 JavaScript 时会被自动移除。

  ```typescript
  // 编译前
  import { TypeA } from './a';
  
  // 编译后
  // import 语句被移除了，因为 TypeA 仅用于类型检查，不在运行时使用。
  ```



#### `preserve`

- **功能**：类型导入语句在编译后会被保留，但形式上只保留文件路径。

  ```typescript
  // 编译前
  import { TypeA } from './a';
  
  // 编译后
  import './a'; // 只保留了路径，以确保模块的副作用（如果有）被执行。
  ```



#### `error`

- **功能**：与 `preserve` 的效果一致，但要求必须使用 `import type`。否则会报错。

  ```typescript
  // 编译前
  import type { TypeA } from './a';
  
  // 编译后
  import './a'; // 仍然保留路径
  ```



## 模块解析策略

TypeScript 提供两种模块解析策略：`Classic` 和 `Node`。

##### 1. Classic 方法

- **相对模块**：从当前目录开始查找 `b.ts` 和 `b.d.ts`。
- **绝对模块**：从当前目录开始查找 `b.ts` 和 `b.d.ts`，逐级向上直到根目录。

##### 2. Node 方法

- **相对模块**：
  - 在当前目录查找 `b.ts`、`b.tsx`、`b.d.ts`。
  - 如果 `b` 是一个目录，查找 `b/package.json` 中的 `types` 字段。
  - 查找 `b/index.ts`、`b/index.tsx`、`b/index.d.ts`。

- **绝对模块**：
  - 从当前目录开始，逐级向上查找 `node_modules`。
  - 在 `node_modules` 中查找 `b` 目录。
    - 查找 `b/package.json` 中的 `types` 字段。
    - 在 `node_modules/@types` 中查找 `b.d.ts`。
    - 在 `b` 子目录中查找 `index.ts`、`index.tsx`、`index.d.ts`。



### `@types` 目录

- **作用**：为没有原生 TypeScript 支持的 JavaScript 库提供类型定义。
- **使用**：当使用第三方库时，如果没有类型声明，可以在 `@types` 中找到社区编写的类型声明文件。
- **安装**：对应库名为 `@types/<库名>`，安装后类型声明文件会存在于 `node_modules/@types/<库名>.d.ts`。



### 解析规则

- 默认情况下，TypeScript 在 Node.js 环境中使用 `Node` 解析策略。
- 在浏览器环境或其他非 Node.js 环境中，Classic可能更常用。
- 可以通过 `tsconfig.json` 中的 `moduleResolution` 配置项显式指定解析规则为 `Classic` 或 `Node`。
