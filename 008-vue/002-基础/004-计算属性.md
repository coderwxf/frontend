模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。因此推荐使用**计算属性**来描述依赖响应式状态的复杂逻辑

```vue
<script setup>
import { reactive, computed } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})

// 一个计算属性 ref
const publishedBooksMessage = computed(() => author.books.length > 0 ? 'Yes' : 'No')
</script>

<template>
  <p>Has published books:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>
```



`computed()` 方法期望接收一个 getter 函数，返回值为一个**计算属性 ref**

Vue 的计算属性会自动追踪响应式依赖。它会检测到 `publishedBooksMessage` 依赖于 `author.books`，所以当 `author.books` 改变时，任何依赖于 `publishedBooksMessage` 的绑定都会同时更新。

```js
// Date.now() 不是响应式数据 所以该计算属性永远不会更新
const now = computed(() => Date.now())
```



## 计算属性缓存 vs 方法

若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于**计算属性值会基于其响应式依赖被缓存**

一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 `author.books` 不改变，无论多少次访 `publishedBooksMessage` 都会立即返回先前的计算结果，而不用重复执行 getter 函数

相比之下，方法调用**总是**会在重渲染发生时再次执行函数。



## 可写计算属性

计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告

只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建

```vue
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>
```



## 最佳实践

### Getter 不应有副作用

计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，**不要在 getter 中做异步请求或者更改 DOM**！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值

副作用操作是指与组件状态无关的操作，也就是除了当前组件状态的修改操作之外的所有操作。这些操作可能会对组件外部的状态产生影响，例如修改全局状态、更新其他组件的状态等



### 避免直接修改计算属性值

计算属性的返回值是一种派生状态，它可以被看作是一个临时的状态快照。每当计算属性依赖的源状态发生变化时，就会重新创建一个新的状态快照因此，计算属性的返回值应该被视为只读的，不能直接修改。如果要更新计算属性的值，应该更新它所依赖的源状态，以触发新的计算

所以在计算属性中使用 `reverse()` 和 `sort()` 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本

```diff
- return numbers.reverse()
+ return [...numbers].reverse()
```

