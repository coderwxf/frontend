组件从创建到销毁的整个生命周期中，存在多个阶段

在这每个阶段中，vue提供了对应的回调函数，以便于我们可以在特定阶段执行自定义逻辑

这些回调函数被称之为生命周期函数 或叫 生命周期钩子

Vue会直接按照普通函数调用的形式回调生命周期钩子 「 是同步调用的 」

回调函数中的this 指向 vue实例

![组件生命周期图示](https://cn.vuejs.org/assets/lifecycle_zh-CN.W0MNXI0C.png) 



执行`new Vue`创建vue实例后，经历如下流程:

1. `initLifecycle` => 初始化生命周期

2. `initEvents`  => 初始化事件处理系统 「 后期用于存储事件并进行事件绑定 」

3. `initRender` => 初始化实例的一些私有属性(`$slots`、`$attrs`、...)并赋初始值

4. **执行`beforeCreate` 生命周期钩子** 

   +  vue实例已经创建，但没有加载options api
   + 所以此时`data`、`methods`等options api都无法使用

   ```js
   beforeCreate() {
     // 在beforeCreate执行前，状态并没有被挂载
     console.log(this.name) // => undefined
   
     // 在beforeCreate执行前，方法并没有被挂载
     console.log(this.foo) // => undefined
   
     // 在beforeCreate执行前，私有属性已被挂载并初始化
     console.log(this.$refs) // => {}
   }
   ```

   

5. `initInjections/initProvide` 初始化`provide/inject`
6. `initState` 加载并执行options api 「 初始化响应式系统 」
   + `initProps`  => 初始化props
   + `initMethods` => 初始化methods
   + `initData` => 初始化状态
   + `initComputed` => 初始化计算属性
   + `initWatch` => 初始化侦听器

7. **执行`created`生命正确钩子**
   + 实例初始化完毕 「 该挂载的都挂载完了，该响应式处理的都响应式处理完了 」



8. 执行`$mount`，开始进行视图渲染

9. 在options api中是否编写了render方法，如果没有初始化一个返回空节点的render方法

10. **在第一次渲染之前，执行`beforeMount`生命周期钩子**

    「  beforeMount 和 created 中，vue处理的事情类似 => 两个回调区别不大 」



10. 执行渲染
11. **第一次渲染完毕，执行`mounted`生命周期钩子**
    + 此时真实DOM，已经创建并渲染完成
    + 此时vue内部标识`_isMounted`设置为true



12. 视图因为修改状态导致界面更新

13. 此时`_isMounted`的值已经为true了，表示组件是更新

    且此时`_isDestoryed`值为fasle，**所以执行`beforeUpdate`生命周期钩子**

14. 视图更新
15. **视图更新完毕，执行`updated`生命周期钩子**
16. **依次执行`$nextTick`方法向更新队列中插入的方法**



当组件销毁时 「 执行了`$destory`方法 或 路由切换 」

17. **执行`beforeDestory`生命周期钩子** 
    + 此时删除操作还没有执行，什么都可以正常操作
18. 组件卸载
19. **执行`destoryed`生命周期钩子**
    + 此时虚拟DOM已经被移除
    + 组件实例依旧存在，修改data值，依旧会触发响应式行为
    + 但此时`isDestoryed`标识已经变成了true，所以不会进行任何更新操作





如果是基于 `vm.$destroy` 这个方法销毁视图

+ 已经渲染的真实DOM不会被移除
+ 基于v-on绑定的事件都被移除了
+ 实例以及挂载到实例上的数据都还在，响应式劫持处理也有，但是当修改状态值，视图不再更新！！

路由切掉，组件失活，销毁，流程不一样



一般情况下

1. 在`created`或`beforeMount`或`beforeCreate`或`mounted`方法中发送网络情况

   + 一般是在`created`中 「 约定俗成 」
   + `created`或`beforeMount` 二选一即可

2. 在`mounted`方法中执行DOM操作

3. 在`updated`方法中可以获取更新后的DOM元素

   + 无论哪个状态导致的界面更新，都会触发`updated`方法

4. 在`beforeDestory`方法中

   + 执行手动绑定事件的卸载，定时器清理等清除操作

   + 如果要往storage中存入数据，可以在这个阶段执行「 如缓存用户输入的表单数据 」

     1. 这样可以避免频繁操作storage

     2. 但是页面直接关闭是不会触发`beforeDestory`和 `destoryed`方法的

        所以还需要在`window.beforeClose`方法中执行类似逻辑

   


数据获取是异步的，第一个渲染created调用，此时mounted调用时，DOM渲染完毕，但是数据没有获取到

数据获取到后，会触发updated，然后重新渲染视图





created和beforeMount，用其中的任意一个即可「一般用created」

真实项目中，我们一般在这里“向服务器发送异步的数据请求，来获取真实的数据”
+ 拿到真实数据后，修改状态，让视图更新，呈现真实的内容
+ 放在此处处理，可以确保视图在第一次渲染完毕后，可以尽快的获取到真实的数据

一般第一次渲染视图，都看不到真实的数据，此时我们可以让界面呈现“骨架屏”效果！拿到数据后，在视图更新的时候，再次呈现出真实的内容！！



**`visibilitychange`**

window.onbeforeunload = function(event) {
    alert(2222)
    return "确定要离开此页面吗？";
};



vue.set

$set

$destory

$delete

动画

什么时候挂载组合式api