1. data中数据会被深度劫持转变为状态后挂载到vue实例上
2. 任何被挂载到vue实例上的属性和方法可以直接在模板中使用
3. 直接挂载到vue实例上的数据
   + 可以在模板中直接使用
   + 但是没有经过数据劫持转变为响应式数据

```vue
<div id="app">
  <div>name: {{ name }}</div>
  <div>age: {{ age }}</div>
</div>

<script>
  const vm = new Vue({
    data: {
      name: 'Klaus',
    }
  });

  // 直接定义的数据，并不是响应式数据
  vm.age = 23;

  vm.$mount('#app');
</script>
```





## 基本原理

当一个数据变成响应式数据时，又可以被称之为状态。当修改响应式数据时，不仅会修改属性值，还会自动更新所有使用到该状态的地方，如UI界面。从而实现数据驱动视图渲染



vue2中，data在new Vue时候会执行`initData`

在`initData`方法中，会通过`Object.defineProperty`方法对data中的每一项数据进行getter和setter劫持

使其变成响应式数据，并将其挂载到vue实例上

1. Vue的响应式处理只针对于**普通对象**和**数组**

   + 函数对象，正则对象等 都不会被响应式处理

2. 对普通对象进行的响应式处理是 **深度响应式**

3. 如果对象被冻结了，数据值本身也就无法进行响应式处理了

   假设data结构如下

   ```js
   data = {
     frozen: Object.freeze({
       c: 100,
       d: '200'
     })
   }
   ```

   1. `frozen`属性变成了响应式数据，可以修改`frozen`属性对应的值并触发其响应式特性
   2. `frozen`所指向的那个对象，是一个被冻结对象，无法进行数据劫持，所以不是响应式数据



### 对象的处理

通过`Object.keys`方法获取每一个key并迭代处理，所以只能获取到 **可迭代**、 **非Symbol类型** 的 **实例属性 **进行处理



### 数组的处理

数组和对象处理不同，数组的每一项并没有进行劫持处理，而是对数组进行了原型重定向

数组的原型指向了一个自定义的新原型，新原型的原型指向了数组原来的原型方法

![image.png](https://s2.loli.net/2024/09/18/bmzISCDBWuwM7YK.png) 

在自定义的新原型对象中，重写了`pop`/`push`/`reverse`/`shift`/`sort`/`splice`/`unshift` 方法

所以

1. 直接通过索引修改数组，并不会触发响应式
2. 只有通过 重写的那七个方法，才会触发数组的响应式



对于Vue2来说，数据劫持发生在“new”这个阶段，此时在data中写的数据，才会被劫持；在“new”之后，手动设置的新对象成员，默认不会被数据劫持，所以建议任何状态都需要先在data中被定义并初始化



后续添加的数据如果需要响应式，可以使用`$set` 

1. `this.$set(对象，key，value)`

2. 这个对象不能是vue实例 



`$set`使用场景:

1. 新增成员的同时，让新增成员变成响应式的

   ```js
   this.$set(this.data, address, 'shanghai')
   ```

2. 修改现有非响应式数据，并不能起到任何的效果

3. 直接通过数组索引更新数据，会触发界面更新，但是数据项并不会被劫持处理 「 一次性的 」

   ```js
   this.$set(this.data.arr, 0, 1000)
   ```

   

示例

有一个数组状态，我们想把第一项修改为1000，并且让视图更新，有哪些办法？

1. `vm.arr.splice(0,1,1000)`
2. `vm.arr.shift()` + `vm.arr = [1000,...vm.arr]`
3. ` vm.$set(vm.arr, 0, 1000)`
4. `vm.arr[0]=1000` + `vm.$forceUpdate()`



## forceUpdate

`this.$forceUpdate()`  强制刷新界面

本质其实是在不修改任何状态的前提条件下，向更新队列中插入界面重新渲染任务

所以`this.$forceUpdate()`执行后，界面并不会立即更新，而是会和其它更新任务一起被批处理执行






















----

Object.freeze 冻结

1. 不修改枚举属性
2. 其余全部定义为false

configuration

+ 不能删除属性
+ 不能删除属性描述符

isFrozen = 检测是否被冻结
