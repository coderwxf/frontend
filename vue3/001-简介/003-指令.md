所有以 `v-` 开头的内容都是 Vue 提供的指令

指令其实就是给标签设置“自定义属性”，Vue在渲染视图的时候，会识别这些属性，根据不同的属性，实现不同的效果

```shell
v-xxx.修饰符 = "值/状态"
```



## 设置内容「 非表单元素 」

+ `v-html`：等同于`innerHTML`，可以识别HTML字符串，把字符串中出现的标签渲染为DOM结构
  + 注意需要避免XSS攻击
+ `v-text`：等同于`innerText`，会把所有内容都当做普通文本渲染
  + 类似于小胡子语法，但是没有小胡子语法灵活



## 元素显示或隐藏

`v-show`和`v-if`用于控制元素的显示和隐藏，指令值都是布尔类型值

+ `v-show`控制显示隐藏的原理：基于`display='none'`来控制元素显示隐藏
+ `v-if「/v-else/v-else-if」`控制显示隐藏的原理：基于控制元素的“销毁”和“渲染”，来控制元素显示隐藏



1. 频繁切换使用`v-show`, 不频繁切换使用`v-if`
2. 如果`v-if`和`v-show`出现于同一个元素上「 不推荐 」
   + `v-if` 优先级较高
     + 如果`v-if`的值是false，则直接不渲染
     + 如果`v-if`的值是true，再根据`v-show`的值判断元素是否显示



### `v-for` 

用来创建循环元素 「 谁需要重复渲染，就给谁添加 `v-for` 」

```shell
v-for = "(item, index) [in|of] 可迭代对象
```

1. `in`和`of`的实际效果是一致的
2. `(item, index)`的大括号是可以省略的 「 不推荐 」
3. 需要给循环的元素设置唯一不变的key值 「 值一般为string | number 」以用于优化DOM-DIFF算法



迭代的值
+ 数组 「 `(item, index) in arr` 」
+ 数字 「 `(item, index) in <num>` 」 --- 假设`num`是`5`，则按照 `[1, 2, 3, 4, 5]`进行解析
+ 字符串 「 `(item, index) in 'Klaus'` 」 --- 作为字符数组进行解析
+ 对象 「 (value, key, index) in user 」
  + 本质迭代的是`Object.entries(user)` 「 特殊处理 」
  + 所以只能迭代自身所有可迭代的非Symbol类型值
+ 其余可迭代对象，会先`Array.from([value])`转换为数组后，在按照数组规则进行迭代



强烈不建议v-for和v-if作用在相同的元素上

+ Vue2中：v-for的优先级高于v-if，如果作用在相同元素上，很可能出现刚创建就被销毁「浪费性能」

  ```html
  <template>
    <div>
      <ul>
        <!-- Vue2: 先执行 v-for，再执行 v-if -->
        <li v-for="item in items" :key="item.id" v-if="item.isVisible">
          {{ item.name }}
        </li>
      </ul>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {
        items: [
          { id: 1, name: 'Item 1', isVisible: true },
          // 这个项会被先渲染出来再销毁
          { id: 2, name: 'Item 2', isVisible: false },  
          { id: 3, name: 'Item 3', isVisible: true }
        ]
      };
    }
  };
  </script>
  ```

  

+ Vue3中：v-if的优先级高于v-for，如果作用在相同元素上，这样在v-if中是无法使用v-for中item/index

  ```html
  <template>
    <div>
      <ul>
        <!-- Vue3: 先执行 v-if，再执行 v-for -->
        <!-- 执行v-if的时候，v-for还没有被执行，所以不存在item.isVisible 「报错」 -->
        <li v-if="item.isVisible" v-for="item in items" :key="item.id">
          {{ item.name }}
        </li>
      </ul>
    </div>
  </template>
  
  <script>
  export default {
    data() {
      return {
        showItems: false,
        items: [
          { id: 1, name: 'Item 1' },
          { id: 2, name: 'Item 2' },
          { id: 3, name: 'Item 3' }
        ]
      };
    }
  };
  </script>
  ```

  

> 推荐使用`template标签`, 将`v-for`和`v-if`分开 
>
> template标签在解析时会被移除，所以template标签不能设置key属性



## 事件绑定

`v-on`（简写`@`）用于实现事件绑定

`v-on`的值可以是函数本身，也可以是函数调用

`v-on`实际是通过`addEventListener`绑定了一个内部方法，当方法执行时，实际执行的是内部方法 「 以便于对事件修饰符进行处理 」，而内部方法会去调用我们传入的函数或执行函数调用语句



```vue
<button @click="fun"> click me </button>
```

点击后，会执行fun方法，并传入事件对象



```html
<button @click="fn(10, 20, $event)"> click me </button>
```

点击后，内部会执行函数调用语句，并使用事件对象替换`$event`



### 修饰符

```shell
@click.xxx.xxx # .xxx 就是对应的修饰符「可以同时用多个」
```



| 普通修饰符 | 描述                                            |
| ---------- | ----------------------------------------------- |
| stop       | 阻止事件(冒泡)传播                              |
| prevent    | 阻止默认行为                                    |
| capture    | 捕获阶段触发                                    |
| self       | 只有事件源是本身时才会触发                      |
| once       | 事件绑定只处理一次，处理完毕后，移除事件绑定    |
| passive    | 禁用`preventDefault` 「 提高高频事件的流畅性 」 |



| 按键修饰符 | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| [keyword]  | 各种按键修饰符 「 如enter/tab/delete/esc/space/up/right/down/left等 」 |
| [number]   | 按键码 「 如`@keyup.13='xxx'` 等价于 `@keyup.enter='xxx'` 」 |
| 自定义按键 | `Vue.config.keyCodes.kk = 13` 「 通过`Vue.config`进行全局配置 」<br />`@keyup.kk='xxx'` 也是按下 Enter 键才触发 |
| 系统按键   | `ctrl/alt/shift/meta`                                        |
| 组合按键   | `@keyup.alt.65` -> 同时按 Alt+a                              |
| 鼠标按键   | `left/right/middle`                                          |
| exact      | 实现精准匹配<br />`@click.ctrl.exact`表示只有ctrl键被按下时触发<br />`@click.ctrl`表示有ctrl键按下即可 「 可以是ctrl键和其它键一起按下 」 |



### 事件委托

在循环元素上添加事件绑定。vue并不会自动进行事件委托操作，需要手动进行事件提升

```html
<div id="app">
  <button
    v-for="user in users"
    :key="user"
    @click="printUser(user)"
  >
    {{ user }}
  </button>
</div>

<script>
  const vm = new Vue({
    data: {
      users: ['Klaus', 'Alex', 'Steven']
    },
    methods: {
      printUser(user) {
        console.log(user)
      }
    }
  });

  vm.$mount('#app');
</script>
```

上述代码修改为

```html
<div id="app">
  <div @click="printUser">
    <button
      v-for="user in users"
      :key="user"
      :data-user="user"
    >
      {{ user }}
    </button>
  </div>
</div>

<script>
  const vm = new Vue({
    data: {
      users: ['Klaus', 'Alex', 'Steven']
    },
    methods: {
      printUser(e) {
        const target = e.target
        if (target.tagName === 'BUTTON' && target.dataset.user) {
          console.log(target.dataset.user)
        }
      }
    }
  });

  vm.$mount('#app');
</script>
```



## 属性绑定

v-bind（简写:） 用于动态绑定元素的属性

v-bind 主要有两个作用：

1. 绑定非字符串类型值。
2. 将JavaScript表达式绑定到元素的属性上
3. 组件也可以使用`v-bind`，用于传递`props`

```vue
<!-- v-bind的值可以是任何合法JavaScript表达式 -->
<div :age="23"></div> <!-- 这里的age是number类型值 -->

<div age="23"></div>  <!-- 这里的age是string类型值 -->
```



## 设置内容 「 表单元素 」

`v-model`实现了数据的双向绑定。当表单元素的内容发生变化时，对应的状态也会自动更新。

```vue
<input type="text" :value="name" @input="e => name = e.target.value">
```

简化为了

```html
<input type="text" v-model="name">
```



### 修饰符

| 修饰符 | 功能                                                         |
| ------ | ------------------------------------------------------------ |
| lazy   | 将监听事件从默认的 `input` 改为 `change`，从而实现类似节流的效果<br />即只在输入框失去焦点或内容真正变化后再更新绑定的值 |
| number | 默认情况下，表单内容是字符串形式<br />使用 `number` 修饰符后，会将输入的内容自动转换为数字类型并赋值<br />如果无法转换，静默失效 |
| trim   | 去除表单内容的首尾空格后，再赋值给对应的状态。               |



### 绑定值

 `radio`：无论存在多少个，`v-model` 绑定的值是选中项对应的 `value`

多选 `checkbox`：如果是单个 checkbox，`v-model` 绑定的值是布尔值；如果是一组 checkbox，`v-model` 绑定的是选中项的 `value` 构成的数组。 「 通过同一个`v-model`值进行分组 」

对于 `select` 元素，单选时 `v-model` 是选中项的 `value`，多选时 `v-model` 是选中项的 `value` 构成的数组。



```html
<div id="app">
  <input type="radio" id="one" value="One" v-model="picked" />
  <label for="one">One</label>

  <input type="radio" id="two" value="Two" v-model="picked" />
  <label for="two">Two</label>

  <div>Picked: {{ picked }}</div>
</div>

<script>
  const vm = new Vue({
    data: {
      picked: 'One'
    }
  });

  vm.$mount('#app');
</script>
```



如果 `v-model` 表达式的初始值不匹配任何一个选择项，`<select>` 元素会渲染成一个“未选择”的状态

在 iOS 上，这将导致用户无法选择第一项，因为 iOS 在这种情况下不会触发一个 change 事件。

因此，建议始终提供一个空值的禁用选项

```vue
<select v-model="citys">
  <option value="" disabled>请选择</option>
  <option value="beijing">北京</option>
  <option value="shanghai">上海</option>
  <option value="guangzhou">广州</option>
  <option value="shenzhen">深圳</option>
  <option value="hangzhou">杭州</option>
</select>
```



## 渲染优化

#### v-pre

`v-pre` 用于指示 Vue 跳过这个元素及其后代元素的编译。

对于含有静态内容的区域，使用 `v-pre` 可以避免不必要的编译过程，直接输出内容，提升性能。具体来说，它会忽略数据绑定和指令的编译，并原样渲染元素的 HTML。

Vue 3 对静态内容的处理做了很多优化。它引入了**静态提升**和**静态节点缓存**，自动识别静态节点并跳过这些节点的重复编译。

因此，对于静态内容，Vue 3 的默认行为已经足够高效，通常不再需要手动使用 `v-pre` 来提升性能。



### v-cloak

`v-cloak` 是 Vue 中用于防止模板在数据未完全渲染时出现的闪烁问题。

当 Vue 的实例尚未挂载到 DOM 上时，可以通过 `[v-cloak]` 选择器隐藏尚未渲染的元素，一旦 Vue 完成模板的解析和渲染，`v-cloak` 属性会自动移除。

使用 SFC 时，由于模板是通过 Vue 的编译器进行静态编译，而非动态编译。因此，通常不需要依赖 `v-cloak` 来防止模板渲染不完整的情况。



###  v-once

当使用 `v-once` 指令时，Vue 只会在组件首次渲染时对该元素及其子元素进行编译和渲染。

此后，无论状态如何变化，带有 `v-once` 的元素及其内容都不会重新渲染



### v-memo

