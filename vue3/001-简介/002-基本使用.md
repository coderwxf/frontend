Vue2是类，通过new Vue，并传入配置项来完成对应功能，这些配置项叫options api

```js
const vm = new Vue({
  // 配置项
});
```

每个实例都有自己的数据和逻辑处理 「 理论上页面可以存在多个vue实例，实例之间不会冲突 」



## 指定视图

假设挂载点为`#app`， vue渲染后内容会替换`#app`中原本内容



**模板使用**:  

![image.png](https://s2.loli.net/2024/09/15/Nxyq46dzLBec7a1.png) 



**挂载点指定:**  

![image.png](https://s2.loli.net/2024/09/15/HM1Q5ylI3A2qZ4p.png) 



>   el配置项和`$mount`的参数 可以是以下两种中的任意一种
>
> 1. css选择器
> 2. DOM元素



还有一种挂载方式是使用`render`函数，并结合JSX

```js
const vm = new Vue({
    el: '#app',
    data: () => ({
      msg: 'Hello World'
    }),
    // render方法需要返回虚拟DOM
    render(h) {
      return (
         // h 是 createElement 的缩写 -- 用于创建虚拟DOM
        h('h2', { class: 'title' }, this.msg)
      )
    }
  })
```



最常用的挂载方式是

1. 模板 编写在 挂载点下
2. 模板通过`$mount`方法进行挂载

以便于在实际挂载前，对vue实例进行一系列额外操作



## data

Vue 会对data中定义的数据进行深度监听和劫持，确保数据的修改能够触发视图的更新

```html
<div id="app">
  <!-- 只要数据被挂载到vue实例上，就可以直接在模板中使用 -->
  <div>name: {{ name }}</div>
  <div>age: {{ age }}</div>
</div>

<script>
  const vm = new Vue({
    // data中定义的数据，会被getter/setter劫持后作为vm的实例属性
    // 所以只有data中定义的数据，才是响应式数据，又被称之为状态
    data: {
      name: 'Klaus',
    }
  });

  // 直接定义的数据，并不是响应式数据
  vm.age = 23;

  vm.$mount('#app');
</script>
```



## template

Vue 中有两个常见的视图构建语法，一个是 `template` 语法，另一个是类似于 React 的 JSX 语法。

`template` 语法中有两个主要的知识点，一个是双大括号（`{{}}`）的“插值”语法，另一个是 Vue 特有的指令（如 `v-for`、`v-if` 等）

> `{{ }}` => 小胡子语法、mustache语法
>
> `{ }` => 大胡子语法、大括号语法



小胡子语法「 双大括号语法 」中嵌入的是“JS表达式”

```vue
{{ message }}
```



### 渲染细节

基本数据类型:  

1. `null/undefined` 渲染为空
2. 其余情况都可以理解为都转换为了字符串 ：`String([value])`

```js
String(10n) // => '10'
String(Symbol()) // => 'Symbol()'
```



引用数据类型:

1. 普通对象/数组对象，是基于 JSON.stringify 变为JSON字符串进行渲染
2. 其余的对象，也可以理解为都是基于 String([value]) 变为字符串进行渲染

```js
JSON.stringify({name: 'Klaus'}) // => '{"name":"Klaus"}'
JSON.stringify([1, 2, 3]) // => '[1, 2, 3]'

// 没有参数，返回undefined 「不是字符串」
JSON.stringify() // => undefined 

JSON.stringify(/\d/) // => ’{}‘ // 转换失败，默认返回空对象
```



在mustache中，可以运行一些指定的window下的方法
「例如：JSON.parse/stringify、parseInt、Number、String等」

但并不是全部，具体可以运行那些，取决于vue中定义的[白名单列表](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9)



## 数据劫持

- **Vue 2** 使用 `Object.defineProperty` 实现数据劫持，通过定义 getter 和 setter 来追踪数据的读取和修改。
- 在 **getter** 中，Vue 会收集当前的依赖，以便在数据变化时更新。
- 在 **setter** 中，当数据被修改时，Vue 会通知所有依赖进行更新，实现自动更新界面的效果。



### 初始化 data

- Vue 使用 `Object.keys` 获取所有可枚举的实例属性（不包括 Symbol 类型和不可枚举的属性），并对这些属性进行数据劫持。
- 劫持后的数据会挂载到组件实例上，以便在模板中直接访问。
- Vue 会递归地对对象和数组进行深度劫持，确保嵌套的数据结构也能被追踪。
- Vue 不会处理 Symbol 类型的属性名和不可枚举的属性。这些属性不会被挂载到实例上，也不会进行数据劫持。
- 对于数组，Vue 不会对每个索引项做 GET/SET 劫持，而是通过重定向数组原型来实现：
  - 「数组.`__proto__` -> 自定义原型对象 -> Array.prototype」
  - 自定义原型对象上有 7 个方法：`push/pop/shift/unshift/splice/sort/reverse`
  - 基于这 7 个方法修改数组时，可以通知视图更新。



### 劫持限制

- Vue 只对普通对象和数组进行劫持，原始类型（如字符串、数字、函数等）不需要劫持。
- 如果对象被冻结（使用 `Object.freeze`），Vue 无法对其属性进行劫持，因为冻结的对象不能被修改。



### 响应式数据

- 在 Vue 2.x 中，响应式数据是在实例化时通过 `data` 中定义的数据实现的。
- 只有在 `data` 中声明的属性才会被 Vue 的响应式系统劫持。
- 如果在实例化后手动添加属性，这些属性默认不会是响应式的，除非使用 `$set` 方法。



### 建议

1. 在 `data` 中提前声明所有需要的响应式数据。
2. 如果数据是响应式的，在设置值时，会将设置的值转换为响应式数据。



### 使用 `$set`

- 如果不想在 `data` 中预先声明，可以使用 `$set` 方法：

```javascript
vm.$set(object, key, value);
```

- 不能给 `vm` 实例对象直接设置属性。
- 示例：`vm.$set(vm.user, 'age', 23);`
  - 给对象新增属性，新增属性是响应式的。
  - 对象本身不是响应式数据，通过 `$set` 无法将其转变为响应式数据。
  - 基于 `$set` 可以保证修改数组信息时视图更新，但不会对每个索引项做 GET/SET 劫持。



### 强制更新

- 使用 `vm.$forceUpdate()` 可以强制视图更新。



### 面试题：如何修改数组的第一项并更新视图？

1. `vm.ary.splice(0, 1, 1000)`
2. `vm.ary.shift()` + `vm.ary = [1000, ...vm.ary]` （只能改首尾数据）
3. `vm.$set(vm.ary, 0, 1000)`
4. `vm.ary[0] = 1000` + `vm.$forceUpdate()`



## methods

1. 在`new Vue`阶段

   + 使用`bind`方法，将函数中的this修改为vue实例对象，

     并将修正this后的新method挂载到组件实例上

     所以method不要写成箭头函数 

     

2. 修改methods，视图不需要更新，所以methods中的方法不需要进行响应式处理

