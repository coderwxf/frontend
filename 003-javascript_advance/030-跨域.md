## 同源策略

同源策略是一个重要的`浏览器安全策略`

同源策略用于`限制一个origin的加载的文档(html)或者脚本(js)如何能与另一个源的资源(API服务器提供的数据资源)进行交互`

同源策略能帮助阻隔恶意文档，减少可能被攻击的媒介

源(origin) = 协议(protocol) + 主机名(host) + port(端口)

源 也 被称之为 协议/主机/端口元组 ---> `const origin: [string, string, string] = [protocol, host, port]`

只有当两个源对应的协议，主机名，端口号全部都一致的前提条件下，浏览器才会认为这两个源是同源

![image.png](https://s2.loli.net/2022/12/20/KhSJskrFjm4gY58.png)

1. 浏览器向静态资源服务器请求对应的html

2. 在解析html的时候，会读取到对应的css和js，此时浏览器就会去加载对应的css和js

3. 浏览器执行对应JS，向API服务器发送请求

4. 服务器向浏览器返回对应的数据

5. 因为此时第一次在获取html的时候 是通过`https://www.example.com`获取

   所以浏览器认为此时的源是`https://www.example.com`

   但是此时对应的数据来源于`https://api.example.com`

   浏览器就会因为同源安全策略，阻止这些数据和资源的加载

   并在控制台报对应的跨域错误



## 跨域代码模拟

`客户端`

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    fetchUserList()

    async function fetchUserList() {
      const request = await fetch('http://localhost:3000/list')
      const res = await request.json()

      console.log(res)
    }
  </script>
</body>
</html>
```



`服务器`

```js
const Koa = require('koa')
const Router = require('@koa/router')

const app = new Koa()

const router = new Router()

router.get('/list', ctx => {
  ctx.body = [
    {
      id: 001,
      name: 'Klaus'
    },
    {
      id: 101,
      name: 'Alex'
    },
    {
      id: 301,
      name: 'Steven'
    }
  ]
})

app.use(router.routes())
app.use(router.allowedMethods())

app.listen(3000)
```



## 解决方法

`常见解决方法`

1. 静态资源和API服务器部署在同一个服务器中
2. CORS， 即是指跨域资源共享
3. node代理服务器
4. Nginx反向代理

`不常见的解决方法`

1. JSONP -- 逐渐被淘汰

2. postMessage

3. websocket

   跨越问题主要出现在`浏览器和服务器之间的 HTTP 请求`和`在一个页面使用 JavaScript 进行跨文档消息传递（也称为跨文档通信）`

   在 socket 通信中，两台计算机之间的通信是通过一个叫做 socket 的通信端口进行的。

   通过 socket 通信，两台计算机之间可以进行双向数据传输，而不需要经过浏览器或者 HTTP 协议

   因此，在 socket 通信中，并不会出现跨域问题



### 静态资源和API服务器部署在同一个服务器中

现实场景中，静态资源和API服务器一般不位于同一个服务器中

而且API服务器不仅需要为浏览器提供数据，也需要想客户端等别的用户代理提供对应服务

```js
const Koa = require('koa')
const Router = require('@koa/router')
const static = require('koa-static')

const app = new Koa()
const router = new Router()

router.get('/list', ctx => {
  ctx.body = [
    {
      id: 001,
      name: 'Klaus'
    },
    {
      id: 101,
      name: 'Alex'
    },
    {
      id: 301,
      name: 'Steven'
    }
  ]
})

app.use(router.routes())
app.use(router.allowedMethods())

// 将客户端代码在部署的时候 作为静态资源
// 和服务器对应服务部署在一起，因为在同源中，因此不会跨域

// ps: staitc方法的参数有以下两点注意事项:
// 1. 一个文件夹的相对路径
// 2. 该文件夹相对于服务器项目运行目录
app.use(static('./client'))

app.listen(3000)
```



### CORS

跨源资源共享(CORS， Cross-Origin Resource Sharing 跨域资源共享) 是一种基于http header的机制

CORS是一系列形如 `Access-Control-*`的响应头，对应的值是域名或*（通配符，即所有域名）

当浏览器解析到这些CORS头后，如果当前域名满足对应的值，那么浏览器就会认为该请求是安全的

那么就可以通过浏览器的同源检测，避免跨域错误的出现



#### 分类

CORS可以分为两类: `简单请求` 和 `非简单请求`

简单请求必须满足如下几个条件:

1. 只能使用 GET、HEAD 和 POST 方法

2. 除了浏览器自动设置的请求头，可以主动设置的请求头列表如下:

   + Accept --- 浏览器可以接收那些文件类型

   + Accept-Language --- 客户端希望接收的语言列表

   + Content-Language --- 指示服务器发送的资源的语言

   + Content-Type:只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain

     `也就是不能是application/json`

不满足上述条件的任何一个请求都被称之为非简单请求



#### Access-Control-*

`简单请求`

```shell
# 对于简单请求，设置的头也很简单
# Access-Control-Allow-Origin: 域名

# 假设服务器的 origin 为 api.example.com
# 可以通过www.example.com 访问 api.example.com中的数据
Access-Control-Allow-Origin: www.example.com

# 设置多个可以访问的域名 --- 使用逗号进行分割
Access-Control-Allow-Origin: www.example.com,news.example.com

# 任何的域名 都可以访问 api.example.com中的数据
Access-Control-Allow-Origin: *
```



```js
const Koa = require('koa')
const Router = require('@koa/router')

const app = new Koa()
const router = new Router()

// 定义一个通用的中间件
// 该中间件需要被定义在最前面
// 以便于在执行所有的路由之前 都可以匹配并执行该中间件
app.use(async (ctx, next) => {

  // ctx.set方法 --- 设置对应的响应头
  // ps: 在Access-Control-Allow-Origin 中 域名和对应ip会被识别为两个不同的origin
  // ctx.set('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')
  ctx.set('Access-Control-Allow-Origin', '*')

  // 调用下一个中间件
  // 因为在koa中 中间件返回的是promise
  // 所以如果下一个中间件中进行了异步操作
  // 那么在该中间件中需要使用await next() 而不是next() 来执行下一个中间件
  next()
})

router.get('/list', ctx => {
  ctx.body = [
    {
      id: 001,
      name: 'Klaus'
    },
    {
      id: 101,
      name: 'Alex'
    },
    {
      id: 301,
      name: 'Steven'
    }
  ]
})

app.use(router.routes())
app.use(router.allowedMethods())

app.listen(3000)
```



`非简单请求`

对于非简单请求而言，光设置`Access-Control-Allow-Origin`是无法达到跨域资源访问的目的的

还需要添加如下几个头

| header                           | 说明                                                         | 示例                                                         |
| -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Access-Control-Allow-Headers     | 跨域请求时，允许使用的自定义头信息                           | Access-Control-Allow-Headers：Accept, AcceptEncoding, Connection, Host, Origin |
| Access-Control-Allow-Credentials | 跨域请求时，是否需要携带用户凭证(如cookie， token等)<br />值是一个boolean类型的值<br />默认值是false | Access-Control-Allow-Credentials: true                       |
| Access-Control-Allow-Methods     | 跨域请求时，处理GET,POST,HEAD之外 还允许那些请求方式         | Access-Control-Allow-Methods: PUT, POST, GET, DELETE, PATCH, OPTIONS |

> 1. 上面三个头 只有在需要发送非简单跨域请求的时候，才需要结合`Access-Control-Allow-Origin`一起进行设置
>
>    在简单的跨域请求下只要设置`Access-Control-Allow-Origin`即可
>
> 2. 上面三个头 在设置的时候，是覆盖浏览器的默认值，而不是在浏览器默认值的基础上进行额外添加
>
>    所以如果你需要再浏览器默认值的基础上额外添加，那么需要将新值和默认值都重新进行设置



`浏览器`

```js
async function fetchUserList() {
  // 参数一 --- url地址
  // 参数二 --- 配置对象
  const request = await fetch('http://localhost:3000/list', {
    // 请求方法 - 不区分大小写
    method: 'PUT'
  })
  const res = await request.json()

  console.log(res)
}
```



`服务器`

```js
app.use(async (ctx, next) => {
  // 当设置Access-Control-Allow-Credentials为true的时候
  // Access-Control-Allow-Origin必须为具体的域名
  // 这样浏览器才只要需要将用户凭证发送给那个域名
  ctx.set('Access-Control-Allow-Origin', 'http://127.0.0.1:5500')

  // 值有多个的时候，使用逗号分隔的字符串表示
  ctx.set("Access-Control-Allow-Headers", "Accept, AcceptEncoding, Connection, Host, Origin")

  // 当设置 为true后，在浏览器发送对应的请求时，也需要将withCredentials选项同时设置为true，以允许发送跨域请求时使用凭据
  ctx.set("Access-Control-Allow-Credentials", true)
  ctx.set("Access-Control-Allow-Methods", "PUT, POST, GET, DELETE, PATCH, OPTIONS")

  await next()
})
```



#### option请求

对于每一次非简单跨域请求之前，都会触发一次对应的option请求

（如果需要查看对应的预检请求 --> network页签 - 网络请求部分，分类为`other`的相关请求中进行查看）

该option请求被称之为预检请求，此时浏览器并不会返回具体的响应信息



而是会将对应的`Access-Control-*`头返回，以便于浏览器检测该请求是否可以通过同源策略

如果可以通过同源策略，那么才会发生真正的请求，如果并不能通过同源策略，会直接抛出跨域错误



除了返回`Access-Control-*`之外，预检请求还会返回一些用于描述该接口基本信息的响应头

其中之一就是`Allow`，该响应头包含了对应接口支持哪些请求方式

1. 除了原本的请求方式，每个请求默认都支持通过`Head`方式来进行数据请求
2. 所以可以通过预检请求获取对应的接口可以支持哪些请求方式



在进行预检请求的时候，会使用到两个仅仅只会在预检请求中使用的请求头

| 请求头                         | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| Access-Control-Request-Headers | 该字段是一个逗号分隔的字符串<br />指定浏览器CORS请求会额外发送的头信息字段 |
| Access-Control-Request-Method  | 列出浏览器的CORS请求会用到哪些HTTP方法                       |



但是在实际的开发过程中并不会直接使用CORS

而是在客户端和服务端之间添加一个代理服务器

在代理服务器上开启对应的CORS

浏览器请求对应的数据的时候，是向代理服务器申请

而代理服务器在帮助我们向真正的服务器请求对应的数据

这样代理服务器不仅仅可以起到解决跨域的作用

同时还可以实现类似于负载均衡，防火墙，权限控制等相关功能

其中 由内网向外网进行访问的代理服务器被称之为正向代理服务器

由外网向内网进行代理访问的服务器，被称之为反向代理服务器，常见的有nginx



`测试环境`

在测试环境，往往使用node代理服务器，在这里我们通过第三方中间件`http-proxy-middleware`来实现

```js
const express = require('express')
// http-proxy-middleware 只能用于express
// 如果需要再koa中使用，需要使用中间件以使koa支持express的中间件
const { createProxyMiddleware } = require('http-proxy-middleware')

const app = express()

app.use('/api', (req, res, next) => {
  // 为代理服务器开启CORS
  // 在开发中使用webpack-dev-server实际上也是使用了http-proxy-middleware
  // 只不过他将测试代码和代理服务器部署到了一个服务器上，所以并不需要开启cors
  res.setHeader('Access-Control-Allow-Origin', '*')
  next()
  // 开启代理
} ,createProxyMiddleware({
  // 需要代理到那条服务器上
  target: 'http://localhost:3000',
  // 路径重写，是一个映射表
  // 也就是 /api/list -> /list
  // 加上/api前缀是为了特定标识 该url是一个代理路由
  pathRewrite: {
    '^/api': ''
  }
}))

app.listen(3001)
```



`生产环境`

在实际生产环境中，往往采用[nginx](https://nginx.org/en/download.html)来进行反向代理

1. mac 在安装nginx前需要安装[homebrew](https://www.jianshu.com/p/e0471aa6672d)
2. [Mac 中nginx的安装](https://m.imooc.com/wiki/nginxlesson-macosinstall)
3. 安装完毕后再浏览器中输入localhost(有的版本对应默认接口是8080，有的是80) 可以看到nginx的欢迎页即安装成功

```shell
# 如果访问/路径下对应资源
location / {
  root   html;
  # 默认返回的页面为index.html
  index  index.html index.htm;

  # nginx 配置使用分号进行结尾
  # 添加响应头 Access-Control-Allow-Origin 值为 *
  add_header Access-Control-Allow-Origin *;

  # 对应的请求转发到 http://localhost:3000
  proxy_pass http://localhost:3000;
}
```