## 原型

### 隐式原型

在每一个JS对象中，都有一个隐藏属性`[[prototype]]`

`[[prototype]]`属性的值 就是我们所谓的`原型对象`，这个原型也被称之为隐式原型



#### 作用

当我们调用`[[get]]`方法的时候，也就是获取对象属性的时候

1. 先去对象自身上寻找是否存在对应的属性，找到就获取对应的值

2. 如果对象自身上不存在对应的属性，就会去对象的原型上查找对应的属性

3. 如果依旧不存在会去对象的原型的原型去查找对应的属性

4. 依次类推，直到查找到Object.prototype.prototype 结束

   因为 Object.prototype.prototype的值是null

5. 如果还是查找不到则返回undefined



#### 获取

```js
const user = {
  name: 'Klaus',
  age: 23
}

// __proto__ 可以方便获取原型，但不是标准方法，是大部分浏览器自己实现的 可能存在兼容性问题
console.log(user.__proto__) 

// Object.getPrototypeOf 是标准中获取对象原型的方法
console.log(Object.getPrototypeOf(user))
```



### 函数原型

任意一个对象 都具备隐式原型(对象原型)`__proto__` 

 --- 用于查找对象属性



而任意一个函数，除了具备隐式原型之外，还具备一个显示原型(函数原型)  `prototype`

--- 用于在构建对象的时候, 为对象设置隐式原型



#### 作用

当我们通过new操作符创建一个对象的时候，其会执行如下操作:

1. 创建一个空对象

2. 将构造函数的显示原型对象赋值给实例对象的隐式原型对象

   即 `实例.__proto__ = 构造函数.prototype` 

3. 将空对象赋值给this

4. 执行构造函数代码

5. 如果显示返回一个对象 --- 则返回显示指定的那个对象

   如果没有显示返回一个对象 --- 则返回this所指向的那个对象

> 其中 第2步 操作 和 第3步操作 没有先后顺序，谁先谁后皆可



此时我们可以将实例共有的属性和方法 放到显示原型对象上

因为所有的实例对象的隐式原型对象和构造函数的显示原型对象本质上是同一个对象

所以通过该构造函数创建出来的所有实例 都可以直接使用该构造函数的显示原型对象

```js
function User(name) {
  this.name = name
}

const user1 = new User('Klaus')
const user2 = new User('Alex')

console.log(user1.__proto__ === user2.__proto__) // => true
console.log(user1.__proto__ === User.prototype) // => true
```



所以简而言之

`隐式原型对象`，是`为了形成原型链，从而便于对象查找对应的属性和方法`

`显示原型对象`，是`为了在创建实例对象的时候，对实例对象的隐式元素对象进行初始化操作`

`显示原型和隐式原型的共同组合使一些所有实例对象共有的属性和方法可以保存到一个公共的对象上，从而实现代码的复用`



## contructor

原型对象上面默认有一个属性`constructor`

`constructor`的值就是当前原型对象对应的构造函数

```js
function Person() {}

console.log(Person.prototype.constructor === Person) // => true
```

![image.png](https://s2.loli.net/2023/04/08/CVWmrGXJjcH6O4e.png)  

```js
function Person() {}

const per = new Person()

// 下述代码等价于 const per1 = Person()
const per1 = per.constructor()

// 原型上的constructor属性 可以用来判断 实例是通过那个构造函数来创建的
console.log(per.constructor === Person) // => true
```



## 重写原型对象

如果我们需要在原型上添加过多的属性，通常我们会重写整个原型对象

```js
function User(name) {
  this.name = name
}

User.prototype = {
  running() {
    console.log('running')
  },

  eatting() {
    console.log('eatting')
  }
}

// 默认原型对象上，存在默认属性constructor
// 如果重写原型对象，那么就需要手动添加constructor属性
// 原型对象的constructor属性是不可枚举的，可配置的，可写的，值指向对应的构造函数

// 为constructor 添加对应的数据属性描述符
Object.defineProperty(User.prototype, 'constructor', {
  configurable: true,
  writable: true,
  value: User
})
```



## 箭头函数的原型

在ES6之前，任何一个函数即可以作为构造函数使用new来进行调用，也可以作为普通函数使用小括号进行调用

但是自ES6开始，为了职责单一，将构造函数调用和普通函数调用进行分离

对于ES6的箭头函数，是没有显示原型对象的，因此箭头函数只能通过普通调用方式进行调用，不可以通过new关键字进行调用

而对应的ES6中的类，虽然其本质依旧是普通function定义的构造函数

但是ES6中的类只能通过new关键字进行调用，不能通过普通方式进行调用



## 原型链

从一个对象上获取属性，如果在当前对象中没有获取到就会去它的原型上面获取

而显示原型对象本质也是一个对象，所以原型对象也有自己的隐式原型对象

所以JS在查找对象的属性和方法的时候遵循如下的规则：

1. 在自身上进行查找
2. 去自身的原型对象上查找
3. 去自身原型对象的原型对象上查找
4. 子自身原型对象的原型对象的原型对象上查找
5. 。。。
6. 因为`Object是所有类的父类`，所以最后会在 Object.prototype上进行查找
7. 如果在Object.prototype上依旧没有找到，就会去`Object.prototype.__proto__`去进行查找
8. 而`Object.prototype.__proto__的值为null，表示的是查找到了顶层，此时就会返回undefined`

这样的查找过程，就被称之为原型链
