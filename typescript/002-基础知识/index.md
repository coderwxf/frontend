JS是动态数据类型 操作是否合法只能通过运行代码来确定, 但这就意味着可能存在许多潜在的没有被发现的错误

静态类型系统描述了我们运行程序时值的形状和行为

TypeScript这样的类型检查器使用这些信息，在代码运行之前帮助我们发现这些错误、并在代码可能出现问题时告诉我们。



在TypeScript中，当我们在运行代码之前使用静态类型检查时，我们会在编译阶段收到错误消息。

这意味着，在我们实际执行代码之前，TypeScript编译器会分析我们的代码并检查类型错误。如果存在类型不匹配或其他类型相关的错误，编译器将在编译过程中发出错误消息。

这种静态类型检查可以帮助我们在代码运行之前发现潜在的问题，并提供及时的反馈。通过在编译阶段捕获错误，我们可以避免一些常见的运行时错误，例如访问不存在的属性或调用不可调用的函数。

因此，使用TypeScript进行静态类型检查可以提供更早的错误反馈，帮助我们在代码运行之前发现问题并进行修复，从而提高代码的质量和健壮性。



TypeScript不仅可以捕获到那些ECMA中明确定义的错误，也可以捕获到那些可能导致运行时错误的合法操作

TypeScript不仅仅可以捕获类型错误，还可以在我们编写代码时进行代码补全操作





类型注解
在TypeScript中，类型注解是记录函数或变量预期合约的轻量级方式

尽管存在错误，greeter.js文件仍然被创建。即使代码中有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript正在警告你的代码可能无法按预期运行。

我们并不总是需要编写显式的类型注解。在许多情况下，即使我们省略了类型注解，TypeScript也可以推断（或者说"弄清楚"）类型。

这是一个特性，最好不要在类型系统能够推断相同类型的情况下添加注解。



实际上没有任何浏览器或其他运行时可以直接运行未修改的TypeScript代码



TS编译为js时

1. 类型擦除
2. 自动开启严格模式



默认情况下，TypeScript的目标是ES3，这是一个非常旧的ECMAScript版本。

我们可以使用target选项选择稍微更新一些的版本。

使用--target es2015运行将使TypeScript的目标变为ECMAScript 2015，这意味着代码应该能够在支持ECMAScript 2015的任何地方运行



默认情况下，TypeScript的目标是ES3，但是当前大多数浏览器都支持ES2015。因此，大多数开发人员可以安全地将目标指定为ES2015或更高版本，除非与某些古老的浏览器的兼容性很重要



将代码从较新或"更高"的ECMAScript版本降级到较旧或"更低"的版本有时被称为降级

```shell
tsc --target es2015 hello.ts
```

与"优雅降级"相对的概念是"渐进增强"（Progressive Enhancement）。

"渐进增强"是一种开发理念，它强调从基本的功能和广泛支持的环境开始，然后逐步增加更多的功能和改进，以满足更高级的环境或设备的能力。在渐进增强的方法中，首先确保基本功能在所有环境中可靠运行，然后根据环境的能力逐步添加更高级的功能。



严格性

默认情况下，ts中的严格性检测是宽松的，推断采用最宽松的类型，并且不会检查潜在的null/undefined值

这可以在验证程序的部分内容的基础上，使TypeScript仍然具有良好的工具支持



严格性设置将静态类型检查从一个开关（要么检查代码，要么不检查）转变为更接近于一个调节旋钮的东西。

您将此旋钮调高的程度越高，TypeScript就会为您进行更多的检查。

这可能需要额外的工作，但一般来说，长期来看这是值得的，并且可以实现更全面的检查和更准确的工具支持。

在可能的情况下，新的代码库应始终打开这些严格性检查。



TypeScript具有几个可以打开或关闭的类型检查严格性标志

在CLI中使用strict标志，或在tsconfig.json中使用"strict": true可以同时打开它们，但我们也可以单独关闭它们。您应该了解的两个最重要的标志是noImplicitAny和strictNullChecks。



noImplicitAny

如果TS无法推测出准确的类型，默认类型将会是any

虽然退回到any只是普通的JavaScript体验。但是使用any往往会削弱使用TypeScript的目的

程序类型化程度越高，验证和工具支持就越多，这意味着在编码过程中会遇到更少的错误。

打开noImplicitAny标志将对隐式推断为any的变量发出错误。



strictNullChecks

默认情况下，null和undefined等值可以赋值给任何其他类型。这可能会使编写某些代码变得更容易，但是忘记处理null和undefined是世界上无数错误的根源

strictNullChecks标志使处理null和undefined更加明确，并且使我们不必担心是否忘记处理null和undefined。



