身份函数。身份函数是一个会返回传入的任何内容的函数。你可以将其类比为回声命令



我们需要一种捕获参数类型的方法，以便我们还可以用它来表示返回的内容。

在这里，我们将使用类型变量，这是一种特殊类型的变量，用于处理类型而不是值, 这种类型变量被称之为泛型

```ts
function identity<Type>(arg: Type): Type {
	return arg;
}

let output = identity<string>("myString");
let output = identity("myString");
```



除了接口、类、类型别名和函数之外，其他地方（如命名空间，枚举）并不支持使用泛型。



## 泛型函数

```ts
function identity<Type>(arg: Type): Type {
  return arg;
}
 
let myIdentity: <Type>(arg: Type) => Type = identity;

// 接口局部有效
interface GenericIdentityFn {
  <Type>(arg: Type): Type;
}

// 接口全局有效
interface GenericIdentityFn<Type> {
  (arg: Type): Type;
}
```



## 泛型约束

在没有实际传值之前 泛型参数会被视为any进行操作

但有时候我们希望其可以被约束为更为具体的类型

```ts
interface Lengthwise {
  length: number;
}
 
// 在进行泛型约束时，还可以设置对应的泛型默认值
function loggingIdentity<Type extends Lengthwise = { length: 10 }>(arg: Type): Type {
  console.log(arg.length); // 现在我们知道它具有.length属性，所以不会再出错
  return arg;
}
```

```ts
function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
  return obj[key];
}
 
let x = { a: 1, b: 2, c: 3, d: 4 };
 
getProperty(x, "a");
```

当一个泛型参数存在默认值时，将自带如下规则

1. 如果类型参数具有默认值，则视为可选的
2. 可选值必须在必传值后边
3. 如果存在类型约束，默认值也必须符合类型约束
4. 如果有默认类型，且实际调用的时候没有传递具体类型或无法推断出具体类型，将默认使用默认类型
5. 可以为已经存在的接口或类扩展带有默认值的字段或为现有字段添加默认值


