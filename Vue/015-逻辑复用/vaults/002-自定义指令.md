除了使用Vue内置的一系列指令之外，Vue 还允许你注册自定义的指令 (Custom Directives)

在 Vue 中，有三种重用代码的方式：[组件](https://cn.vuejs.org/guide/essentials/component-basics.html) 和 [组合式函数](https://cn.vuejs.org/guide/reusability/composables.html) 以及 [自定义指令](https://cn.vuejs.org/guide/reusability/custom-directives.html#introduction)

组件是主要的构建模块，而组合式函数则侧重于有状态的逻辑, 自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑



一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数

```html
<script setup>
// 在模板中启用 v-focus
const vFocus = {
  mounted: (el) => el.focus()
}
</script>

<template>
  <input v-focus />
</template>
```



在 `<script setup>` 中，任何以 `v` 开头的驼峰式命名的变量都可以被用作一个自定义指令。

在没有使用 `<script setup>` 的情况下，自定义指令需要通过 `directives` 选项注册

```ts
export default {
  setup() {
    /*...*/
  },
  directives: {
    // 在模板中启用 v-focus
    focus: {
      /* ... */
    }
  }
}
```

将一个自定义指令全局注册到应用层级也是一种常见的做法

```ts
const app = createApp({})

// 使 v-focus 在所有组件中都可用
app.directive('focus', {
  /* ... */
})
```



只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。其他情况下应该尽可能地使用 `v-bind` 这样的内置指令来声明式地使用模板，这样更高效，也对服务端渲染更友好。



## 指令钩子

一个指令的定义对象可以提供几种钩子函数 (都是可选的)：

```js
const myDirective = {
  // 在绑定元素的 attribute 前
  // 或事件监听器应用前调用
  created(el, binding, vnode, prevVnode) {
    // 下面会介绍各个参数的细节
  },
  // 在元素被插入到 DOM 前调用
  beforeMount(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都挂载完成后调用
  mounted(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件更新前调用
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都更新后调用
  updated(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载后调用
  unmounted(el, binding, vnode, prevVnode) {}
}
```

### 钩子参数

指令的钩子会传递以下几种参数：

- `el`：指令绑定到的元素。这可以用于直接操作 DOM。
- `binding`：一个对象，包含以下属性。
  - `value`：传递给指令的值。例如在 `v-my-directive="1 + 1"` 中，值是 `2`。
  - `oldValue`：之前的值，仅在 `beforeUpdate` 和 `updated` 中可用。无论值是否更改，它都可用。
  - `arg`：传递给指令的参数 (如果有的话)。例如在 `v-my-directive:foo` 中，参数是 `"foo"`。
  - `modifiers`：一个包含修饰符的对象 (如果有的话)。例如在 `v-my-directive.foo.bar` 中，修饰符对象是 `{ foo: true, bar: true }`。
  - `instance`：使用该指令的组件实例。
  - `dir`：指令的定义对象 --- 当前指令对象自身
- `vnode`：代表绑定元素的底层 VNode。
- `prevNode`：代表之前的渲染中指令所绑定元素的 VNode。仅在 `beforeUpdate` 和 `updated` 钩子中可用。



指令的参数和值可以是任何合法的JavaScript表达式，这些表达式会在求出最终结果后，再被挂载到binding的对应属性上



举例来说，像下面这样使用指令：

```html
<div v-example:foo.bar="baz">
```

`binding` 参数会是一个这样的对象：

```js
{
  arg: 'foo',
  modifiers: { bar: true },
  value: /* `baz` 的值 */,
  oldValue: /* 上一次更新时 `baz` 的值 */
}
```



除了 `el` 外，其他参数都是只读的，不要更改它们。若你需要在不同的钩子间共享信息，推荐通过元素的 [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset) attribute 实现

在 Vue3 指令中，binding 对象包含了与指令相关的信息，例如指令的值、参数、修饰符等。除了 `el` 属性以外，binding 对象的其他属性都是只读的，不能被更改。也就是说，如果你尝试在指令的钩子函数里修改 `binding.value` 或者 `binding.arg` 等属性，那么这些更改是不会生效的

而 `el` 属性是一个可读写的属性，因为它表示了指令所绑定的元素。你可以在指令的钩子函数中读取 `el` 属性来获取元素的信息，也可以将某些数据绑定在 `el` 的 dataset 属性上，以便在不同的钩子函数中共享这些数据。

所以你可以使用 `el` 的 dataset 属性来共享数据，而不是直接修改 `binding` 对象的其他属性。

```html
<template>
  <div ref="myElement" data-custom-info="hello"></div>
</template>
```

```js
export default {
  mounted() {
    console.log(this.$refs.myElement.dataset.customInfo) // 输出 "hello"
    this.$refs.myElement.dataset.customInfo = "world" // 修改自定义数据
  },
  updated() {
    console.log(this.$refs.myElement.dataset.customInfo) // 输出 "world"
  }
}
```



## 简化形式

对于自定义指令来说，一个很常见的情况是仅仅需要在 `mounted` 和 `updated` 上实现相同的行为，除此之外并不需要其他钩子

这种情况下我们可以直接用一个函数来定义指令

```html
<div v-color="color"></div>
```

```js
app.directive('color', (el, binding) => {
  // 这会在 `mounted` 和 `updated` 时都调用
  el.style.color = binding.value
})
```



## 在组件上使用

当在组件上使用自定义指令时，它会始终应用于组件的根节点

需要注意的是组件可能含有多个根节点。当应用到一个多根组件时，指令将会被忽略且抛出一个警告

但是和穿透属性不同的是，指令不能通过 `v-bind="$attrs"` 来传递给一个不同的元素

总的来说，**不**推荐在组件上使用自定义指令

