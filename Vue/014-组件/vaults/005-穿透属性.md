“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 [props](https://cn.vuejs.org/guide/components/props.html) 或 [emits](https://cn.vuejs.org/guide/components/events.html#defining-custom-events) 的 attribute 或者 `v-on` 事件监听器。最常见的例子就是 `class`、`style` 和 `id`

当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上

同样的规则也适用于 `v-on` 事件监听器：

```html
<MyButton class="large" />

<!-- <MyButton> 的模板 -->
<button>click me</button>

<!-- 最终渲染结果 -->
<button class="large">click me</button>
```

如果一个子组件的根元素已经有了 `class` 或 `style` attribute，它会和从父组件上继承的值合并

```html
<!-- <MyButton> 的模板 -->
<button class="btn">click me</button>

<!-- 最终渲染结果 -->
<button class="btn large">click me</button>
```

穿透属性会一层层向子组件传递，只有在中间某个组件上声明过的 `props`或使用`emits` 声明的事件才会从穿透属性中被移除

换句话说，声明过的 props 和侦听函数被 中间声明的组件给“消费”了。



如果你**不想要**一个组件自动地继承 attribute，你可以在组件选项中设置 `inheritAttrs: false`。

从 3.3 开始你也可以直接在 `<script setup>` 中使用 [`defineOptions`](https://cn.vuejs.org/api/sfc-script-setup.html#defineoptions)：

```ts
// 可以通过 defineOptions 宏在 <script setup> 中使用选项式 API
// 也就是说可以在一个宏函数中设置 name, props, emits等
defineOptions({
  inheritAttrs: false
})

// ...setup 逻辑
```

最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上

通过设置 `inheritAttrs` 选项为 `false`，你可以完全控制透传进来的 attribute 被如何使用

这些透传进来的 attribute 可以在模板的表达式中直接用 `$attrs` 访问到

这个 `$attrs` 对象包含了除组件所声明的 `props` 和 `emits` 之外的所有其他 attribute

- 和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写

  所以像 `foo-bar` 这样的一个 attribute 需要通过 `$attrs['foo-bar']` 来访问。

- 像 `@click` 这样的一个 `v-on` 事件监听器将在此对象下被暴露为一个函数 `$attrs.onClick`

```html
<div class="btn-wrapper">
  <!-- 
		$attrs 中的所有属性和方法都会被应用到 button.btn 上
	-->
  <button class="btn" v-bind="$attrs">click me</button>
</div>
```



## 多根节点的 Attributes 继承

和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为

因为Vue 不知道要将 attribute 透传到哪里

如果 `$attrs` 没有被显式绑定，将会抛出一个运行时警告



## 在 JavaScript 中访问透传 Attributes

可以在 `<script setup>` 中使用 `useAttrs()` API 来访问一个组件的所有透传 attribute

```ts
import { useAttrs } from 'vue'

const attrs = useAttrs()
```

如果没有使用 `<script setup>`，`attrs` 会作为 `setup()` 上下文对象的一个属性暴露

```ts
export default {
  setup(props, ctx) {
    // 透传 attribute 被暴露为 ctx.attrs
    console.log(ctx.attrs)
  }
}
```

因为传统属性 在整个项目声明周期过程中基本不会发生任何的改变

因此出于性能原因，`useAttrs()`的返回值并不是响应式的

如果需要监听他的改变，可以在`onUpdated()`中进行调用，使得在每次更新时都很获取到最新的`attrs`并执行对应副作用

或者将`useAttrs()`作为props传递给子组件，这样当组件修改时，会重新计算`useAttrs()`以获取最新`attrs`