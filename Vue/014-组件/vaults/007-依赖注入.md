通常情况下，当我们需要从父组件向子组件传递数据时，会使用 [props](https://cn.vuejs.org/guide/components/props.html)

但是有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据

在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去，这会非常麻烦：

![Prop 逐级透传的过程图示](https://cn.vuejs.org/assets/prop-drilling.11201220.png)

虽然这里的 `<Footer>` 组件可能根本不关心这些 props，但为了使 `<DeepChild>` 能访问到它们，仍然需要定义并向下传递

如果组件链路非常长，可能会影响到更多这条路上的组件。这一问题被称为“prop 逐级透传”



`provide` 和 `inject` 可以帮助我们解决这一问题

个父组件相对于其所有的后代组件，会作为**依赖提供者**。

任何后代的组件树，无论层级有多深，都可以**注入**由父组件提供给整条链路的依赖

![Provide/inject 模式](https://cn.vuejs.org/assets/provide-inject.3e0505e4.png) 

## Provide (提供)

要为组件后代提供数据，需要使用到 [`provide()`](https://cn.vuejs.org/api/composition-api-dependency-injection.html#provide) 函数：

```ts
import { provide } from 'vue'

provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
```

如果不使用 `<script setup>`，请确保 `provide()` 是在 `setup()` 同步调用的：

```ts
import { provide } from 'vue'

export default {
  setup() {
    provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
  }
}
```

可以注入响应式状态来确保后代组件在获取对应注入内容时，对应的值是响应式的

```ts
import { ref, provide } from 'vue'

const count = ref(0)
provide('key', count)
```



## 应用层 Provide

除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖：

```ts
import { createApp } from 'vue'

const app = createApp({})

app.provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
```

在应用级别提供的数据在该应用内的所有组件中都可以注入。

这在你编写[插件](https://cn.vuejs.org/guide/reusability/plugins.html)时会特别有用，因为插件一般都不会使用组件形式来提供值。



## Inject (注入)

要注入上层组件提供的数据，需使用 [`inject()`](https://cn.vuejs.org/api/composition-api-dependency-injection.html#inject) 函数

如果提供的值是一个 ref，注入进来的会是该 ref 对象，而**不会**自动解包为其内部的值。

这使得注入方组件能够通过 ref 对象保持了和供给方的响应性链接。

```ts
import { inject } from 'vue'

const message = inject('message', '这是默认值')
```

同样的，如果没有使用 `<script setup>`，`inject()` 需要在 `setup()` 内同步调用



如果默认值是通过调用函数或者初始化类来获取的，需要使用工厂函数进行包裹，并通过第三个参数告知Vue第二个是工厂函数，其返回值才是默认值

```ts
const value = inject('key', () => new ExpensiveClass(), true)
```



## 和响应式数据配合使用

提供 / 注入响应式的数据时，**建议尽可能将任何对响应式状态的变更都保持在供给方组件中**

这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护

```ts
<!-- 在供给方组件内 -->

import { provide, ref } from 'vue'

const location = ref('North Pole')

function updateLocation() {
  location.value = 'South Pole'
}

provide('location', {
  location,
  updateLocation
})
```

```html
<!-- 在注入方组件 -->
<script setup>
import { inject } from 'vue'

const { location, updateLocation } = inject('location')
</script>

<template>
  <button @click="updateLocation">{{ location }}</button>
</template>
```



如果你想确保提供的数据不能被注入方的组件更改，你可以使用 [`readonly()`](https://cn.vuejs.org/api/reactivity-core.html#readonly) 来包装提供的值

```ts
import { ref, provide, readonly } from 'vue'

const count = ref(0)
provide('read-only-count', readonly(count))
```



## 类型标注

provide 和 inject 通常会在不同的组件中运行。要正确地为注入的值标记类型，Vue 提供了一个 `InjectionKey` 接口，

它是一个继承自 `Symbol` 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型：

```ts
import { provide, inject } from 'vue'
import type { InjectionKey } from 'vue'

const key = Symbol() as InjectionKey<string>

// InjectionKey<string> 表示注入的值必须是 字符串
provide(key, 'foo') // 若提供的是非字符串值会导致错误

const foo = inject(key) // foo 的类型：string | undefined
```

建议将注入 key 的类型放在一个单独的文件中，这样它就可以被多个组件导入

并且使用Symbol( )来命名key，这样可以最大程度的避免命名冲突



当使用字符串注入 key 时，注入值的类型是 `unknown`，需要通过泛型参数显式声明

```ts
const foo = inject<string>('foo') // 类型：string | undefined
```

注意注入的值仍然可以是 `undefined`，因为无法保证提供者一定会在运行时 provide 这个值。

但是当提供了一个默认值后，这个 `undefined` 类型就可以被移除

```ts
const foo = inject<string>('foo', 'bar') // 类型：string
```

如果你确定该值将始终被提供，则还可以强制转换该值

```ts
const foo = inject('foo') as string
```







-----

----

在应用级别提供的数据在该应用内的所有组件中都可以注入。

这在你编写[插件](https://cn.vuejs.org/guide/reusability/plugins.html)时会特别有用，因为插件一般都不会使用组件形式来提供值。



如果默认值是通过调用函数或者初始化类来获取的，需要使用工厂函数进行包裹 -- -为什么