组件化开发的优势

- 利于团队协作开发 「 减少代码冲突 」
- 利于组件复用
- 利于SPA单页面应用开发 「 一个组件就是一个路由 」
- ……



React中组件分类

1. 函数组件 => Hook组件
2. 类组件



React组件本质是一种特殊JavaScript语法，所以后缀可以是`js`或`jsx`

在项目目录中

+ 视图组件一般位于 `src/views` 或 `src/pages` 目录下
+ 项目复用组件 一般位于 `src/components`目录下



无论Vue 还是 React，组件一般首字母大写 => 使用PascalCase命名规则



## 函数组件

1. 接收props的函数
2. 该函数返回了JSX对象

```jsx
export default function App(props) {
  // 使用小括号将返回的JSX进行包裹 => 便于换行处理
  return (
    <>
      this is a functional component
    </>
  )
}
```

调用方式

```html
<App /> <!--  单闭合调用 => 必须严格闭合  -->

<App></App>  <!-- 双闭合调用 -->

<!-- 组件上传递的属性被称之为props  -->
<User name="Klaus" age={23} />

<!-- 双闭合调用 子节点会作为props.children 属性进行传递 -->
<Child>Hello World</Child>

<!-- 
	将多个props组合成对象，可以一次性传入多个props
	props的名称是属性名，props的值是属性值
-->
<Child {...props} />

<Child danger /> <!-- 等价于 <Child danger={true} /> -->
```



函数组件被解析后生成`React.createElement(函数名, {...})` => 解析后`vnode.type`的值就是函数本身

此时react就会去执行函数，并获取返回的JSX进行渲染 「 例如 `<App />` => `App(props)` 」



## 静态组件

函数组件是静态组件，除非父组件传入的props改变，否则函数组件基本不会重新渲染

 因为每次调用函数都是生成一个独立的函数作用域，无法保存之前的状态



当一个组件修改自身状态后，可以让组件界面更新，这种组件就是动态组件

+ 类组件
+ hook组件



## 原生类使用

```jsx
class Parent {
  // 类成员变量写法 「 依旧挂载实例上 」
  num = 0;
  // 私有属性必须先通过类成员表达式进行声明后才能使用
  #msg = 'running' // #开头的属性是私有属性 「 只能在当前类中使用 」
  
  static call() {} // 静态方法「 类方法 」=> 不可枚举
  static calssName = 'className' // 静态属性 「 类属性 」=> 可枚举

  // new的时候，会自动调用构造函数
  constructor(x, y) {
    // this->创建的实例
    this.num = x + y;
  }

  // 方法会自动挂载原型上 => 不可枚举
  run() {
    console.log(this.#msg)
  }

  study = () => { // 会被挂载到实例上
    // class后边的大括号会生成块级作用域 「 箭头函数study内this，会找到组件实例 」
    // 可以理解为成员表达式写法 解析时会移动到构造函数中执行
    console.log(this)
  } 
}

// 如果要往类原型上加属性 => 只能在类外部添加
Parent.prototype.msg = 'prototype message'
```

```jsx
// extends关键字实现继承
class Child extends Parent {
  constructor(childName) {
    // 在子类构造方法中使用this之前必须通过super方法调用父类构造方法
    // 以确保JS可以转换为借用构造函数继承 和 借用原型链继承
    super() // 调用父类构造函数
    this.childName = childName
  }

  childRunning() {
    super.running() // 调用父类实例方法
  }

  static childStudying() {
    super.studying() // 调用父类静态方法
  }
}
```



默认情况下，不使用构造函数，构造函数可以省略，存在如下默认构造函数

```js
// 没有继承时
constructor() { }

// 存在继承时
constructor(...props) { super(...props) }
```

