1. 状态是一种特殊数据
2. 状态改变会导致界面重新渲染
3. 通过`state`挂载属性 => `state`的默认值是`null`

```js
class Parent {
  constructor(props) {
    super(props)

    this.state = {
      // 定义状态
    }
  }
}
```

可以简写为

```js
class Parent {
  state = {
    // 定义状态
  }
}
```



### 数据

满足以下任意一个条件就可以被认为是状态

1. 只参与逻辑，不参与界面渲染
2. 参与界面渲染，但是后期数据不会再发生改变

```js
class Parent {
  // 定义数据
  columns = {}
  
  state = {
    // 定义状态
  }
}
```

或者

```js
// 定义数据
const columns = {}

class Parent {  
  state = {
    // 定义状态
  }
}
```



### setState

React不存在响应式

1. 直接修改状态，界面不会更新 「 `this.state.xxx = yyy`是错误的 」
   + react没有向vue那样对状态进行数据劫持
   + 以在修改状态时，触发setter，并在setter中通知视图更新
2. 需要通过`this.state(partialState)`来修改状态
   + `setState`  会做两件事 => 更新状态 + 更新视图
   + 内部会执行`Object.assign(state, partialState)` => 支持部分更新

```jsx
export default class Child extends Component {
  state = {
    count: 0
  }

  render() {
    const { count } = this.state

    return (
      <>
        <div>{ count }</div>
        {/*
          onClick
          1. 需要是小驼峰写法 => 因为是react中的合成事件
          2. 绑定的值 需要是一个函数 => 不支持像vue那样直接绑定函数调用
        */}
        <button onClick={ () => this.setState({ count: count + 1 }) }>add</button>
      </>
    )
  }
}
```



### forceUpdate

`forceUpdate`会跳过`SCU`, 直接执行`render` 

1. 全量生成`VDOM` 并进行 `DOM-DIFF`
2. 根据`DOM-DIFF`后是否存在`PATCH`来决定是否需要更新

```jsx
export default class Child extends Component {
  state = {
    count: 0
  }

  /*
    自定义事件处理函数
    => 自定义事件调用方式类似于 updateCount() => 不是通过组件实例.updateCount()调用
    => 类和模块解析会自动开启严格模式 => 自定义事件中this等于undefined
  */
  updateCount() {
    this.state.count++
    
    // 强制更新视图
    this.forceUpdate(() => {
      // forceUpdate可以传入回调，回调会在componentDidUpdate执行完毕后被回调
      console.log('forceUpdate') 
    })
  }

  render() {
    const { count } = this.state

    return (
      <>
        <div>{ count }</div>
        {/*
          自定义方法 => 需要修正this
        */}
        <button onClick={ () => this.updateCount() }>add</button>
      </>
    )
  }
}
```


