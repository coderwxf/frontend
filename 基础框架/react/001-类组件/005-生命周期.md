## 生命周期

1. 预设的一系列回调函数
2. 这些函数会在组件执行的某些关键时刻被React回调
3. 从而实现一些自定义的业务逻辑 => 也就是执行组件渲染和更新之外的一系列副作用操作



![image.png](https://s2.loli.net/2024/09/26/lyDPkECnM31wB9L.png) 



### 老版本 「 React16之前 」

![image.png](https://s2.loli.net/2024/09/24/bkeFHJAfCavu5zD.png) 



### 新版本 「 React16 及 以后  」

![image.png](https://s2.loli.net/2024/09/24/pKU7w1jfJNlkuCg.png)



1. 生命周期构子都是和render同层级的函数

2. ==render是渲染函数 => 组件生命周期过程中的重要函数 => 严格意义上render不是生命周期钩子==

3. 除了`componentWillUnmount`之外所有名称中带`will`的生命周期钩子都是不安全的 => 使用推荐加上`UNSAFE_`前缀

```jsx
UNSAFE_componentWillMount() {
  // componentWillMount => 已过时 => 控制台会报警告 
  // 『 React严格模式和非React严格模式都是黄色警告 』

  // UNSAFE_componentWillMount => 推荐写法
  // 1. 非React严格模式 => 不出现警告
  // 2. React严格模式 => 控制台抛出红色警告 => 本质是检测了 UNSAFE_ 前缀

  // componentWillMount 和 UNSAFE_componentWillMount 适用于所有过时生命周期钩子
}
```



```jsx
UNSAFE_componentWillUpate(nextProps, nextState) {
  // UNSAFE_componentWillUpate 执行时 组件也没有更新
  // 参数依旧是 更新前的 props 和 state
}
```



```jsx
render(props) {
	// 执行render方法时
  // 	1. 如果是第一次渲染 => 执行render前，会初始化props和state, context
  // 	2. 如果不是第一次渲染 => 执行render前，会更新props和state, context
  // 所以在render中永远都能拿到最新的props和state
}
```



```jsx
// 参数是更新之前的props和state
componentDidUpdate(prevProps, prevState) { }
```



###  SCU

![image.png](https://s2.loli.net/2024/09/25/dwpQ6UtlK4G3cfX.png) 

1. shouldComponentUpdate => 简称SCU => 会在组件更新之前被回调 => 用于决定组件是否需要更新
2. 如果不重写 `shouldComponentUpdate`，组件会默认返回 `true`，这意味着每次状态或属性更新时，组件都会重新渲染
3. shouldComponentUpdate的返回值是布尔类型值
   + `true`：组件生成虚拟 DOM（VDOM），并进行 DOM-DIFF 操作，然后执行组件更新。
   + `false`：组件不会重新渲染，也不会生成新的 VDOM，这可以提高性能，减少不必要的渲染。

```jsx
// 执行时，组件还没有更新 
// => 实例上是更新前状态和props，参数是更新后状态和props
shouldComponentUpdate(nextProps, nextState) {

  // 函数默认返回undefined，但还是推荐显示返回明确的布尔类型值
  return ture
}
```

React的默认行为是当父组件重新渲染时，其所有子组件也会重新渲染。

当子组件的props和state没有改变时，子组件是不需要重新更新的，但React只有通过DOM-DIFF后才能知道

手动实现SCU可以显示告诉React，组件是否需要更新

如果SCU返回了false，组件更新将被直接跳过 => 不会生成新的VDOM, 也不会进行DOM-DFF 

所以SCU的主要目的是提升渲染性能，减少不必要的渲染。



## 组件更新

React组件更新使用的深度优先原则

+ 在执行`render`和`componentWillUnmount`中 如果遇到了子组件
+ 先解析子组件，并触发对应生命周期钩子
+ 子组件解析完毕，再继续执行父组件中剩余执行流程



有两种方式可以触发组件更新

1. 自更新 => 修改自身state引发的更新
2. props更新



==如果是props更新，在执行`SCU`前，会先执行一个不安全的生命周期钩子`componentWillReceiveProps`==

`componentWillReceiveProps`的主要作用是

1. 根据props的改变，更新state 
2. 触发一些副作用 

推荐使用 `getDerivedStateFromProps` 或 `componentDidUpdate` 来替代

```js
UNSAFE_componentWillReceiveProps(nextProps) {
  if (this.props.name !== nextProps.name) {
    this.setState({ nameUpdate: true })
  } 
}
```



函数组件是“静态组件”：

- 函数组件无法实现自更新
- 函数组件的父组件更新，一定会触发函数组件的重新更新 「 函数组件自己再去执行SCU判断是否需要继续更新 」



类组件是"动态组件":

+ 类组件即能实现自更新 也能实现 props更新



hook组件 => 在函数组件中使用hooks函数

+ 类组件功能强大，函数组件功能弱但执行效率高，没有类那么臃肿
+ hook组件结合了类组件和函数组件的优势 => 函数组件动态化



## PureComponent

`PureComponent`相对于`Component`最大的特点是

+ `PureComponent`实现了默认的`SCU` => 自己实现`SCU`会在console抛出警告
+ `Component`没有实现默认的`SCU`

```js
// 判断参数是否是对象
function isObject(obj) {
  return obj !== null && ['function', 'object'].includes(typeof obj)
}

// 浅层比较 => 只比较对象的第一层级属性，不再进行深层级属性比较
function shallowEqual(obj1, obj2) {
  // 1. 基本数据类型 直接判等
  if (!isObject(obj1) && !isObject(obj2)) {
    return obj1 === obj2
  }

  // 2. obj1 和 obj2 一个是基本数据类型，一个是引用数据类型 => 直接不等
  if(!isObject(obj1) || !isObject(obj2)) {
    return false
  }

  // 3. obj1 和 obj2 都是同一个地址引用  => 就是同一个对象 => 直接返回true
  if (obj1 === obj2) {
    return true
  }

  // 4. obj1 和 obj2的属性个数不一致 => 直接不等
  // Reflect.ownKeys <=> Object.keys => 没有Reflect.ownValues和Reflect.ownEntries
  if (Reflect.ownKeys(obj1).length !== Reflect.ownKeys(obj2).length) {
    return false
  }

  // 5. 依次迭代obj1中的每一个key => 去obj2中查找对应属性值 => 判断obj1和obj2中对应属性值是否相等
  for (const key of Reflect.ownKeys(obj1)) {
    // Reflect.has(obj, key) <=> key in obj => 自身和原型链
    // Object.hasOwn(obj, key) <=> obj.hasOwnProperty(key) => 只包含自身
    
    // 迭代obj1的key => obj1[key] 一定存在
    
    // !Object.hasOwn(obj2, key) => 确保obj2自身存在属性key 
    // => obj2[key]只能知道obj2自身或其原型上存在属性key,
    // => 但无法知道key位于obj2自身，还是位于obj2的原型对象上
    
    // Object.is(obj1[key], obj2[key]) => 两个属性值是相等的
    // 不使用obj1[key] !== obj2[key] => 属性值都是NaN 应该视为相等，而不是不等
    
    // Object.is 底层也是使用严格判等「 === 」
    // 区别是 Object.is(NaN, NaN) => true 然而 NaN === NaN => false
    if (!Object.hasOwn(obj2, key) || !Object.is(obj1[key], obj2[key])) {
      return false
    }
  }

  return true
}
```

```jsx
shouldComponentUpdate(nextProps, nextState) {
  // PureComponent默认将新旧props和新旧state进行浅层比较
  // 只要两者的引用地址都没有发生改变，则当前组件将不再进行更新
	return !shallowEual(nextProps, this.props) || !shallowEual(nextState, this.state)
}
```



所以如果状态是数组，需要插入值时，不要使用`push`方法，而是使用展开运算符

```jsx
this.state.arr.push(20)
this.setState({ arr }) // => 新旧state引用地址不会改变 => 不会触发更新

this.setState({
	arr: [...this.state.arr, 20] // => 实际是浅拷贝 => 改变了state对应的引用地址 => 触发更新 => 数据的不可变性
})
```

数据的不可变性是指不直接修改数据对象，而是创建新的对象。这样，浅比较可以有效地检测到变化，因为对象的引用地址会发生改变。



## React.StrictMode

React中的严格模式，用于检测一些React中一些不规范的操作 

「 如调用过时的{ 例如 `componentWillMount` }或者不推荐使用的API { 例如`findDomNode` }」



注意: 这和JavaScript中的严格模式是完全不同的两种东西

某些第三方库的开发时间较早，内部可能会使用一些不推荐或过时的API 「 如Ant-Design 」 

=> 所以在实际开发中一般不会开启React的严格模式

