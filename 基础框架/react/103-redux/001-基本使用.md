Redux 全局状态管理工具 => 并不局限于必须在react中使用

在react中，一般结合`react-redux`简化redux的使用

Redux Toolkit (RTK) 是官方提供的工具包，可以在`react-redux`的基础上继续简化对应操作



一般情况下，Redux 相关的文件会被存放到 `src/store` 目录下。



## createStore

```js
import { createStore } from 'redux';

const store = createStore(reducer, enhancer);
export default store;
```

1. `reducer` => 纯函数，所有修改`redux`的操作都必须通过`reducer`
2. `enhancer` => 中间件「 可选 」



### reducer

`reducer`是一个纯函数，接收`store`并返回一个新`store`

```js
import { createStore } from 'redux'
import { INCREMENT, DECREMENT } from './consts'

const initalState = {
  count: 0
}

function reducer(state = initalState, action) {
  // 根据行为标识做不同的事情
  switch (action.type) {
    case INCREMENT:
      // 获取参数并执行派发事件
      return {
        ...state,
        count: state.count + action.payload.step ?? 1
      }
    case DECREMENT:
      return {
        ...state,
        count: state.count - 1
      }
    default:
      // 原封不动的返回参数，不违反纯函数原则
      return state
  }
}

const store = createStore(reducer)
export default store
```



#### 首次派发

redux内部会默认派发一次action，其中type是`@@redux/init + 随机数}`

没有任何用户自定义行为标识和默认行为标识匹配，此时执行`default`逻辑块

返回默认state，而初始state其实是undefined，也就会初始化为`initalState`



#### 后续派发

后续派发

+ 匹配到type，执行对应逻辑块
+ 没有匹配到对应type，原封不动返回state



**为什么要时纯函数**

1. 确定的输入一定有确定的输出 => 方便根据参数预测返回结果「 因为没有副作用影响 」
2. 输入参数和返回值是完全独立的两个对象 => 便于实现`redux devtool` => 记录store操作并进行版本穿梭
3. 所以redux store的操作都由redux来完成 => 和组件业务逻辑实现解耦



所以不应该直接修改store，更新store的操作应该全部交给reducer来执行

组件只需要通过`dispatch`派发任务给`reducer`即可



## store

store对象中一般存在如下方法

+ `dispatch` => 派发行为对象
+ `subscribe` => 将订阅组件加入store事件池
+ `getState` => 获取最新状态



### dispatch

本质是执行`reducer`用于更新`store`

```js
store.dispatch(<行为对象>)
```



#### 行为对象

行为对象「 action对象 」 => 一个有type属性的对象

```js
{
  type: 'INCREMENT' //  行为标识
  payload: { // 参数 => 类型任意，一般放在payload中
    step: 10 
  }
}
```



## 使用

### 全局注入

创建一个自定义context，全局注入store

虽然可以在每个组件内部自己引入store后使用，但是

```jsx
import { createContext } from "react";
export default createContext();

<ReduxContext.Provider value={store}>
  <App />
</ReduxContext.Provider>
```



### 类组件

```jsx
import { PureComponent } from 'react'
import StoreContext from './contetxt/StoreContext'

export default class ClassChild extends PureComponent {
  static contextType = StoreContext

  state = {
    dateStamp: 0
  }

  render() {
    // context, props和state是在render函数执行前不久被初始化的
  	// 所以this.context在构造函数中的值是undefined
    const store = this.context
    
    // 获取store state 并解构
    const { count } = store.getState()

    return (
      <h1>class: { count }</h1>
    )
  }
  
  componentDidMount() {
    const store = this.context

    // subscribe的callback回调会被加入redux事件池中
    // 当store发生更新后，redux会依次执行事件池中的回调函数
    store.subscribe(() => {
      this.setState({
        // 事件池回调的目的是让render方法重新执行 => 更新组件
        // 所以这里使用 this.forceUpdate() 也是一样的
        dateStamp: +new Date()
      })
    })
  }
}
```



#### 函数组件

```jsx
import { useContext, useState } from 'react'
import StoreContext from './contetxt/StoreContext'

export default function FunctionChild() {
  const store = useContext(StoreContext)
  const { count } = store.getState()
  const [_, forceUpdate] = useState(0)
  
  store.subscribe(() => {
    forceUpdate(+new Date())
  })

  return (
    <h1>
      function: { count }
    </h1>
  )
}
```

另一种使用方式

```jsx
import { useContext, useEffect, useState } from 'react'
import StoreContext from './contetxt/StoreContext'

export default function FunctionChild() {
  const store = useContext(StoreContext)
  const { count } = store.getState()

  const [num, setNum] = useState(0)

  useEffect(() => {
    // const unSubscribe = subscribe(callback)
    // unSubscribe也是一个函数，执行后，会从事件池中将callback移除
    const unSubscribe = store.subscribe(() => {
      setNum(num + 1)
    })

    // 移除上一个更新函数，避免重复订阅
    return unSubscribe
  }, [num])

  return (
    <h1>
      function: { count }
    </h1>
  )
}
```



#### 事件派发

```jsx
{/* 派发事件并传递参数 */}
<button 
  onClick={ 
    () => dispatch({ 
      type: INCREMENT, step: 10
    })
  }
>
  increment
</button>
```



## 源码实现 - 部分

```jsx
/* 实现redux的部分源码 */
export function createStore(reducer) {
  if (typeof reducer !== 'function') {
    throw new TypeError('The reducer must be a function')
  }

  // state 状态对象 => 初始值 undefined
  let state
  // 事件池数组
  let listeners = []

  function dispatch(action) {
    // 确保行为对象action 是一个纯对象
    if (Object.prototype.toString.call(obj) !== "[object Object]") {
      throw new TypeError('The action must be a plain object.')
    }

    if (!action.type) {
      throw new TypeError('The action must have a type property.')
    }

    // 状态更新逻辑交给使用者编写
    // redux所需要做的仅仅只是调用reducer并传入state和action
    // 同时将reducer的返回值替换现有state即可
    state = reducer(state, action)

    // 通知观察者
    listeners.forEach(listener => listener())

    // dispatch方法的返回值是行为对象 「 一般不用而已 」
    return action
  }

  // 派发一个不可能被reducer匹配的行为对象 => 初始化redux state
  dispatch({
    type: Symbol()
  })

  return {
    getState: () => state,
    dispatch,
    subscribe(callback) {
      if (typeof callback !== 'function') {
        throw new TypeError('The subscribe parameter must be a function.')
      }

      let index = listeners.findIndex(listener => listener === callback)

      // 如果更新回调函数已经在事件池中，就不需要重复添加 
      // 「 判断是引用地址，简称事件指针或事件引用 」
      if (index === -1) {
        listeners.push(callback)
        index = listeners.length - 1
      }

      // 返回一个从事件池中，移除方法的函数
      return () => listeners.splice(index, 1)
    }
  }
}
```

实际上`redux`内部为了实现旧版本兼容，初始派发是通过

```jsx
function randomString() {
   // toString(n) => 转换为n进制数值格式字符串
   // n的取值范围是 [2, 36] => 之所以是36，是0-9「10个数值」 + a-z「 26个字母 -> 进制中字母不区分大小写 」
  
   // str.substring(start, end) => 截取子串, start是开始索引，end是结束索引 => [start, end)
   // end不传默认值是str.length => 即截取到最后
   return Math.random().toString(36).substring(7).split('').join('.');
};

dispatch({
	type: `@@redux/INIT` + randomString()
})
```



### 普通对象

```jsx
Object.prototype.toString.call(obj) === "[object Object]" // => true
```



#### 纯对象

1. 必须是普通对象
2. 直接隐式原型必须是Object的显示原型或null 「 即是顶层对象或Object实例，不能是自定义类的实例 」

```jsx
function isPlainObject(obj) {
  // 只要是普通对象 
  // => Object.prototype.toString.call(obj)返回值都是 [object Object]
  if (Object.prototype.toString.call(obj) !== "[object Object]") {
    return false
  }

  const proto = Object.getPrototypeOf(obj)
  
  // 通过Object.create(null) 创建的 纯对象
  if (!proto) {
    return true
  }

  // new Object 或 字面量创建出的对象
  // => 对象.hasOwnProperty(属性) => 属性是否是对象自身的属性
  // => Reflect.has(属性， 对象) <=> 属性 in 对象 => 属性在对象自身或在对象的原型链上
  if (proto.hasOwnProperty('constructor') && proto.constructor === Object) {
    return true
  }
}
```









---

----



这段描述不太准确。`dispatch` 方法通常用于 Redux 中的状态管理，它的主要作用是将一个 action 发送到 store。`dispatch` 方法的返回值通常是你传入的 action 对象，或者是中间件可能返回的其他值。

如果你的应用中使用了 Redux Thunk 或其他中间件，`dispatch` 可能会返回一个不同的值（例如，一个 promise）。

所以，`dispatch` 的返回值是 action 对象或中间件处理后的结果，而不是所谓的“行为对象”。

dispatch的返回值是dispatch方法？？？？



### reducer

`reducer`被要求是一个纯函数，接收store并返回新的store对象

不能直接修改store，而是应该通过`dispatch`派发一个行为对象 (action)，让`reducer`来修改状态

+ 全局状态都交给redux管理和更新，组件只要派发任务「 通知redux执行任务即可 」
+ 纯函数，状态修改结果是确定的 => 方便实现redux devtool

```js
const initalState = {
  count: 0
}

function reducer(state = initalState, action) {
  // 根据行为标识做不同的事情
  switch (action.type) {
    case INCREMENT:
      // 获取参数并执行派发事件
      return {
        ...state,
        count: state.count + action.step ?? 1
      }
    case DECREMENT:
      return {
        ...state,
        count: state.count - 1
      }
    default:
      // 原封不动的返回参数，不违反纯函数原则
      return state
  }
}

const store = createStore(reducer)
export default store
```



#### 首次执行

`redux`内部会默认执行一次派发, 用于初始化状态

```js
dispatch({
  type: <hash值>
})
```

此时在`reducer`中没有任何行为标识与其匹配，会执行默认逻辑，也就是`default`中的逻辑

又因为初始`state`值是`undefined`，所以此时`state`会等于`initalState`



#### 后续执行

根据行为对象中的行为标识，执行不同的逻辑代码块

如果行为标识不存在，则什么都不处理，将state原封不动的返回



## 全局注入

store在多个组件中都需要使用，所以作为全局context传递给每一个组件，然后组件再通过上下文对象去获取即可

直接导入store使用也是可以的，但是通过 **Context**，实际上是在 **store** 和 **组件** 之间引入了一个“中间层”，这层结构的主要作用是降低耦合度，并提供灵活性和可扩展性。



store中有三个方法

+ `getState()`：获取当前的全局状态。
+ `subscribe()`：订阅状态变更，当状态发生变化时会执行回调。
+ `dispatch()`：派发 action，通知 Redux reducer 更新状态。

```jsx
{/* ReduxContext => 自定义的context */}
<ReduxContext.Provider value={store}>
  <App />
</ReduxContext.Provider>
```



## 使用

### 类组件

```jsx
import { PureComponent } from 'react'
import StoreContext from './contetxt/StoreContext'

export default class ClassChild extends PureComponent {
  static contextType = StoreContext

  state = {
    dateStamp: 0
  }

  render() {
    // context和state和props都是在render方法执行之前才被初始化
    // 所以在构造函数中，this.context的值是undefined
    const store = this.context
    // 获取store state 并解构
    const { count } = store.getState()

    return (
      <h1>class: { count }</h1>
    )
  }
    
  componentDidMount() {
    const store = this.context

    // subscribe的回调会被插入store state的事件池中
    // 当状态改变时，会依次执行事件池中的回调
    store.subscribe(() => {
      this.setState({
        // dateStamp不参与界面渲染 => redux状态更新后，确保组件可以更新
        // 所以这里也可以使用this.forceUpdate()
        dateStamp: +new Date()
      })
    })
  }
}
```



### 函数组件

```jsx
import { useContext, useState } from 'react'
import StoreContext from './contetxt/StoreContext'

export default function FunctionChild() {
  const store = useContext(StoreContext)
  const { count } = store.getState()
  const [_, forceUpdate] = useState(0)
  
  store.subscribe(() => {
    forceUpdate(+new Date())
  })

  return (
    <h1>
      function: { count }
    </h1>
  )
}
```

```jsx
import { useContext, useEffect, useState } from 'react'
import StoreContext from './contetxt/StoreContext'

export default function FunctionChild() {
  const store = useContext(StoreContext)
  const { count } = store.getState()

  const [num, setNum] = useState(0)

  useEffect(() => {
    // const unSubscribe = subscribe(callback)
    // subscribe是一个函数，用于将callback从redux事件池中移除掉
    const unSubscribe = store.subscribe(() => {
      setNum(num + 1)
    })

    // 避免订阅事件的重复添加
    return () => unSubscribe()
  }, [num])

  return (
    <h1>
      function: { count }
    </h1>
  )
}
```



### 派发事件

```jsx
{/* 派发事件并传递参数 => dispatch 从store对象中解构得到 */}
<button 
  onClick={ () => dispatch({ type: INCREMENT, step: 10})}
>
increment
</button>
```



## 源码实现 - 伪代码

```js
/* 实现redux的部分源码 */
export function createStore(reducer) {
  if (typeof reducer !== 'function') {
    throw new TypeError('The reducer must be a function')
  }

  // state 状态对象 => 初始值 undefined
  let state
  // 事件池数组
  let listeners = []

  function dispatch(action) {
    // 确保行为对象action 是一个纯对象
    if (Object.prototype.toString.call(obj) !== "[object Object]") {
      throw new TypeError('The action must be a plain object.')
    }

    if (!action.type) {
      throw new TypeError('The action must have a type property.')
    }

    // 状态更新逻辑交给使用者编写
    // redux所需要做的仅仅只是调用reducer并传入state和action
    // 同时将reducer的返回值替换现有state即可
    state = reducer(state, action)

    // 通知观察者
    listeners.forEach(listener => listener())

    // dispatch方法的返回值是行为对象 「 一般不用而已 」
    return action
  }

  // 派发一个不可能被reducer匹配的行为对象 => 初始化redux state
  dispatch({
    type: Symbol()
  })

  return {
    getState: () => state,
    dispatch,
    subscribe(callback) {
      if (typeof callback !== 'function') {
        throw new TypeError('The subscribe parameter must be a function.')
      }

      let index = listeners.findIndex(listener => listener === callback)

      // 如果更新回调函数已经在事件池中，就不需要重复添加 「 判断依据是更新回调函数的引用地址，简称事件指针或事件引用 」
      if (index === -1) {
        listeners.push(callback)
        index = listeners.length - 1
      }

      // 返回一个从事件池中，移除方法的函数
      return () => listeners.splice(index, 1)
    }
  }
}
```

其中，为state赋予初始值使用的是

```js
dispatch({
  type: Symbol()
})
```

但redux中，为了兼容ES6之前语法。实际并不是这么实现的

```js
function randomString() {
   // toString(n) => 转换为n进制数值格式字符串
   // n的取值范围是 [2, 36] => 之所以是36，是0-9「10个数值」 + a-z「 26个字母 -> 进制中字母不区分大小写 」
  
   // str.substring(start, end) => 截取子串, start是开始索引，end是结束索引 => [start, end)
   // end不传默认值是str.length => 即截取到最后
   return Math.random().toString(36).substring(7).split('').join('.');
};

dispatch({
	type: `@@redux/INIT` + randomString()
})
```



### 纯对象 和 原生对象

1. **原生对象**：

   ```js
   // 检测方式
   Object.prototype.toString.call(obj) === "[object Object]" 
   ```

   

2. **纯对象（Plain Object）**：

   直接由`Object`创建或通过`Object.create(null)`创建的对象

   本质上纯对象是一种特殊的原生对象

   使用`Object.prototype.toString.call(obj) === "[object Object]"`之所以无法检测纯对象

   因为即使是自定义对象，只要没有重写`toString`方法，其条件判断结果就是`true`

   ```js
   class Person {}
   const p = new Person()
   
   console.log(Object.prototype.toString.call(p) === "[object Object]" ) // => true
   ```

   所以还需要对原生对象的原型进行检测

   ```js
   function isPlainObject(obj) {
     if (Object.prototype.toString.call(obj) !== "[object Object]") {
       return false
     }
   
     const proto = Object.getPrototypeOf(obj)
     
     // 通过Object.create(null) 创建的 纯对象
     if (!proto) {
       return true
     }
   
     // new Object 或 字面量创建出的对象
     // => 对象.hasOwnProperty(属性) => 属性是否是对象自身的属性
     // => Reflect.has(属性， 对象) <=> 属性 in 对象 => 属性在对象自身或在对象的原型链上
     if (proto.hasOwnProperty('constructor') && proto.constructor === Object) {
       return true
     }
   }
   ```

   



### 观察者设计模式

观察者模式是一种行为型设计模式，允许一个对象（被观察者）维护一组依赖它的对象（观察者）。

当被观察者的状态发生变化时，它会自动通知所有订阅的观察者，让它们更新自己

=> 观察者订阅被观察者，在被观察者发生更新时，自动执行某些操作 => 一般都是基于事件



原生redux和事件总线就是观察者模式的具体实现。

它们维护者一个事件队列，观察者会将当被观察对象改变后需要执行的逻辑封装为方法存入事件队列中，

当被观察对象发生更新时，会依次执行事件队列中的各个回调

```js
function subscribe(callback) {
  // 将回调函数添加到监听器列表
  listeners.push(callback);
}

// 通知所有监听器
listeners.forEach(listener => listener());
```



`InteractionObserver`是另一种观察者模式的实现，当观察者需要订阅被观察者时，会将观察者存入观察者列表

被观察者自身维护者一个事件，当被被观察者发生更新时，会执行被观察者自身维护的事件，并将观察者列表作为参数传入

```js
const callback = (entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Element is in view:', entry.target);
    } else {
      console.log('Element is out of view:', entry.target);
    }
  });
};
```



 观察者设计模式 vs 发布-订阅模式