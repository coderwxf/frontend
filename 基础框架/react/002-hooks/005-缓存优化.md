## useMemo

实现类似于计算属性的功能

```shell
let state = useMemo(callback, 依赖数组)
```

1. 首次渲染 => 执行callback => 将callback的返回值赋值给state，并缓存结果
2. 后续更新 => 只有依赖数组中某个状态发生改变, 才会重新执行callback，并将新的返回值赋值给state并更新缓存

```jsx
import { useMemo, useState } from "react"

export default function Child(props) {
  const [x, setX] = useState(0)
  const [y, setY] = useState(0)
  const [z, setZ] = useState(0)

  const sum = useMemo(() => {
    console.log('memo')
    return x + y
  }, [x, y])

  return (
    <>
      <div>{x} + {y} = {sum}</div>
      <div>z: {z}</div>

      <div>
        <button onClick={() => setX(x + 1)}>add X</button>
        <button onClick={() => setY(y + 1)}>add Y</button>
        <button onClick={() => setZ(z + 1)}>add Z</button>
      </div>
    </>
  )
}
```



## useCallback

缓存方法类型props

每次函数组件执行都会生成全新函数执行上下文，产生新的闭包

对于非状态更新函数，没必要每次都新建一个，此时就可以使用`useCallback`



```shell
useCallback(callback, [dependencies])
```

`useCallback`使用方式类似于`useMemo`

如果不传递依赖数组，即使函数使用`useCallback`包裹，每次组件更新时都会返回新的函数 

=> useCallback将会失去作用 => 所以只要使用`useCallback`，就一定需要为其设置依赖数组

```jsx
import { useCallback, useState } from "react"

let prevFunc = null
let prevCallback = null

export default function Child(props) {
  const [count, setCount] = useState(0)

  function handle() {
    console.log('handle')
  }

  const callbackHandle = useCallback(handle, [])

  if (!prevFunc) {
    prevFunc = handle
    prevCallback = callbackHandle
  } else {
    console.log(prevFunc === handle) // => false
    console.log(prevCallback === callbackHandle) // => true
  }

  return (
    <>
      <div>{ count }</div>
      <button onClick={() => setCount(count + 1)}>click me</button>
    </>
  )
}
```



但是实际使用时，一般只会为函数类型props使用useCallback进行优化

因为对于组件内自用函数，使用`useCallback`会增加缓存逻辑判断时间，此时所实现的性能优化效果并不显著

但是当某个函数以props形式传递给子组件时，推荐将函数类型props使用`useCallback`进行包裹

以避免父组件更新后，因为每次都会生成新的函数类型props，从而导致子组件也会产生不必要的更新

```jsx
import { memo, useCallback, useState } from "react"

// memo是一个高阶组件，参数是函数组件 => 实现类似于PureComponent的效果
const Count= memo(function({ count, increment, handle }) {
  console.log('render')

  return <>
     <div>{ count }</div>
     <button onClick={increment}>click me</button>
     <button onClick={handle}>handle</button>
  </>
})

export default function Child(props) {
  const [count, setCount] = useState(0)

  // 函数类型props
  // 如果不使用useCallback => 每次都是新引用地址 => 子组件SCU返回false => 子组件需要重新渲染
  // 如果使用useCallback包裹 => 引用地址相同 => 子组件SCU返回true => 子组件不需要重新渲染

  const handle = useCallback(() => console.log('handle'), [])

  // 如果存在状态，则需要在状态改变时，更新函数 => 以获取新执行上下文中对应新的状态值
  // 否则将导致内部状态获取到的是旧状态值 「 因为访问的是旧的闭包 」
  const increment = useCallback(() =>  setCount(count + 1), [count])

  return (
    <>
      <Count count={count} increment={increment} handle={handle} />
    </>
  )
}
```

```jsx
/*
  如果forwardRef 和 memo 同时使用
    => memo(forwardRef(（props, ref) => {})) => 可以确保ref被正常传递
    => forwardRef(memo(（props, ref) => {})))
       => ref被传递给了memo，但是memo没有传递给函数组件
       => 此时会导致ref传递的丢失
*/
const Count = memo(forwardRef((props, ref) => {
  return <div ref={ref}>count</div>
}))
```

