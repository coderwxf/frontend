## 自由变量

如果一个变量，满足如下条件，就可以被认为是自由变量

1. 在当前函数作用域中被使用
2. 变量并不是在当前作用域中定义的



## 闭包

`广义闭包`

函数有能力使用自由变量，无论是否实际使用自由变量, 都构成了闭包

`狭义闭包`

在函数内部实际使用了外部的自由变量，才真正意义上构成闭包



闭包 = 当前函数 + 自由变量所处的那个词法环境 

所以闭包 又被称之为 词法闭包 或 函数闭包

任何支持函数式编程的语言 都支持 闭包



在JavaScript中，闭包是通过 作用域链实现的

所以闭包的作用也很明显:  `在函数内部 访问 函数外部的 变量和方法`

```js
function createAdder(count) {
  function adder(num) {
    // 使用了自由变量count -- 构成了狭义闭包
    return count + num
  }

  // 因为adder函数被返回，即外部有引用指向adder函数
  // 所以adder函数 和 count变量所处了词法环境无法被释放
  return adder
}

const adder8 = createAdder(8)
adder8(22)

// 如果adder8不在需要使用，需要手动置为空 -- 即闭包需要自己主动释放内存，否则会导致内存泄露
adder8 = null
```



### 浏览器优化

```js
function fun() {
  // 按规范来说, name是被引用的自由变量，所以name所处的词法环境会被保留下来
  // 也就是说name, age, address都会被应该被保留下来

  // 但是实际上，address和age并没有被保留下来 --- 因为age和name并没有被实际引用
  // 所以浏览器会对闭包进行优化 实际留下来的只有 函数本身 和 自由变量name
  let name = 'Klaus'
  let age = 24
  let address = 'shanghai'

  return function() {
    // 运行环境停止在debugger这行，控制台对应的环境就是当前函数所对应的那个词法环境
    // 所以在控制台中 可以直接输出name对应的值，但是age和address对应的值是无法输出的
    // 由此可以证明 浏览器将没有访问的自由变量进行了优化
    debugger

    console.log(name)
  }
}

fun()() // => Klaus
```

