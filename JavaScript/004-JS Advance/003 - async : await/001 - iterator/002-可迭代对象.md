每个对象上有一个特殊内置属性`@@iterator`，我们可以通过`Symbol.iterator`来获取

如果`@@iterator`被正确实现，也就是返回一个迭代自身的迭代器，那么这个对象就是可迭代对象

```js
// user正确实现了Symbol.iterator --- user就可以被认为是可迭代对象
const user = {
  friends: ['Alex', 'Klaus', 'Steven'],

  // 底层调用时通过 user[Symbol.iterator]()调用 --- Symbol.iterator中的this是user
  [Symbol.iterator]() {
    let index = 0

    return {
      // 底层调用时通过 user[Symbol.iterator]().next()调用 --- 所以默认next中的this是迭代器自身
      // 使用箭头函数，确保next内部this为user
      next: () => {
        return  {
          value: this.friends[index++],
          done: index > this.friends.length
        }
      }
    }
  }
}


// for-of在迭代过程中会自动执行对象内部的[Symbol.iterator]方法
for (const name of user) {
  console.log(name)
  /*
    =>
      Alex
      Klaus
      Steven
  */
}
```



## 内置可迭代对象

一些JS内置对象，默认实现了自己的迭代器

这些内置对象就被称之为可迭代对象，默认可以调用for-of迭代

1. string
2. array
3. map
4. set
5. nodeList
6. arguments



## 示例

原生对象默认不是线性数据结构，并不能明确具体需要迭代那部分内容

需要我们自己实现`Symbol.iterator`使原生对象转变为可迭代对象

```js
class Person {
  constructor(name, age, height) {
   this.name = name
   this.age = age
   this.height = height
  }

  // 一般Symbol.iteratordou是在类的原型上定义的，这样所有的实例都可是可迭代的
  [Symbol.iterator]() {
   const values = Object.values(this)
   let index = 0

   return {
     next() {
        
     }
   }
  }
 }

 const p1 = new Person('Klaus', 23, 1.88)

 for (const value of p1) {
   console.log(value)
 }

 /*
   =>
     Klaus
     23
     1.88
 */
```



## 应用

1. 使用如下语法时，会自动执行`Symbol.iterator`

   + for-of
   + 展开运算符
   + 解构赋值 --- 原生对象的解构赋值除外，原生对象可以解构是JS底层做了特殊处理
   + yield*

   

2. 可以在创建某些数据类型时，作为其参数

   + new Map([Iterable])
   + new WeakMap([iterable])
   + new Set([iterable])
   + new WeakSet([iterable])

   

3. 可以作为一些方法的参数

   + Promise.all(iterable)
   + Promise.race(iterable)
   + Array.from(iterable)



## 迭代器的中断

迭代器在以下情况下，会被中断

1. 遍历的过程中通过`break`、`return`、`throw`中断了循环操作
2. 解构的时候，没有解构所有的值

一旦迭代器被中断，就会触发`iterator.return`方法

```js
const user = {
  name: 'Klaus',
  age: 23,
  height: 1.88,
  [Symbol.iterator]() {
    const values = Object.values(user)
    let index = 0

    return {
      next() {
        return {
          value: values[index++],
          done: index > values.length
        }
      },

      // 重写默认的return方法 --- 默认存在一个空的return方法，这里覆盖了默认的return方法
      // return方法返回的对象 和 next方法返回的对象 一致 => { value: unknown, done: boolean }
      // 只不过return方法返回的对象 实际应用场景不多
      return() {
        console.log('迭代器被中断了')
        return { done: true }
      }
    }
  }
}

for (const value of user) { // 执行next方法
  console.log(value)
  if (value === 23) {
    return // 执行return方法
  }
}
/*
	=>
		Klaus
    23
    迭代器被中断了
*/

const user = {
  name: 'Klaus',
  age: 23,
  height: 1.88,
  [Symbol.iterator]() {
    const values = Object.values(user)
    let index = 0

    return {
      next() {
        return {
          value: values[index++],
          done: index > values.length
        }
      },

      // 重写默认的return方法 --- 默认存在一个空的return方法，这里覆盖了默认的return方法
      // return方法返回的对象 和 next方法返回的对象 一致 => { value: unknown, done: boolean }
      return() {
        console.log('迭代器被中断了')
        return { done: true }
      }
    }
  }
}

const [name, ,height] = user
console.log(name, height)
/*
  =>
    迭代器被中断了
    Klaus 1.88
*/
```

