## 什么是生成器

1. 一种特殊的函数
2. 可以自主控制函数的执行流程 --- 可以让函数暂停执行

```js
// function* 标识这是一个生成器
// function* foo 或 function *foo 或 function * foo 都可以 -- 推荐function* foo
function* foo() {
  console.log(1)
  yield console.log('a') // 通过yield关键字 暂停函数的执行
  console.log(2)
  yield console.log('b')
  console.log(3)
}

// 生成器方法被执行的时候，并不会执行函数内部的代码, 而是会返回一个生成器对象
// 生成器是特殊的迭代器
const generator = foo()

// generator被yield划分为了多个执行块
// 每次调用next方法，都会执行一个执行块，直到遇到下一个yield
generator.next()
/*
  =>
    1
    a // yield 后边的内容 属于上一个 执行块
*/

generator.next()
/*
  =>
    2
    b
*/

generator.next()
/*
  =>
    3
*/

// 如果迭代完成，next方法 静默失效
generator.next()
```



## 返回值

```js
function* foo() {
  console.log(1)
  yield 'value1' // yield xxx --- xxx会作为迭代器返回对象的value属性值
  console.log(2)
  yield 'value2'
  console.log(3)
  return 2
  // return 2 等价于
  //  1. 立即结束迭代
  //  2. 迭代器的返回值为 { done: true, value: 2 }
}


const generator = foo()

console.log(generator.next().value) // value1
console.log(generator.next().value) // value2
console.log(generator.next().value) // 2
```



## 参数传递

```ts
function* foo(res) {
  console.log(res) // 第一次传参
  const res1 = yield
  console.log(res1) // 第二次传参
  const res2 = yield
  console.log(res2) // 第三次传参

}

const generator = foo('第一次传参')

// next方法传入的参数将作为上一条yield语句的返回值
// 第一次调用next方法时传参是无效的 -- 第一个调用传参需要在调用生成器函数时，作为函数参数传入
generator.next()
generator.next('第二次传参')
generator.next('第三次传参')
```



## 中断执行

```js
function* foo(res) {
  console.log(res) // => undefined
  const res1 = yield '第一次yield返回值'
  console.log(res1) // => '第一次传参'
  return 'foo函数执行完毕了' // return -- 立即结束生成器函数的执行，并返回reutrn后的值
  console.log('这行代码不会被执行')
}

const generator = foo()

console.log(generator.next('第一次传参')) // => { value: '第一次yield返回值', done: false }
console.log(generator.next('第二次传参')) // => { value: 'foo函数执行完毕了', done: true }
console.log(generator.next('第三次传参')) // => { value: undefined, done: true }
```



## 提前结束

```js
function* foo() {
  console.log('part1')
  yield
  console.log('part2')
  yield
  console.log('part3')
}

const generator = foo('arg1')

console.log(generator.next()) // => { value: undefined, done: false }

// 调用生成器的return(x)方法
//  1. 立即结束生成器执行 --- 所以不会输出part2
//  2. 返回 { value: x, done: true }
console.log(generator.return('arg2')) // => { value: 'arg2', done: true }
console.log(generator.next('arg3')) // => { value: undefined, done: true }
```



## 抛出异常

```js
function* foo() {
  try {
    // 捕获生成器函数内部的异常
    //  1. yield 表达式 中 表达式执行异常
    //  2. 外部调用 generator.throw方法, 让yield表达式的返回值异常
    yield
    console.log('part1')
  } catch(e) {
    yield '2'
    console.log('error:' + e)
  }

  yield
  console.log('part2')
}

const generator = foo('arg1')

console.log(generator.next())
// generator.throw方法 --- 抛出一个异常给生成器函数
console.log(generator.throw(new Error('this is an error')))
console.log(generator.next('arg3'))
console.log(generator.next('arg3'))
```

```js
function* foo() {
  try {
    // 这里捕获的是yield抛出的异常
    yield
    console.log('part1')
  } catch(e) {
    yield '2'
    console.log('error:' + e)
  }

  yield
  console.log('part2')
}

const generator = foo('arg1')

// 直接调用抛出异常，第一个代码执行块报错，无法在生成器内部被捕获
console.log(generator.throw(new Error('this is an error')))
```

