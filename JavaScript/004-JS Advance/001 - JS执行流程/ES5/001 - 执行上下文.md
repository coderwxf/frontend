## 执行流程

在解析JavaScript代码时，会开辟一个栈内存空间，这个栈被称之为执行上下文栈「Execution Context Stack，简称ECS」



在代码执行前，会创建全局执行上下文「Global Execution Context(GEC) 」并压入执行上下文栈中

在遇到函数时，会创建函数执行上下文栈 「Functional Execution Context，简称FEC」并压入执行上下文栈中



函数执行完毕，函数执行上下文会执行出栈操作

整个JavaScript代码执行完毕，全局执行上下文会执行出栈操作



所以

1. 全局执行上下文 一定 是 执行上下文中位于栈底部的那个
2. 正在执行的那个活跃执行上下文 一定是位于 栈顶的 那个
3. 栈顶那个正在被JS Engine执行的那个 称之为 活跃执行上下文



## 执行上下文

执行上下文是 JS Engine 在执行JS代码时 在内存中开辟的 一种数据结构

执行上下文由三部分组成

1. 变量对象（Variable Object, VO） --- 当前作用域中可以直接获取的变量和方法
2. 作用域链（Scope Chain）--- 变量的查找链
3. this  --- 执行调用者 --- 运行时动态绑定



执行上下文是在JS Engine读取解析代码的时候被创建的, 在构建VO时会发生预解析操作「变量提升」

1. 先解析函数
   + VO对象上是否存在同名key
     + 存在 --- 静默失效
     + 不存在 --- 函数被挂载到VO上 「key -> 函数名，value -> 函数本身」
2. 再解析变量
   + VO上是否存在同名key
     + 存在 --- 静默失效
     + 不存在 --- 变量被挂载到VO上 「key -> 变量名，value -> undefined」

```js
console.log(name) // => undefined
sayHi() // => Hi

var name = 'Klaus'
function sayHi() {
  console.log('Hi')
}
```

```js
var foo = 'foo'

function foo() {
  console.log('function foo')
}

// 函数的预解析是早于变量的预解析
// 所以在本例中，foo变量最早指向的是foo函数对象, 随后又被赋值为了字符串foo
// 因此输出字符串foo
console.log(foo)  // => foo
```

