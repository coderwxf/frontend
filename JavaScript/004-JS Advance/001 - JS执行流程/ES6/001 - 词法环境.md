ES6开始，执行上下文由 词法环境 和 this 组成

也就是 `[[ scopes ]]` 和 `VO` 被整合成了一个新的数据结构 --- 即词法环境

所以 词法环境由以下两个部分组成

1. 环境记录（Environment Record） --- 即原本的VO
2. 一个可能为空的外部词法环境 （Outer Lexical Environment）--- 即原本的`[[ scopes ]]`
   + 为空 就说明是全局词法环境 --- 就像原本的GEC中 `[[ scopes ]]`只有GO 是一样的



## 变量环境

虽然ES6中使用let/const来取代var，但是为了向下兼容，ECMA依然需要确保var可以正常被使用

为此创建了一种特殊的词法环境 --- 变量环境 『 VariableEnvironment 』

`因此实际上一个执行上下文本质上会被关联两个环境`



1. 使用let/const 定义的变量 会被挂载到词法环境上 
   + 词法环境中 变量初始值是 undefined，但此时该变量是无法被使用的
   + 只有该变量被实际赋值后才可以被正常使用
   + 词法环境的这个行为 被称之为 暂时性死区

2. 使用 var/function 定义的变量 会被挂载到变量环境上
   + 变量环境 解析规则 和 ES5保持一致 -- 存在 VO 和 [[ scopes ]]
   + 变量依旧存在 变量提升 --- 可以在初始化之前进行使用

> function 被挂载到变量环境 是因为 ES6和ES5 定义函数的方式一致
>
> 为了向下兼容，只能将function声明的变量 挂载到 变量环境中



## 环境记录分类

环境记录  = 声明式环境记录 + 对象式环境记录

除了通过with函数 强制插入 作用域的 那些变量和函数 属于 对象式环境记录

正常情况下，所有的变量和函数 都属于 声明式环境记录