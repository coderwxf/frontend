```js
function Person(name) {
  this.name = name
}

Person.prototype.sayHi = () => console.log('hi')

function Student(name, age) {
  this.name = name
  this.age = age
}

// 修正Student的原型指向，使其指向Person.prototype --- 这种方式被称之为 原型链继承
// 此时Student实例查找时，会先查找Student.prototype，再查找Person.prototype
Student.prototype = new Person('Klaus')

Student.prototype.study = () => console.log('study')

const stu = new Student('Tom', 18)
stu.study() // => study
stu.sayHi() // => hi
console.log(stu.name, stu.age) // => Tom 18
```

上述代码存在问题

1. `Student.prototype`上存在 不必要的name属性
2. 共有的属性name 无法复用



解决第一个问题

```js
function Person(name) {
  this.name = name
}

Person.prototype.sayHi = () => console.log('hi')

function Student(name, age) {
  this.name = name
  this.age = age
}

// 通过Object.create()方法创建一个全新的新对象，而不是初始化Person的实例
// 重写原型对象, 需要重置constructor属性
Student.prototype = Object.create(Person.prototype, {
  constructor: {
    value: Student,
    writable: true,
    configurable: true
  }
})

Student.prototype.study = () => console.log('study')

const stu = new Student('Tom', 18)
stu.study() // => study
stu.sayHi() // => hi
console.log(stu.name, stu.age) // => Tom 18
```



解决第二个问题: 

借用构造函数继承  「 又叫call继承 」

```js
function Person(name) {
  this.name = name
}

Person.prototype.sayHi = () => console.log('hi')

Person.staticHi = () => console.log('static hi')

function Student(name, age) {
  // 通过Student实例 执行父类构造函数逻辑
  // name 实际是被挂载到了Student实例上 -- 从而实现了属性继承
  Person.call(this, name)
  this.age = age
}

Student.prototype = Object.create(Person.prototype, {
  constructor: {
    value: Student,
    writable: true,
    configurable: true
  }
})

// 实现静态方法的继承
Object.setPrototypeOf(Student, Person)

Student.staticStudy = () => console.log('static study')

Student.prototype.study = () => console.log('study')

const stu = new Student('Tom', 18)

console.log(stu.name, stu.age) // => Tom 18

stu.study() // => study
stu.sayHi() // => hi

Student.staticHi() // => static hi
Student.staticStudy() // => static study
```



借用构造函数继承 + 原型链继承 = 寄生组合式继承