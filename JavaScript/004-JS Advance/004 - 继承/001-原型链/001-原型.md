## [[prototype]]

在JavaScript中，只要值是对象，就存在属性` [[prototype]]`

1. ` [[prototype]]` 是浏览器内部实现名 --- 一般无法直接获取使用
2. ` [[prototype]]`的值是一个对象
3. ` [[prototype]]`所指向的那个对象 被称之为原型对象



## 获取 [[prototype]]

```js
const user = {}

// 方式一 -- 早期方式 -- 非标准方法
console.log(user.__proto__)

// 方式二 -- 标准方法
console.log(Object.getPrototypeOf(user))
```



## 原型分类

```js
function Person() {}

const per1 = new Person()
const per2 = new Person()

// 构造函数的显示原型
console.log(Person.prototype)

// 实例的隐式原型
console.log(per1.__proto__)

// 构造函数的显示原型 和 其实例的隐式原型 是同一个对象
console.log(per1.__proto__ === Person.prototype) // => true

// 目的: 原型是所有实例共享的，一些需要共享的属性和方法可以直接挂载到原型对象上
console.log(per1.__proto__ === per2.__proto__) // => true
```



## 构造函数

当通过new执行构造函数时，假设执行的是`const per = new Person()`

1. 新建空对象`instance ` --- 就是组件实例
2. `instance.__proto__ = Person.prototype`
3. 函数内部this = instance
4. 执行Person函数 逻辑体
5. 返回结果
   + 如果Person函数 返回了对象类型值，per的值就是Person函数返回的那个对象
   + 如果Person 没有返回对象类型值，per的值组件实例，在本例中就是instance

> 第二步和第三步没有先后之分



## constructor

```js
function Person() {}

// 原型对象上有一个不可枚举属性constructor，指向构造函数
console.log(Person.prototype.constructor === Person) // true

const per = new Person()

// 原型对象上的constructor属性执行了构造函数，所以可以用来进行类型检测
console.log(per.constructor.name === 'Person')
```

```js
function User(name) {
  this.name = name
}

// 重写原型
User.prototype = {
  running() {
    console.log('running')
  },

  eatting() {
    console.log('eatting')
  }
}

// 重写原型对象后，需要手动设置constructor属性
Object.defineProperty(User.prototype, 'constructor', {
  configurable: true,
  writable: true,
  value: User
})
```

