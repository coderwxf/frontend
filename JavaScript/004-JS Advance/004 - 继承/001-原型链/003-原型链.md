获取对象属性时，本质执行的是`[[ get ]]`操作

1. 在自身查找
2. 如果自身上不存在，去当前对象的`__proto__`查找
3. 如果依旧不存在，去当前对象的`__proto__.__proto__`查找
4. 。。。
5. 最后会查找到`Object.prototype`  --- 「 Object是所有类的父类 」
6. 如果依旧不存在 `Object.prototype.__proto__`
   + `Object.prototype.__proto__`的值是null
   + 即表示查找到尽头，如果依旧不存在，输出undefined



函数的显示原型

1. 本质依旧是一个普通对象
2. 函数显示原型的`__proto__`的值是 其父类构造函数的显示原型 --- 「 从而够成了一条都是由原型组成的链式结构 」
3. 因为Object是所有类的父类，所以这条链的顶端是 `Object.prototype`



所以

1. 函数的显示原型作用:  为实例的隐式原型进行初始化操作
2. 实例的隐式原型作用:  构建原型链，便于属性和方法的复用



函数是一种特殊的对象，所以对于函数而言，其既有显示原型，也存在隐式原型

+ 函数的显示原型 是 实例的隐式原型 -- 一个单独的JavaScript对象
+ 函数的隐式原型 是 Function.prototype -- 函数本质是通过`new Function`创建出来的