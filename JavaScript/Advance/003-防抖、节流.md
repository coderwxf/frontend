## 防抖 (debounce)

防抖函数的目的是限制某个频繁触发的函数调用频率，只有在设定的时间间隔内没有再次触发事件时，才会真正执行该函数，从而实现延迟执行。

![IM8Qtz.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fbb92c422c042bbb358a838982982ea~tplv-k3u1fbpfcp-zoom-1.image) 



### 简单实现

```js
const inputEl = document.getElementById('foo')

function debounce(fn, delay = 0) {
  if (typeof fn !== 'function') {
    throw new Error('param1 must be a function')
  }

  let timer = null

  return function(...args) {

    // 如果有新的事件被触发，就清除上一次对应的事件回调
    if (timer) clearTimeout(timer)

    timer = setTimeout(() => {
      fn.apply(this, args)
      timer = null
    }, delay)
  }
}

inputEl.addEventListener('input', debounce(e => console.log(e.target.value), 1000))
```



### 边界处理

### 取消功能

在单页应用（SPA）中，用户可能在一个页面上触发了某个事件，导致了防抖函数的计时器开始计时，但用户在计时器到期之前就导航到了另一个页面。此时，原本的回调函数在新页面中可能已经不再相关，执行它可能会导致不必要的操作或意外的副作用。

```js
function debounce(fn, delay = 0) {
  if (typeof fn !== 'function') {
    throw new Error('param1 must be a function')
  }

  let timer = null

  const _debounce = function(...args) {
    if (timer) clearTimeout(timer)

    timer = setTimeout(() => {
      fn.apply(this, args)
      timer = null
    }, delay)
  }

  // 清除防抖函数
  _debounce.cancel = () => {
    if (timer) clearTimeout(timer)
    timer = null
  }

  return _debounce
}
```



### 立即执行

在开始防抖之前，先执行一次回调函数

```js
function debounce(fn, delay = 0, immediate = false) {
  if (typeof fn !== 'function') {
    throw new Error('param1 must be a function')
  }

  let timer = null
  let isInvoke = false

  const _debounce = function(...args) {
    if (timer) clearTimeout(timer)

    if (immediate && !isInvoke) {
      fn.apply(this, args)
      isInvoke = true
    }

    timer = setTimeout(() => {
      fn.apply(this, args)

      timer = null
      isInvoke = false
    }, delay)
  }

  _debounce.cancel = () => {
    if (timer) clearTimeout(timer)

    timer = null
    isInvoke = false
  }

  return _debounce
}
```



### 获取返回值

```js
function debounce(fn, delay = 0, immediate = false) {
  if (typeof fn !== 'function') {
    throw new Error('param1 must be a function')
  }

  let timer = null
  let isInvoke = false

  const _debounce = function(...args) {
    // 因为对应的事件回调会被延迟执行，所以对应的函数就被转换为了异步函数
    // 所以为了拿到对应的结果，需要返回对应的Promise
    return new Promise((resolve, reject) => {
      try {
        if (timer) clearTimeout(timer)

        if (immediate && !isInvoke) {
          // 返回执行结果
          resolve(fn.apply(this, args))
          isInvoke = true
        }

        timer = setTimeout(() => {
          // 返回执行结果
          resolve(fn.apply(this, args))

          timer = null
          isInvoke = false
        }, delay)

      } catch (error) {
        reject(error)
      }
    })
  }

  _debounce.cancel = () => {
    if (timer) clearTimeout(timer)

    timer = null
    isInvoke = false
  }

  return _debounce
}

// Test Code
const foo = debounce(name => `my name is ${name}`, 1000)

// 防抖只能使用then来获取返回值
// 此时第一个和第二个promise 因为定时器被移除，将永远处于pending状态
// 所以只有第三个promise会被执行
foo('klaus').then(res => console.log(res))
foo('klaus').then(res => console.log(res))
foo('klaus').then(res => console.log(res))
```



## 节流 (throttle)

节流函数通过控制事件处理函数的执行频率，在单位时间内确保执行次数的固定性，以应对事件被频繁触发的情况 「 控制执行频率 」

![IM8njt.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6a4f7d2888943a0bdbe0e3cfe308126~tplv-k3u1fbpfcp-zoom-1.image) 

```js
function throttle(fn, intervalTime) {
  // 开始时间默认为0, currentTime - startTime > intervalTime结果为true
  // 一进来就可以执行一次
  let startTime = 0

  return function(...args) {
    const currentTime = Date.now()

    if (currentTime - startTime > intervalTime) {
      fn.apply(this, args)
      startTime = currentTime
    }
  }
}

const fn = throttle(() => console.log('function called'), 2000)

setInterval(fn, 100)
```



### 边界功能

### 取消首次执行

```js
function throttle(fn, intervalTime, leadInvoke = true) {
  let startTime = 0

  return function(...args) {
    const currentTime = Date.now()

    // 不需要首次执行时，将startTime初始化为currentTime
    if (!leadInvoke && !startTime) {
      startTime = currentTime
    }

    if (currentTime - startTime > intervalTime) {
      fn.apply(this, args)
      startTime = currentTime
    }
  }
}

const fn = throttle(() => console.log('function called'), 2000, false)

setInterval(fn, 100)
```



### 尾部执行

假设事件每10秒执行一次，如果间隔不到10秒，就不执行。然而，在15秒的时候手动触发了一次事件，那么接下来希望20秒时依然能够触发事件的回调，而不是因为手动触发导致时间计算中断。

```js
function throttle(fn, intervalTime, { leadInvoke = true, trailInvoke = false }) {
  let startTime = 0
  let timer = null

  function _throttle(...args) {
    return new Promise((resolve, reject) => {
      try {
        const currentTime = Date.now()

        if (!leadInvoke && !startTime) {
          startTime = currentTime
        }

        const waitTime = intervalTime - (currentTime - startTime)

        const exec = () => {
          resolve(fn.apply(this, args))
          startTime = currentTime

          if (timer) {
            clearTimeout(timer)
            timer= null
          }
        }

        // 准点执行，就没必要再去判断要不要尾部执行了
        if (waitTime <= 0) {
          exec()
          return
        }

        if (trailInvoke) {
          if (timer) {
            clearTimeout(timer)
            timer = null
          }

          timer = setTimeout(exec, waitTime)
        }

        _throttle.cancel = () => {
          // 只有trailInvoke为true的时候，才可能需要尾部清除
          if (timer) {
            clearTimeout(timer)
            timer = null
            startTime = 0
          }
        }
      } catch(e) {
        reject(e.message)
      }
    })
  }

  return _throttle
}

const fn = throttle((type) => console.log(type), 2000, {
  trailInvoke: true
})

let count = 0

const intervalId = setInterval(() => {
  count++

  if (count === 3) {
    // 在时间间隔中执行多次，只会执行最后一个
    fn('trail call1')
    fn('trail call2')
    clearInterval(intervalId)
  } else {
    fn('normal call')
  }
}, 100)
```



> `loash` 和 `underscore`等第三方库提供了对应的防抖和节流函数，可以直接引入并使用
>
> `loash`对`underscore`进行了功能扩展，比`underscore`要重，但已经不维护了
>
> 如果要使用，直接使用`underscore`即可
