## 面向对象三大特征

| 特性 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| 封装 | 将相关联的属性和方法 封装到一个类中，以提高相关属性和方法的内聚度 |
| 继承 | 将重复的代码和逻辑抽取到父类中，子类只需要直接继承过来使用即可<br />从而减少重复代码的数量，继承同时也是多态的前提<br />子类又叫派生类，父类又叫基类 |
| 多态 | 相同的操作（方法或函数）在不同的对象上具有不同的表现形式     |



在纯面向对象语言中，多态是通过重写父类同名方法实现的，所以继承是多态的前提条件

在函数式编程中，尤其是在像JavaScript这种弱数据类型语言中，处处是多态

因为函数可以接收任意类型参数，并根据类型不同执行不同的操作，从而实现多态 「 不需要通过继承 」

所以从广义角度来说，JavaScript到处都是多态，但从狭义角度来说，JavaScript中不存在多态



**弱数据类型形成的多态**

```js
function foo(arg1, arg2) {
  return arg1 + arg2
}

console.log(foo(10, 20))
console.log(foo('Hello', 'World'))
```



**函数式编程形成的多态**

```js
function foo(arg1, arg2, fn) {
	return fn(arg1, arg2)  
}

console.log(foo(10, 20, (arg1, arg2) => arg1 + arg2))
console.log(foo(10, 20, (arg1, arg2) => arg1 - arg2))
```



## ES5继承

### 继承方法

ES5中继承方法使用的是**借用原型链继承**, 只能继承方法不能继承属性

```js
// 父类
function Person(name, age) {
  this.name = name
  this.age = age
}

Person.prototype.eatting = function() {
  console.log(this.name + ' eatting')
}

// 子类
function Student(name, age, sno) {
  // 借用原型链继承无法继承属性
  this.name = name
  this.age = age
  this.sno = sno
}

// 借用原型链实现继承
const per = new Person('per', 18)
Student.prototype = per

Student.prototype.studying = function() {
  console.log(this.name + ' studying')
}
```



### 继承属性

ES5继承属性使用的方法是**借用构造函数继承**

即使用借用构造函数继承，又使用借用原型链继承的方式，被称之为**组合继承**

```js
// 父类
function Person(name, age) {
  this.name = name
  this.age = age
}

Person.prototype.eatting = function() {
  console.log(this.name + ' eatting')
}

// 子类
function Student(name, age, sno) {
  // 子类执行父类构造方法，因为this的值是子类实例
  // 因此name和age将被挂载到实例上
  Person.call(this, name, age)
  this.sno = sno
}

const per = new Person('per', 18)
Student.prototype = per

Student.prototype.studying = function() {
  console.log(this.name + ' studying')
}
```



### 寄生组合式继承

现在的组合继承有一些弊端

父类被执行了两次 「 继承属性时被调用，继承方法时又被调用了一次 」

继承方法而调用父类构造函数，会导致子类的显示原型上存在多余的属性 「 在这里就是name和age 」

因此我们需要让子类的显示原型指向一个空对象，而这个空对象的原型指向父类的显示原型



#### 工厂函数

最古老的实现方式是使用工厂函数

```js
// 父类
function Person(name, age) {
  this.name = name
  this.age = age
}

Person.prototype.eatting = function() {
  console.log(this.name + ' eatting')
}

// 子类
function Student(name, age, sno) {
  Person.call(this, name, age)
  this.sno = sno
}

// 原型式继承函数 - 本质是一个工厂函数
function createObj(obj) {
  // 通过空构造函数来创建空对象
  function F() {}
  F.prototype = obj
  return new F()
}

// 寄生式(Parasitic)函数
// 通过一个对象派生出另一个对象的形式被称之为 寄生对象，对应函数是寄生式函数
function inherit(subType, superType) {
  subType.prototype = createObj(superType.prototype)
}

// 方法继承
inherit(Student, Person)

Student.prototype.studying = function() {
  console.log(this.name + ' studying')
}
```

这种继承方式即使用了寄生式函数，又使用了组合函数，所以被称之为**寄生组合式继承**



在ES6中，可以使用`Object.create`和`Object.setPrototypeof`来替代`原型继承函数`

```js
function inherit(subType, superType) {
  // 实现实例方法的继承
  subType.prototype = Object.create(superType.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: subType
    }
  })

  // 实现静态方法和属性的继承 -- 使用setPrototypeOf是因为这里修改的是构造函数的隐式原型
  Object.setPrototypeOf(subType, superType)
}
```



## ES6继承

ES6使用class关键字来定义类

class关键字的本质是寄生组合式继承的语法糖 「 **简化了写法，并进行了一定程度的增强** 」

class相比构造函数定义类，在极大程度上提高了内聚度



### 基本使用

和构造函数一样，类一般也采用大驼峰写法

```js
// 类声明
class Person {}

// 类表达式
const Student = class {}
```



```js
class Person {
  // 通过new调用时，本质调用的是构造方法 「 用于对实例属性进行初始化 」
  // 在类中，构造函数有且只能有一个
  constructor() {} // -> 这是默认的构造方法，可以省略

  // 类中方法定义方法，不是getName: function() {}的语法糖
  getName() {}
  
  // 方法和方法之前不使用逗号分割
  setName() {}
}
```



```js
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  // 类中的方法会自动挂载到类的原型对象上
  running() {
    console.log('running')
  }

  // 通过类的表达式写法定义方法，本质其实是定义实例属性，值是方法
  // 其和在构造函数中通过this.eatting = () => { ... } 是等价的
  eatting = () => {
    console.log('eatting')
  }
}

const per = new Person('Klaus', 23)
per.running()
per.eatting()
```



### 存储器

```js
class Foo {
  // #开头的属性是类的私有属性或私有方法 「 需要先以类表达式形式进行声明 」
  // ES6之前，通过下划线开头变量定义私有属性 「 语法不限制，仅是约定规则 」
  #name = ''

  // getter方法
  get name() {
    return this.#name
  }

  // setter方法
  set name(v) {
    this.#name = v
  }
}

const foo = new Foo()
foo.name = 'Klaus'
console.log(foo.name)
```



### 静态属性和静态方法

与类实例相关的属性和方法被挂载到实例上

而与类本身相关的属性和方法通过staitc关键字被挂载到类本身上

```js
class Foo {
  static username = 'klaus'

  static bar() {
    console.log(this) // => class Foo
  }
  
  // 静态代码块只会在类初始化时执行一次，用于执行一些初始化操作
  static {
    console.log('静态代码块')
  }
}

console.log(Foo.username) // => klaus
Foo.bar()
```



### 继承

```js
class Parent {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  running() {
    console.log('running')
  }
}

// 通过extends关键字实现继承
class Student extends Parent {
  constructor(name, age, sno) {
    // 子类必须在使用this或返回实例之前, 必须先调用super方法初始化父类构造函数
		// 先调用 super 是为了确保父类实例被正确初始化，保证继承机制的正确性和对象状态的一致性
    super(name, age)
    this.sno = sno
  }

  // 如果子类方法和父类同名，就是重写父类方法
  eatting() {
    console.log('eatting')
  }
}

const stu = new Student('Klaus', 23, 1810166)
console.log(stu)
stu.running()
stu.eatting()
```

```js
class Person  {
  constructor() {
  }
}

class Student extends Person {
  // 继承后 对应的默认构造函数如下: 「 可以省略 」
  constructor(...props) {
    super(...props)
  }
}
```



### super

super的应用场景

1. 调用父类构造函数，初始化子类实例
2. 调用父类的实例方法
3. 调用父类的静态方法

```js
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  running() {
    console.log('running')
  }

  static eatting() {
    console.log('eatting')
  }
}

class Student extends Person {
  constructor(name, age) {
    super(name, age)
  }

  running() {
    console.log('overwrite')
    super.running()
  }

  static eatting() {
    console.log('overwrite')
    super.eatting()
  }
}

const stu = new Student('Klaus', 24)
Student.eatting()
stu.running()
```



### 成员变量

类成员表达式定义的实例属性确实是定义在实例上的，而不是原型上的、

类成员表达式会在构造函数执行之后，再被执行，因此如果构造函数中定义了同名属性，类成员表达式中的值会覆盖构造函数中的值。

```js
class Person {
  // 定义实例属性 「 这种定义方式被称之为 类的成员表达式 」
  height = 1.88
  static intro = 'static public field'

  constructor(name, age) {
    // 定义实例属性
    this.name = name
    this.age = age
  }

  // 类成员表达式的值可以是函数 「 不推荐，会被挂载到实例上 」
  running = function() {
    console.log('running')
  }
}

const per = new Person('Klaus', 23)
console.log(Object.hasOwn(per, 'running')) // => true
```



### 私有属性

之前在类中定义私有属性，通过`_`前缀，但这是约定规则并不是语法限制规则

从ES13起，可以通过`#`前缀来定义私有属性和私有方法，其会在语法层面对其进行限制

私有属性和私有方法只能在类的内部进行访问，不可以通过类的实例或子类来进行访问

```js
class Person {
  // 私有成员需要先声明后使用 「 通过类成员表达式方式进行声明 」
 	# address
  static #msg = 'private static msg'
  
	#getAge() { // 私有方法
    return this.#age;
  }

	static #getMsg() { // 静态私有方法
    return this.#age;
  }
}
```



## mixin

mixin 本质是一种叫组合模式的设计模式，它通过组合多个功能模块来扩展对象的行为，而不是通过继承来扩展。

mixin 通常通过将一组方法或属性添加到现有对象上来实现扩展。从而在不改变原始对象的情况下添加新功能。

虽然mixin相比继承来说更灵活也更轻量级，但是如果使用了多个mixin，且多个 mixin之间 包含同名的属性或方法，后者会覆盖前者。这会导致属性和方法的来源不明确，使代码难以理解和维护，增加调试的复杂性

因此一般不推荐使用mixin



### 示例

JavaScript默认只支持单继承，但可以通过mixin来模拟多继承

```js
class Student {
  studying() {
    console.log('studying')
  }
}

//基本原理是将多继承转变为多层的单继承
function mixinEatting(baseClass) {
  // 返回了一个匿名类
  return class extends baseClass {
    eatting() {
      console.log('eatting')
    }
  }
}

function mixinRunning(baseClass) {
  return class extends baseClass {
    running() {
      console.log('running')
    }
  }
}

const stu1 = new (mixinEatting(mixinRunning(Student)))()
stu1.running()
stu1.eatting()
stu1.studying()
```