正则表达式用于在字符串中进行查找，匹配，替换等操作

正则表达式主要由两部分组成:模式(patterns)和修饰符(flags)

```js
// 参数1 为 pattern 参数2 为 flags
const reg1 = new RegExp('foo', 'ig')

// 可以省略new 不推荐
const reg2 = RegExp('foo', 'gi')

// /pattern/flags
const reg3 = /foo/gi
```



## 方法

正则实例只有`exec`和`test`方法，别的都是字符串的方法

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/749773e0e2df4e829d6adf45bee044e6~tplv-k3u1fbpfcp-zoom-1.image) 



### replace/replaceAll

1. `replacce`和`replaceAll`传入正则，如果匹配失败，静默失效

   ```js
   const str = 'Lorem23 ipsum dol323or sit'
   console.log(str.replace(/\d+/g, '')) // => Lorem ipsum dolor sit
   ```

   

> 名称以All结尾的方法，传入正则时，正则必须开启全局匹配 『 以便于全局查找 』，否则直接报错
>
> ```js
> const str = 'Lorem23 ipsum dol323or sit'
> console.log(str.replaceAll(/\d+/g, '')) // => Lorem ipsum dolor sit
> ```

   

### exec

1. 以数组形式返回第一个匹配项的详细信息 「 无论是否开启全局模式，都只返回第一个 」

2. 没有匹配成功，就返回null 

   「 JavaScript中基本所有的正则方法如果没有匹配成功，但需要返回值，则返回null 」

```js
const str = 'Lorem 3232ipsum dolor32132 sit'

console.log(/\d+/ig.exec(str))
/*
  =>
    [
      '3232',
      index: 6,
      input: 'Lorem 3232ipsum dolor32132 sit',
      groups: undefined
    ]
*/
```



### match/matchAll

```js
const str1 = 'Lorem 3232ipsum dolor32132 sit'

// 全局匹配，以数组形式返回匹配结果
// 1. 只有一个匹配结果，也是以数组形式返回
// 2. 没有匹配，返回null 「 不是空数组 」
console.log(str1.match(/\d+/ig)) // => [ '3232', '32132' ]
```

```js
const str1 = 'Lorem 3232ipsum dolor32132 sit'

// 不开启全局匹配，效果和exec完全一致
// 1. 不管匹配中多少项，只返回符合条件的第一项的详细信息
// 2. 没匹配成功，返回null
console.log(str1.match(/\d+/i)) 
/*
	=>
	[
    '3232',
    index: 6,
    input: 'Lorem 3232ipsum dolor32132 sit',
    groups: undefined
  ]
*/
```

```js
const str1 = 'Lorem 3232ipsum dolor32132 sit'

// 1. matchAll方法传入正则，必须开启全局
// 2. matchAll的返回值即是迭代器，也是可迭代对象
// 3. 返回每一个匹配项的详细信息
const iterator = str1.matchAll(/\d+/ig)

console.log(iterator.next())
/*
  =>
    {
      value: [
        '3232',
        index: 6,
        input: 'Lorem 3232ipsum dolor32132 sit',
        groups: undefined
      ],
      done: false
    }
*/

for (const item of iterator) {
    console.log(item)
}
/*
  =>
    [
      '3232',
      index: 6,
      input: 'Lorem 3232ipsum dolor32132 sit',
      groups: undefined
    ]
    [
      '32132',
      index: 21,
      input: 'Lorem 3232ipsum dolor32132 sit',
      groups: undefined
    ]
*/
```



### search

1. 返回第一个匹配项第一个字符在字符串中的索引值
2. 无视全局匹配，也没有`searchAll` 「 只返回第一个匹配项 」

```js
const str = 'Lorem 3232ipsum dolor32132 sit'
console.log(str.search(/\d+/ig)) // => 6
```

匹配失败，则返回`-1`

```js
const str = 'Lorem ipsum dolor sit'
console.log(str.search(/\d+/ig)) // => -1
```



### split

找到匹配项，并以此对字符串进行分割

无论是否开启全局匹配，都是找到所有匹配项后进行分割

```js
const str = 'Lorem 3232ipsum dolor32132 sit'

console.log(str.split(/\d+/i)) // => [ 'Lorem ', 'ipsum dolor', ' sit']
console.log(str.split(/\d+/ig)) // => [ 'Lorem ', 'ipsum dolor', ' sit']
```



## 修饰符

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d8e483122f2484f966f0a7daaf78168~tplv-k3u1fbpfcp-zoom-1.image) 

默认值是 `非全局匹配，并大小写敏感`



### 多行匹配

默认情况下，字符串会作为一个整体进行匹配

开启多行匹配后，字符串会按照换行符进行分割形成多个子字符串后，再逐个进行匹配

```js
const str = `
Hello World
Hello Vue
Hello React
`

// 多行匹配是按照换行符进行分割，所以实际匹配的是
// '\nHello World\nHello Vue\nHello React\n' 分割后为
// [ '', 'Hello World', 'Hello Vue', 'Hello React', '' ]
// 也就是说 实际上 字符串的开头和结尾部分是 换行符

// 开启多行匹配，每一个子字符串都进行匹配
console.log(str.match(/^Hello (.*)$/mg)) 
// => [ 'Hello World', 'Hello Vue', 'Hello React' ]

// 没有开启多行匹配，字符串整体进行匹配 「 开头和结尾是换行符 」
console.log(str.match(/^Hello (.*)$/g)) // => null

console.log(str.match(/^\s(Hello\s[A-Z]\w+\s?)+$/g))
// => [ '\nHello World\nHello Vue\nHello React\n' ]
```



## 规则 

```shell
# 伪代码
$ \d === [0-9] # 0~9中的任意一个数字
$ \s # 任意空白字符 「 如换行符，空格等 」
$ \w === [0-9a-zA-Z_] # 字母数字下划线中的任意一个
$ . # 除换行符外的任意字符 「 不包括换行符 」
```

| 符合 | 没有开启多行匹配时含义 | 开启多行匹配时含义 |
| ---- | ---------------------- | ------------------ |
| `^`  | 字符串开头             | 每一行的行头       |
| `$`  | 字符串结尾             | 每一行的行尾       |



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9391c39b5cc4804869fbadaf55549f9~tplv-k3u1fbpfcp-zoom-1.image) 

```js
const str = 'time is 12:45, number is 123:342'
const reg = /\b\d\d:\d\d\b/g
console.log(str.match(reg)) // => [ '12:45' ]
```

`\b` => 单词边界  

`\B` => 非单词边界



在特殊含义字符前（如 `[] \ ^ $ . | ? * / + ( )`等）加`\`表示转移

```js
const reg = /\.jsx?$/
```



`[ABC]` => 存在字符`A | B | C`

`[a-z0-9]` => 存在26个小写字符中的任何一个或0-9中的某个数字

`[^0-9]`  => 不要数字

`[\s\S]` => 所有字符 「 无论该字符是否为可见字符 」



`\d{5}` => 5个连续的数字

`\d{3,5} ` => 3-5个连续的数字，包含3和5这两个边界 「 `{3,5}`不要有空格，`{3, 5}`是不合法的 」

`\d{3,} ` =>连续3个及以上的数字 「 省略第二个表示大于等于3个连续的数字 」

| 符号 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| +    | 代表“一个或多个”，相当于 `{1, }`                             |
| ？   | 代表“零个或一个”，相当于 `{0,1}` 换句话说，它使得符号变得可选 |
| *    | 代表着“零个或多个”，相当于 `{0, }` 也就是说，这个字符可以多次出现或不出现 |



`abc{2,}` => `ab` + 两个或以上连续的`c`

`(abc){2,}` => 两个或以上连续的`abc`



## 贪婪(Greedy)和惰性(lazy)模式

默认情况下，会找到符合条件的最长字符串，这种模式就是贪婪模式

可以在量词后加上`?`，来开启惰性模式，如 `+？, *?, ??`等

开启惰性模式后，只会匹配到符合条件的最短字符串

```js
const str = '<div>foo</div><div>bar</div><div>baz</div>'
const reg1 = /<.+>/gi
const reg2 = /<.+?>/gi

console.log(str.match(reg1)) 
// => [ '<div>foo</div><div>bar</div><div>baz</div>' ]

console.log(str.match(reg2)) 
// => [ '<div>', '</div>', '<div>', '</div>', '<div>', '</div>' ]
```



## 捕获组

通过捕获组，取出匹配内容中的指定某一部分

```js
const str = '有以下书籍: 《朝花夕拾》, 《群己权界论》, 《小王子》'
const reg = /(《)(.+?)》/gi

// 分组内容需要通过匹配详情查看
const books = str.matchAll(reg)

for (const book of books) {
  console.log(book)
}
/*
  =>
    [
      '《朝花夕拾》',  // => 匹配到的内容
      '《',   // => 第一个分组中的内容
      '朝花夕拾',  // => 第二个分组中的内容，依次类推
      index: 7, // => 匹配到的字符串的首字母对应的索引值
      input: '有以下书籍: 《朝花夕拾》, 《群己权界论》, 《小王子》', // => 输入字符串
      groups: undefined // => 具名分组会以对象的形式存放在这个属性中，默认值为undefined
    ]

    ...
*/
```

```js
const str = '有以下书籍: 《朝花夕拾》, 《群己权界论》, 《小王子》'
// 捕获组的命名方式是在捕获组开头加上 ?<捕获组名称>
const reg = /《(?<bookname>.+?)》/gi

const books = str.matchAll(reg)

for (const book of books) {
  // 对应的具名捕获组会存放在详细信息的groups属性中
  console.log(book.groups.bookname)
}
/*
  =>
    朝花夕拾
    群己权界论
    小王子
*/
```

```js
const str = '有以下书籍: 《朝花夕拾》, 《群己权界论》, 《小王子》'

// 在捕获组开头加上  ?: 表示小括号只是表示整体，其并非捕获组
const reg = /(?:《)(.+?)(?:》)/gi

const books = str.matchAll(reg)

for (const book of books) {
  console.log(book)
}
/*
  =>
    [
      '《朝花夕拾》',
      '朝花夕拾', // 《 和 》 不在 捕获组中
      index: 7,
      input: '有以下书籍: 《朝花夕拾》, 《群己权界论》, 《小王子》',
      groups: undefined
    ]

    ...
*/
```

```js
const str = 'Hello World, Hello JavaScript, Hello React'

// 在捕获组中可以通过 | 表示或的概念
console.log(str.match(/(World|JavaScript|React)/gi)) 
// => [ 'World', 'JavaScript', 'React' ]
```



### 回溯引用

引用之前捕获组中匹配内容

```js
const str1 = `<div>loren</div>`
const str2 = `<div>loren</span>`

// 默认情况下 \w+ 只能匹配到任意个字符, 但并不要求多次匹配的时候对应的值必须相同
console.log(/<\w+>.*<\/\w+>/.test(str1)) // => true
console.log(/<\w+>.*<\/\w+>/.test(str2)) // => true

// 通过 \n 的形式 引用之前 第n个捕获组 「 索引从1开始 」
console.log(/<(\w+)>.*<\/\1>/.test(str1)) // => true
console.log(/<(\w+)>.*<\/\1>/.test(str2)) // => false
```

`replace`和`replaceAll`也可以使用回溯引用，只不过是通过`$n`的形式

```js
const str = '<p>2333</p>'
const regExp = /<\/?(.*?)>/g

// replace 和 replaceAll中的回溯引用 需要以字符串形式 传入
console.log(str.replace(regExp, '$1')) // => p2333p
```



## 断言

在 JavaScript 的正则表达式里，**断言**是一种特殊的规则，它会检查某个位置的前后是否符合你设定的条件，但它**不会**实际匹配这些字符，也就是说，它只是检查而已，不会占用或改变匹配到的内容。



常见的断言除了之前所说的:

+ **开头断言** (`^`)
+ **结尾断言** (`$`)
+ **词边界断言** (`\b`)
+ **非词边界断言** (`\B`)



还存在如下断言: 

**正向前瞻断言**: `\d(?=px)` 匹配字符串 `"10px"` 中的 `10`（但不包括 `px`）。

**负向前瞻断言**: `\d(?!px)` 匹配 `"10em"` 中的 `10`（因为它后面没有 `px`）。

**正向后顾断言**: `(?<=\$)\d+` 匹配 `$100` 中的 `100`。

**负向后顾断言**: `(?<!\$)\d+` 匹配 `100`，但不匹配 `$100`。



前瞻断言又叫先行断言，所有浏览器都支持

后顾断言又叫后行断言，大部分现代浏览器都支持 「 safari不支持 」



## 示例

### 日期格式化

```js
function formatTime(timeStamp, formatStr = 'YYYY-MM-DD HH:mm:ss') {
  // 避免直接修改参数 -- 纯函数
  let dateStr = formatStr

  const date = new Date(timeStamp)

  const keywords = {
    'Y{4}': date.getFullYear(),
    'M{2}': date.getMonth() + 1, // 月份是从0开始计算的
    'D{2}': date.getDate(), // getDate是月份中的第几天 getDay是一周中的第几天
    'H{2}': (date.getHours() + '').padStart(2, '0'),
    'm{2}': (date.getMinutes() + '').padStart(2, '0'),
    's{2}': (date.getSeconds() + '').padStart(2, '0')
  }

  for (const [key, value] of Object.entries(keywords)) {
    const reg = new RegExp(key)

    if (reg.test(formatStr)) {
      dateStr = dateStr.replace(reg, value)
    }
  }

  return dateStr
}

console.log(formatTime(Date.now())) // => 2024-8-23 13:37:08
console.log(formatTime(Date.now(), 'YYYY-MM-DD')) // => 2024-8-23
```



### 密码强度验证

对用户输入的密码要求字符串满足长度至少8个字符，且包含小写字母、大写字母和数字

```js
// 子串或字符串本身存在小写字符，大写字符和数字的前提下，长度需要大于等于8位
console.log(/(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9]).{8,}/.test('Admin123456')) 
// => true
```



`(?=.*[a-z])`表示字符串本身或子串「 空字符串也是子串的一种 」的后边有小写字符，且他们之间不一定要连续，简单来说就是字符串中存在小写字符，同理`(?=.*[A-Z])`表示要有大写字符，`(?=.*[0-9])`表示要有数字

`1(?=.*[a-z])`表示字符串本身或子串中存在数字1，且数字1后边紧跟着小写字符，数字1和小写字符之间不一定要连续



以下判断都是错误的

```js
// 子串或字符串本身长度大于等于8位的前提条件下，在后边存在小写字符，大写字符和数字
console.log(/.{8,}(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])/.test('Admin123456'))
// => false
```

```js
// 子串或字符串本身后边同时直接紧跟小写字符，大写字符和数字的前提下，长度需要大于等于8位
// 这类字符串时不存在的
console.log(/(?=[a-z])(?=[A-Z])(?=[0-9]).{8,}/.test('Admin123456')) 
// => false
```

