## 迭代器

迭代器是一种帮助我们遍历某个数据结构「 容器对象 」的对象，无需关心对象的内部实现细节

迭代器在各种编程语言中都有实现，例如Java和Python，最典型的迭代器就是数据库中的光标



在JavaScript中，迭代器是一个具体的对象，需要符合迭代器协议（Iterator Protocol）

该协议定义了产生一系列值（无论是有限还是无限个）的标准方式，即一个特定的 `next` 方法。



`next` 方法的要求

1. `next` 方法是一个无参数或者一个参数的函数。「 只有生成器才会给next方法传参 」
2. `next` 方法返回一个对象，该对象应当拥有以下两个属性：
   - `done` (boolean) --- 是否迭代完毕
     - 如果迭代器可以产生序列中的下一个值，则为 `false`。这等价于没有指定 `done` 这个属性。
     - 如果迭代器已将序列迭代完毕，则为 `true`。这种情况下，`value` 是可选的，如果它依然存在，即为迭代结束之后的默认返回值（一般情况下，对应的默认值为 `undefined`，因此此时 `value` 就可以省略）。
   - `value`:
     - 迭代器返回的任何 JavaScript 值。`done` 为 `true` 时可省略。

```javascript
function createIterator(array) {
  let index = 0
  
  return {
    next() {
      if (index < array.length) {
        return { value: array[index++], done: false };
      } else {
        return { done: true };
      }
    }
  };
}

const myIterator = createIterator([1, 2, 3]);

console.log(myIterator.next()); // { value: 1, done: false }
console.log(myIterator.next()); // { value: 2, done: false }
console.log(myIterator.next()); // { value: 3, done: false }
console.log(myIterator.next()); // { done: true }
```



目前容器对象和迭代器是分离的，可以通过`Symbol.iterator`进行关联

如果`Symbol.iterator`方法返回迭代容器对象的迭代器，则这个对象就是可迭代对象

```js
const user = {
  friends: ['Alex', 'Klaus', 'Steven'],

  // 需要是计算属性 -- 内部实际指向`@@iterator`
  [Symbol.iterator]() {
    let index = 0

    // 生成迭代器的调用方式类似于 user[Symbol.iterator]()
    console.log(this === user) // => true

    return  {
      // 迭代器的生成方式类似于 [Symbol.iterator]()
      // 所以 next方法一般写成箭头函数 以修正this指向
      next: () => {
        if (index < this.friends.length) {
          return {
            done: false,
            value: this.friends[index++]
          }
        } else {
          return { done: true }
        }
      }
    }
  }
}

// for - of iterable --- 内部自动调用iterable的迭代器
for (const name of user) {
  console.log(name)
}
/*
  =>
    Alex
    Klaus
    Steven
*/
```



JavaScript 的一些内置对象 「 如String、Array、Map、Set、arguments、NodeList 」 都是可迭代对象 

「 也就是默认实现了对应迭代器方法 」

```js
const arr = [1, 2, 3]
const iterator = arr[Symbol.iterator]()

console.log(iterator.next()) // => { value: 1, done: false }
console.log(iterator.next()) // => { value: 2, done: false }
console.log(iterator.next()) // => { value: 3, done: false }
console.log(iterator.next()) // => { value: undefined, done: true }
```



## 应用场景

1. JavaScript中语法: for ...of、展开语法(spread syntax)、yield*、解构赋值(Destructuring_assignment) {对象的解构赋值除外}
2. 创建一些对象时:new Map([Iterable])、new WeakMap([iterable])、new Set([iterable])、new WeakSet([iterable])
3. 一些方法的调用:Promise.all(iterable)、Promise.race(iterable)、Array.from(iterable)



## 迭代器的中断

 迭代器在某些情况下会在没有完全迭代的情况下中断，就会触发return方法

+ 比如遍历的过程中通过break、return、throw中断了循环操作
+ 比如在解构的时候，没有解构所有的值

```js
const user = {
  name: 'Klaus',
  age: 23,
  height: 1.88,
  [Symbol.iterator]() {
    const values = Object.values(user)
    let index = 0

    return {
      next() {
        if (index < values.length) {
          return { done: false, value: values[index++] }
        } else {
          return { done: true }
        }
      },

      // 不写存在默认return方法，这里是在重写return方法
      // 迭代器必须返回的都是有done和value属性的对象 「 return方法也不例外 」
      return() {
        console.log('迭代器被中断了')
        return { done: true }
      }
    }
  }
}

for (const value of user) {
  console.log(value)
  if (value === 23) {
    break
  }
}
```



## 生成器

1. 生成器函数可以手动控制函数的执行和暂停
2. 生成器函数的返回值是一个Generator(生成器，一种特殊的迭代器)



一个函数function后边加上 星号 就表明当前函数是生成器函数

`*`只要在function和函数名之间即可 即 `function* foo()` 和 `function *foo()` 都是合法的 

「 推荐 `function* foo()` 」

```js
function* foo() {
  console.log(111)
  console.log(222)
  yield
  console.log(333)
  console.log(444)
  yield
  console.log(555)
  console.log(666)
}

const generator = foo()

// yield可以看成仅能在生成器函数中使用的特殊return
generator.next()
/*
  =>
    111
    222
*/

console.log('------')
generator.next()
/*
  =>
    333
    444
*/

console.log('------')
generator.next()
/*
  =>
    555
    666
*/

// 函数内部代码执行完毕后，继续执行生成器对象的next方法，会静默失效
generator.next()
```

```js
function* foo() {
  console.log(111)
  console.log(222)
  yield '第一次yield返回值'
  console.log(333)
  console.log(444)
  yield '第二次yield返回值'
  console.log(555)
  console.log(666)
  return 'foo函数执行完毕了'
}

const generator = foo()

// yield关键字 后边的值 会作为next方法返回值的value值
// 如果是因为 yield关键字 暂停的 函数执行 那么next方法的返回值的done属性的值为false
// 如果是因为 return 结束的 函数执行 那么next方法的返回值的done属性的值为true
console.log(generator.next()) // => { value: '第一次yield返回值', done: false }
console.log(generator.next()) // => { value: '第二次yield返回值', done: false }
console.log(generator.next()) // => { value: 'foo函数执行完毕了', done: true }
```

```js
function* foo(res) {
  console.log(res)
  const res1 = yield
  console.log(res1)
  const res2 = yield
  console.log(res2)
  return 'foo函数执行完毕了'
}

// 函数执行到第一个yield中使用的变量在函数调用的时候进行传入
const generator = foo('第一次传参')

// 第一次调next方法时候，一般不会传入对应的参数(也无法传入对应的参数)
generator.next()

// 自第二次开始，next方法传入的参数,会作为yield表达式的返回值
generator.next('第二次传参')
generator.next('第三次传参')
```

```js
function* foo(res) {
  console.log(res)
  const res1 = yield '第一次yield返回值'
  console.log(res1)
  return 'foo函数执行完毕了'
  console.log(res2)
  yield 'foo函数执行完毕了'
}

const generator = foo()

// 如果提前return了，那么生成器函数后边的所有yield和return都不会再被执行
// return后边的值 会作为返回对象的value属性，并将done设置为true
console.log(generator.next('第一次传参')) 
// => { value: '第一次yield返回值', done: false }
console.log(generator.next('第二次传参')) 
// => { value: 'foo函数执行完毕了', done: true }
console.log(generator.next('第三次传参')) 
// => { value: undefined, done: true }
```

```js
function* foo() {
  console.log('part1')
  yield
  console.log('part2')
  yield
  console.log('part3')
}

const generator = foo('arg1')

console.log(generator.next()) // => { value: undefined, done: false }

// 调用生成器的return方法 会立即结束生成器函数的执行
// 返回的对象中 done的值 为 true, value的值为return方法传入的参数
console.log(generator.return('arg2')) // => { value: 'arg2', done: true }
console.log(generator.next('arg3')) // => { value: undefined, done: true }
```

```js
function* foo() {
  console.log('part1')
  try {
    // 第一个yield的返回值是一个异常，或者说yeild表达式执行产生了异常
    // 所以使用try-catch进行异常捕获
    yield
    console.log('part2')
  } catch(e) {
    // 在catch语句中不能继续yield新的值，但是可以在catch语句外使用yield继续中断函数的执行
    // 在catch中的yield会被自动忽略
    console.log('error:' + e)
  }

  yield
  console.log('part3')
}

const generator = foo('arg1')

console.log(generator.next())
// generator.throw方法 用于让generator在内部抛出一个异常 「 该方法的参数是一个异常对象 」
console.log(generator.throw(new Error('this is an error')))
console.log(generator.next('arg3'))
```



## 生成器 替代 迭代器

```js
const user = {
  name: 'Klaus',
  age: 24,
  height: 1.88,

  *[Symbol.iterator]() {
    const entries = Object.entries(user)
    for (let i = 0; i < entries.length; i++) {
      // 调用next方法后，会将第一个entry返回，并停止当前函数的执行
      // 再次调用next方法，返回后一个entry，并再次停止当前函数的执行
      // 依次类推
      // 最终迭代完成后，返回{ done: true, value: undefined }
      yield entries[i]
    }
  }
}

for(let [key, value] of user) {
  console.log(key, value)
}
/*
  =>
    name Klaus
    age 24
    height 1.88
*/
```



### yield*

`yield* <iterable>` 是一种yield的语法糖，会依次迭代这个可迭代对象，每次迭代其中的一个值

所以上述示例中，生成器可以修改为

```js
*[Symbol.iterator]() {
    yield* Object.entries(this)
  }
```



## async/await

如果我们存在如下需求:

+ 我们需要向服务器发送网络请求获取数据，一共需要发送三次请求
+ 第二次的请求url依赖于第一次的结果
+ 第三次的请求url依赖于第二次的结果
+ 依次类推

```js
// 如何then方法嵌套then回调，会导致嵌套层级过多，产生回调地狱
asyncFn('第一次调用').then(res => {
  console.log(res)
  asyncFn('第二次调用').then(res => {
    console.log(res)
    asyncFn('第三次调用').then(res => console.log(res))
  })
})
```

```js
// 利用promise的then方法依旧会返回一个新的promise的特性, 可以将嵌套调用 转换为 链式调用
asyncFn('第一次调用').then(res => {
  console.log(res)
  return asyncFn('第二次调用')
}).then(res => {
  console.log(res)
  return asyncFn('第三次调用')
}).then(res => console.log(res))
```

```js
function asyncFn(res) {
  return new Promise(resolve => {
    setTimeout(() => resolve(res), 2000)
  })
}

// 利用生成器函数来处理异步方法
function* fetchData() {
  const res1 = yield asyncFn(10)
  const res2 = yield asyncFn(20)
  const res3 = yield asyncFn(30)

  console.log(res1 + res2 + res3) // => 60
}

const generator = fetchData()

generator.next().value
  .then(res => generator.next(res).value)
  .then(res => generator.next(res).value)
  .then(res => generator.next(res).value)
  .catch(err => console.error(err))
```

生成器执行逻辑是重复的，可以封装成一个自动化执行函数

```js
function asyncFn(res) {
  return new Promise(resolve => {
    setTimeout(() => resolve(res), 2000)
  })
}

// 利用生成器函数来处理异步方法
function* fetchData() {
  const res1 = yield asyncFn(10)
  const res2 = yield asyncFn(20)
  const res3 = yield asyncFn(30)

  console.log(res1 + res2 + res3) // => 60
}

const generator = fetchData()
execGenerator(fetchData)

function execGenerator(fn) {
  if (typeof fn !== 'function') {
    throw new Error('fn is not a function')
  }

  const generator = fn()

  function exec(res) {
    const { done, value } = generator.next(res)

    // done为true，表示函数已经执行完毕
    if (done) return
    // 否则继续执行
    value.then(res => exec(res))
  }

  exec()
}
```

在ES9中，提供了`async/await`, `async/await`本质就是`promise+generator`的语法糖

```js
function asyncFn(res) {
  return new Promise(resolve => {
    setTimeout(() => resolve(res), 2000)
  })
}

// 这段代码就是上述示例的语法糖写法
async function fetchData() {
  const res1 = await asyncFn(10)
  const res2 = await asyncFn(20)
  const res3 = await asyncFn(30)

  console.log(res1 + res2 + res3) // => 60
}

fetchData()
```

async声明的函数就是异步函数，异步函数的返回值是promise

+ 情况一：异步函数也可以有返回值，但是异步函数的返回值相当于被包裹到Promise.resolve中
+ 情况二：如果我们的异步函数的返回值是Promise，状态由会由Promise决定
+ 情况三：如果我们的异步函数的返回值是一个对象并且实现了thenable，那么会由对象的then方法来决定



所以异步函数抛出的错误，可以使用catch进行捕获

```js
async function foo() {
  throw new Error('this is a error')
}

foo()
  .then(res => console.log(res))
  .catch(err => console.error(err.message))
```

注意，以下方式是无法捕获错误的

```js
async function foo() {
  throw new Error('this is a error')
}

try {
  // 异步函数返回值是异步的，try-catch是同步的
  foo()
} catch(e) {
  console.error(e.message)
}
```

可以进行如下改进

```js
async function foo() {
  throw new Error('this is a error')
}

try {
  // 等待foo执行结束，以便于捕获foo执行异常
  await foo()
} catch(e) {
  console.error(e.message)
}
```



await关键字只能使用在async函数内部，或ES模块的顶层

await表达式后边的值 需要是一个promise实例 「 不是会自动转换 」

await后边的表达式是同步执行的，但await语句后边的代码需要等await 表达式值变为`fulfilled`时才会继续执行



如果await关键字需要在ES模块顶层使用，需要满足如下两个条件中的任意一个

1. 在`package.json`中设置`type: module`
2. 将需要开启顶层`await`的模块的后缀设置`mjs`