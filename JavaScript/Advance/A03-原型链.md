对象有隐式原型`__proto__`, 用于查找对应属性和方法

函数作为特殊对象，除了有隐式原型，还存在显示原型`prototype`, 用于初始化实例对象的隐式原型对象





## 原型链

当我们查找属性或方法时

1. 先在对象自身查找
2. 不存在，去对象的隐式原型上查找
3. 不存在，去对象的隐式原型的隐式原型查找
4. 依次类推
5. 不存在，去Object的显示原型上查找
6. 不存在，Object的显示原型的隐式原型是null，查找结束，如果依旧不存在，返回undefined 「 此时调用方法就会报错 」



## 获取隐式原型

1. `__prtot__` 
   + 早期获取方法
   + 一般测试使用
   + 非标准属性
2. `getPrototypeOf`
   + 标准方法



### 显示原型

只有函数才有显示原型

显示原型的本质就是一个普通的对象

当通过new调用构造函数的时候，会将函数的显示原型赋值给实例的隐式原型对象

所以实例通用的属性和方法都可以放置到他们共同的隐式原型对象上，从而实现代码复用的目的



### 箭头函数

ES5中，任何函数都可以作为普通函数调用，也可以作为构造函数调用

ES6中，进行了拆分将其划分为了类和箭头函数

+ 箭头函数不能通过new调用，只能作为函数调用 『 箭头函数没有显示原型 』
+ 类只能通过new调用，不能通过函数调用 『 虽然类的本质依旧是function，但加了限制 』

其次，箭头函数内部没有this，arguments和super 



## constructor

原型对象上的一个属性，其值指向构造函数本身

`constructor`默认的属性描述符是 不可枚举，可配置，可修改的

`constructor`属性的作用是通过该属性找到显示原型对应的构造函数 「 确保构造函数和显示原型的配对 」

```js
function User(name) {
  this.name = name
}

console.log(User === User.prototype.constructor) // => true
```



我们可以通过`constructor`来进行类型检测

```js
function Person(name) {
  this.name = name;
}

const person1 = new Person('Alice');

// 通过实例的constructor属性可以直接获取其对应的构造函数
if (person1.constructor === Person) {
  // 这种方式并不可靠 「 constructor是可写属性，可能会被手动修改 」
  console.log('person1 是 Person的实例')
}

// 创建一个新的实例
const person2 = new person1.constructor('Bob');
console.log(person2.name); // "Bob"
```



如果我们整体修改了原型对象，需要手动设置`constructor`

```js
function User(name) {
  this.name = name
}

User.prototype = {
  running() {
    console.log('running')
  },

  eatting() {
    console.log('eatting')
  }
}

Object.defineProperty(User.prototype, 'constructor', {
  configurable: true,
  writable: true,
  value: User
})
```



### 原型继承关系图

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86c3736fda6f46e9a5fcfa72ac585d3e~tplv-k3u1fbpfcp-zoom-1.image) 

1. 任何函数都是 Function函数的实例对象，包括任何一个构造函数和Function函数本身

   因此``Function.prototype`和` Function.__proto__ `指向的是同一个对象

2. Object是所有对象的父类，包括Function对象和任何一个原型对象

3. 原型对象本质就是一个有`constructor`属性的对象，其也是Object的实例

4. 任何对象都有自己的隐式原型对象，任何函数对象都额外再有一个显示原型对象

5. 原型链的尽头是`Object.prototype`，`Object.getPrototypeof(Object.prototype)`的结果是`null`

6. `Object`是`Function`的父类，但是`Object`又是`Function`的实例

