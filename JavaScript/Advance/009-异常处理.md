## 使用场景

1. JavaScript是单线程的，一旦执行出错，整个进程就停止执行 「 捕获错误 」
2. 调用函数的时候，如果使用错误，希望给调用者对应的错误提示信息 「 抛出错误 」



## throw

1.  通过throw来抛出错误
2.  throw后边语句将停止执行
3.  throw后边跟表达式来表示具体的错误信息
4.  throw后可以跟的类型值有:
    + 基本类型值
    + 对象类型

```js
function foo() {
  console.log(1)
  throw { message: 'error msg', code: -1001 }
  // throw抛出异常后，throw表达式后边的代码将不在继续执行
  console.log(2)
  console.log(3)
}

foo()
```



为了统一开发过程中的错误信息格式，JavaScript提供了Error内置类，来方便我们创建错误信息



Error的实例对象包含以下三个属性：

| 属性名   | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| messsage | 创建Error对象时传入的message                                 |
| name     | Error的名称，通常和类的名称一致                              |
| stack    | 整个Error的错误信息，包括函数的调用栈<br />当我们直接打印Error对象时，打印的就是stack |



为了可以表示更为具体的错误信息，JS提供了Error的一些子类

| 子类        | 说明                           |
| ----------- | ------------------------------ |
| RangeError  | 下标值越界时使用的错误类型     |
| SyntaxError | 解析语法错误时使用的错误类型   |
| TypeError   | 出现类型错误时，使用的错误类型 |



## catch

默认情况下，错误会沿着调用者逐层传递，直到顶层

如果顶层依旧没有处理，就会在控制台输出错误信息，并终止代码的执行

我们可以使用`try-catch[-finally]`来捕获并处理异常

```js
function foo() {
  try {
    throw new Error('err msg')
  } catch(e) {
    console.log(e.message)
    return 'catch'
  } finally {
    // 无论是否存在异常，finally代码块都会被执行
    console.log('无论是否抛出异常，都会被执行的代码')

    // 因为finally代码块一定会执行
    // 所以finally代码块中的return语句会覆盖try或catch代码块中的return语句
    return 'finally'
  }
}

function bar() {
  const res = foo()
  console.log(res) // => finally
}

bar()
```

```js
function foo() {
  try {
    throw new Error('err msg')
  } catch { // catch代码块中如果不使用错误对象，错误对象可以省略
    console.log('发生了错误')
  } finally {
    console.log('无论是否抛出异常，都会被执行的代码')
  }
}

function bar() {
  foo()
}

bar()
```

