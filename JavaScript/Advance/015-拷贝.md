## 对象赋值关系

| 分类     | 说明                                           |
| -------- | ---------------------------------------------- |
| 引用赋值 | 指向同一个对象，相互之间会影响                 |
| 浅拷贝   | 只是浅层的拷贝，内部引入对象时，依然会相互影响 |
| 深拷贝   | 两个对象不再有任何关系，不会相互影响           |



### 浅拷贝

浅拷贝实现主要有两种方式:

1. 展开运算符
2. Object.assign方法



### 深拷贝

1. `JSON.parse/JSON.stringify` 
   + 不支持symbol，undefined，方法等JSON不支持的类型 
   + 无法处理循环引用
2. 使用`loadsh/underscore`等第三方库
3. 自己编写 「 JavaScript原生不支持 」



## 手动实现

```js
const user1 = {
  name: 'Klaus',
  friend: {
    name: 'Alex'
  }
}

// 产生循环引用
user1.self = user1

function isObject(property) {
  return (property !== null) && ['function', 'object'].includes(typeof property)
}

// 在deepClone的时候传入一个WeakMap实例
// 调用者调用deepClone方法的时候, 不需要传递第二个参数, 使用默认生成的Weakmap实例即可

// 在deepClone内部调用的时候,手动传入之前初始化生成的那个WeakMap实例，以确保deepClone方法
// 内部使用的WeakMap实例都是同一个
function deepClone(origin, map = new WeakMap()) {
  // 新建symbol
  if (typeof origin === 'symbol') {
    // 如果origin.description不存在，等价于Symbol(undefined), 返回值是symbol()
    return Symbol(origin.description)
  }

  // 基本数据类型 直接返回
  if (!isObject(origin)) return origin

  // 函数的功能是用于执行，不是存储值，所以函数直接复用
  if (typeof origin === 'function') {
    return origin
  }

  // 如果是Set类型 单独处理
  if (origin instanceof Set) {
    const set = new Set()

    for (const value of origin) {
      set.add(value)
    }

    return set
  }

  // 如果是Map类型 单独处理
  if (origin instanceof Map) {
    const map = new Map()

    for(const [key, value] of origin) {
      map.set(key, value)
    }

    return map
  }

  // 如果对象已经存在，则直接返回，没必要重复创建
  if (map.has(origin)) {
    return map.get(origin)
  }

  const obj = Array.isArray(origin) ? [] : {}

  // 每创建一个新对象，就在map上挂载一下
  map.set(origin, obj)

  // 默认情况下for-in只能迭代自身和自身原型链上可迭代的非Symbol属性
  for (const key in origin) {
    obj[key] = deepClone(origin[key], map)
  }

  // 对Symbol属性值单独迭代
  for (const sym of Object.getOwnPropertySymbols(origin)) {
    obj[Symbol(sym.description)] = deepClone(origin[sym], map)
  }

  return obj
}

const user2 = deepClone(user1)
console.log(user2)
console.log(user2.self === user2) // => true
```

