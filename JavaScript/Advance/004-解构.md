## 数组解构

```js
const arr = ['Klaus', 'Alex', 'Steven',  undefined, 'Jhon']

// 基本使用
const [name1, name2] = arr
console.log(name1, name2) // => Klaus Alex

// 数组的解构是有顺序的
// 如果某个数组元素项不需要解构，需要使用空位替代
const [user1, , user2] = arr
console.log(user1, user2) // => Klaus Steven

// 默认值
// 如果每个元素值为undefined的时候，就会使用传入的默认值
// 其余情况就使用元素本身的值
const [,,, username = 'default'] = arr
console.log(username) // => default

// 将解构出的元素放置到一个新的数组中
const [name, ...names] = arr
console.log(names) // => [ 'Alex', 'Steven', undefined, 'Jhon' ]

// 嵌套解构
const arr = [[1], [2], [3], [4]]
const [[num1], [num2], [num3]] = arr
console.log(num1, num2, num3) // => 1 2 3
```



## 对象解构

```js
const user = {
  name: 'Klaus',
  age: 24,
  address: 'shanghai'
}

// 基本使用
// 对象的解构是基于key，所以对象的解构没有顺序
const { name, address } = user
console.log(name, address) // => Klaus shanghai

// 重命名
const { age: userAge } = user // => 等价于 const userAge = user.age
console.log(userAge) // => Klaus
// console.log(age) // error

// 默认值
// 当解构出来的值为undefined的时候，就会使用默认值
const { gender = 'male' } = user
console.log(gender) // => male

// 将剩余key解构到一个新数组中
const {address: userAddress, ...userInfo} = user
console.log(userInfo) // => { name: 'Klaus', age: 24 }

// 嵌套解构
const user = {
  name: 'Klaus',
  age: 23,
  friend: {
    name: 'Alex'
  } 
}

const {friend: { name }} = user
console.log(name) // => Alex
```



解构利用的本质是可迭代的特性，所以所有可迭代对象本质都可以解构

```js
// 创建一个 Set 对象
const mySet = new Set([1, 2, 3, 4]);

// 解构 Set 对象
const [a, b, c, d] = mySet;

console.log(a); // 输出: 1
console.log(b); // 输出: 2
console.log(c); // 输出: 3
console.log(d); // 输出: 4
```

但原生对象不是可迭代的，之所以可以解构，是因为ES进行了特殊处理