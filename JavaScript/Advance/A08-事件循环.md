软件运行的时候至少存在一个或多个进程，其中最主要的那个被称之为主进程

每个进程中存在一个或多个线程，其中最主要那个被诚之为主线程



JavaScript的宿主环境是多进程的，但JavaScript是单线程的

例如： 浏览器每一个tab页签都是一个进程 「 一个页签卡死不影响别的页签 」

而每一个页签中都存在多个线程，如JavaScript线程，UI渲染线程，网络请求线程等



JavaScript是单线程的，所以JavaScript在同一时间内只能做一件事。如果遇到了耗时操作会交给其它线程处理。对应线程执行完毕后，再将结果告诉JavaScript主线程



1. 整个流程被称之为浏览器的事件循环
2. 这些需要交给其它线程执行的操作被称之为异步任务
3. 浏览器用于存放这些异步任务的队列被称之为事件队列

```js
console.log('定时器之前的代码')

// 虽然该定时器所需要等待的时候为0s, 但定时器是异步任务, 要交给其它线程处理
// 所以定时器的回调最后才会被执行
setTimeout(() => {
  console.log('定时器中的代码')
}, 0)

console.log('定时器之后的代码')
/*
  =>
    定时器之前的代码
    定时器之后的代码
    定时器中的代码
*/
```



浏览器中存在两个用于存放异步任务的队列

| 任务                          | 说明                                                   |
| ----------------------------- | ------------------------------------------------------ |
| 宏任务队列（macrotask queue） | ajax、setTimeout、setInterval、DOM监听、UI Rendering等 |
| 微任务队列（microtask queue） | Promise的相关回调、queueMicrotask等                    |



执行流程

1. 主线程代码先执行
2. 执行异步操作
   + 在执行每一个宏任务之前，必须确保微任务对象是空的
   + 只有微任务队列是空的时候，才可以执行对应宏任务



`示例`

`await` 表达式中的代码会被转换为Promise并被同步执行。

`await` 后面的代码会等这个Promise实例的状态变为resolved的时候才会被执行。

```js
console.log('start');

await Promise.resolve().then(() => console.log('promise3'));

console.log('end');

/*
  start
  promise3
  end
*/
```



在上述示例中

```js
await Promise.resolve().then(() => console.log('promise3'));

console.log('end');
```

等价于

```js
Promise.resolve()
  .then(() => console.log('promise3'))
	.then(() => console.log('end'))
```


