面向对象 简写 OOP ( Object-oriented programming )

1. OOP是一种编程思想
2. 对象 就是 有 属性和方法的 数据结构
3. 面向 就是 使用 --- 面向对象 就是 使用对象进行开发
4. 面向对象 就是 根据事物共性 抽取 类 --- 实际使用的是 类的实例



类 可以理解为  是一种 特殊的 自定义的 数据类型，用于抽取事物之间的公共特性



有时，不同类之间存在着共同的属性或方法，我们可以创建一个共同的父类或基类，

并让其他子类或派生类从这个父类继承，以实现代码的复用和维护对象之间的层次关系



JS中 类和实例 是通过原型链机制来实现的



面向有三大特性

1. 封装
2. 继承
3. 多态



## 封装

把一段需要重复执行的代码 使用函数或类 包裹起来 形成一个整体

在需要重复执行的时候，直接调用函数或类即可

从而避免了重复代码的执行，提升代码内聚性，减低耦合性



## 多态

多态 = 重载 + 重写



### 重载

1. 多个同名方法
2. 形参的个数或类型不一致

```java
// 参数个数不一致 构成重载
public sum(int x) {}
public sum(int x, int y) {}

// 参数类型不一致 构成重载
public add(int x, int y) {}
public add(int x, float y) {}
```

重载的目的是 

将原本位于一个函数中的业务逻辑，根据参数的不同，划分到不同的代码块中，减低业务复杂度，增加函数的并发处理能力 和 可维护性



前端没有真正意义上的重载，因为存在变量提升，后边同名定义会覆盖前面的同名定义

```js
function sum(num1, num2) {
  return num1 + num2
}

function sum(num1 + num2 + num3) {
  return num1 + num2 + num3
}

console.log(sum(10, 20)) // => NaN
console.log(sum(10, 20, 30)) // => 60
```



JavaScript 有宏观意义上的重载

1. 同一个方法
2. 根据不同的参数 执行不同的逻辑

```js
function sum(x, y, z) {
  /* 
  	判断参数不同的方式有
  	1. arguments
  	2. 剩余参数
  	3. 参数值是否是undefined
  */
  if (y === undefined && z === undefined) {
    return x * 2
  } else if (z === undefined) {
    return x + y
  } else {
    return x * y + z
  }
}
```



### 重写

1. 存在继承
2. 子类和父类 存在 同名方法
3. 子类 实现自己的同名方法 --- 覆盖了父类的同名方法



## 继承

子类继承父类，子类就拥有了父类中的属性和方法

从而 子类的实例 就可以使用 父类中定义的属性和方法



### 原型继承

父类原型 位于 子类实例的原型链上

```js
function Parent(parent) {
  this.parent = parent
}

Parent.prototype.parentCall = () => console.log('parent call')

function Child(child) {
  this.child = child
}

// 子类在挂载方法前
// 1. 子类原型 指向 父类实例
// 2. 原型重定向后 添加constructor属性 保证 原型完整性
Child.prototype = Object.create(new Parent('parent'), {
  constructor: {
    value: Child,
    writable: true,
    configurable: true,
  }
})

Child.prototype.childCall = () => console.log('child call')

const child = new Child('child')

console.log(child.parent) // => 'parent'
console.log(child.child) // => 'child'
child.parentCall() // => 'parent call'
child.childCall() // => 'child call'
console.log(Child.prototype.constructor) // => [Function: Child]
```

