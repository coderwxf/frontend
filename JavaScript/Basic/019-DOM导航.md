JavaScript 可以分为以下三个部分：

1. **ECMAScript**：基础语法
2. **DOM**：操作网页文档
3. **BOM**：操作除网页文档外的其它浏览器元素

所谓基础语法，即使构成JavaScript的基本组成部分，这部分在不同宿主环境中都是通用的，而DOM和BOM仅存在于浏览器中



BOM和DOM本质就是两个存在于window上的对象

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e331636132ef4966bd922be7cfa4ca03~tplv-k3u1fbpfcp-zoom-1.image) 

# DOM

浏览器解析HTML文档的时候，会并为每一个HTML元素生成对应的DOM对象

这一过程被称之为构建DOM。

DOM对象和HTML元素是同步的，也就是说，通过JavaScript操作DOM对象，HTML元素会相应地发生改变。

由于HTML文档是树状结构，生成的DOM对象也会形成相应的树结构，这棵树被称之为DOM树。

所以DOM得本质是为了获取HTML元素，然后在JavaScript中对这个元素进行操作



### Document

整个文档被抽象到 document 对象中，也就是说document对象是整个DOM的入口对象，可以从document开始去访问任何节点元素

```js
// 访问文档的根节点
console.log(document.doctype) // <!DOCTYPE html>
console.log(document.documentElement); // <html> 元素
console.log(document.body); // <body> 元素
console.log(document.head); // <head> 元素
```



## DOM继承 

在 DOM 中，不同的 HTML 元素被抽象成不同的类，例如 `HTMLLIElement` 表示 `<li>` 元素，`HTMLDivElement` 表示 `<div>` 元素等

这些类都有一个共同的父类 `HTMLElement`，进一步继承自 `Element`，最终继承自 `Node`。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1382d797f5e54075a1887f6b30e87eec~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp) 





### 节点和元素

**节点**

1. Node的实例对象
2. 包括了文本节点，注释节点，元素节点等

> 在DOM中，节点是包裹元素，注释和文本在内的，
>
> 所以html结构中的换行也可能会被识别为一个单独的节点(Text)
>
> 此外获取文本内容的时候，其往往也是加上换行的



**元素**

1. Element的实例
2. 元素是节点的一个部分



在 JavaScript 中，`document` 对象是一个全局对象，代表整个 HTML 文档

我们可以通过 `document` 对象访问和操作 HTML 文档的各个部分

例如 `document.body` 可以获取到 `body` 元素。

但这并不意味着body是document的子类，只能说body是document对象的一个属性，仅此而已

例如，我们可以创建一个普通对象 `obj`，并通过 `obj.name` 访问其属性，但name不是obj的子类



HTML文档结构是树形的，对应的DOM（文档对象模型）树也具有相同的树形结构。在DOM树中，如果多个节点拥有相同的父节点，它们就是兄弟节点，表示它们在实例层面上是并列关系。

然而，类与类之间不存在“兄弟类”这一概念。类之间的关系通常表现为继承、实现接口或共享某些属性和方法，但这并不形成类似于实例之间的兄弟关系。因此，兄弟节点之间的关系仅存在于实例层面，而与类之间的关系无关。

例如: 虽然Document和Element都直接继承自Node 类，但并不意味着Document和Element是兄弟关系

例如学生和老师都可以直接继承自Person类，但是并不意味这学生和老师这两个类一定要存在兄弟关系



## 节点导航

节点导航是指通过一个节点访问其他相关节点的过程



### **节点导航**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb490fb880e64521bbf03e166d822f23~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp) 



### **元素导航**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d68507220a534a989b796c3b13aab08b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp) 



### **表格导航**

基本结构

```html
<table>
  <thead>
    <tr>
      <td>id</td>
      <td>name</td>
      <td>count</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>001</td>
      <td>mackbook</td>
      <td>112</td>
    </tr>
    <tr>
      <td>101</td>
      <td>iphone</td>
      <td>122</td>
    </tr>
  </tbody>
</table>
```



获取表单

```js
// 获取table元素
const tableEl = document.body.firstElementChild
```

`firstElementChild`只能知道是`HTMLElement`, 无法准确知道是`HTMLTableElement`

所以对表单而言，属性提示可能不全，此时可以临时借用TypeScript的类型断言来提升VSCode的代码提示功能

```ts
const tableEl = document.body.firstElementChild as HTMLTableElement
```

但是类型断言毕竟是TypeScript功能，所以在实际调试时需要移除后，才能被浏览器所识别



表单的`caption`,`thead`等，都是表单的标准子元素，所以抽象成了表格DOM元素的直接属性

但又一个特例是`tbody`, 因为理论上`tbody`是可以存在多个的，虽然正常情况下就一个，

所以对于`tbody`的获取是通过`tbodies[0]`来获取的

```js
console.log(tableEl.caption) // => null
console.log(tableEl.tHead) // => thead元素
console.log(tableEl.tBodies) // => HTMLCollection [tbody]
console.log(tableEl.tFoot) // => null
```



表格是由td和tr组成的，所以他们也是表单元素的直接属性

```js
// 获取所有行
console.log(tableEl.rows) // => HTMLCollection(3) [tr, tr, tr]

// 获取第三行
 const tr = tableEl.rows[2]
 
 // 获取第三行中所有td元素
 console.log(tr.cells) // => HTMLCollection(3) [td, td, td]
```

```js
// rowIndex -- 当前是表格中的第几行 -- 索引从0开始统计
console.log(tr.rowIndex) // => 2

// 将thead和tbody中的元素分开成两个section
// sectionRowIndex 表示是在当前thead或tbody中是第几行
// rowIndex 是在整个表单元素中是第几行
console.log(tr.sectionRowIndex) // => 1

const td = tr.children[2]

// cellIndex -- 是当前行的第几个单元格 -- 索引从0开始统计
console.log(td.cellIndex) // => 2
```



### 表单导航

基本结构

```html
<form id="myForm">
  <input type="text" id="user" name="username" value="JohnDoe">
  <input type="password" name="password" value="12345">
  <input type="checkbox" name="subscribe" checked>
  <select name="fruits">
    <option value="apple">Apple</option>
    <option value="orange">Orange</option>
  </select>
</form>
```



表格是标准元素，可以直接通过`document.forms`获取所有表单元素

使用document.forms获取的表单具有更为具体的类型 --> `HTMLFormElement`

```js
console.log(document.forms) // 输出值是HTMLCollection

/*
  输出结果的伪数组如下
	[
    0: form#myForm,
    myForm: form#myForm,
    length: 1
	]
*/
```

所以既可以通过索引0去获取表单元素，也可以通过id值`myForm`来获取表单元素

```js
const form = document.forms['myForm'];
```



可以通过`elements`属性获取表单中所有的表单组件

```js
const elements = form.elements // HTMLFormControlsCollection 是 HTMLCollection的子类

/*
	[
    0: input#user,
    1: input,
    2: input,
    3: select,
    fruits: select,
    password: input,
    subscribe: input,
    user: input#user,
    username: input#user,
    length: 4
	]
*/
```

所以如果要获取`<input type="text" id="user" name="username" value="JohnDoe">`

即可以通过索引`elements[0]`

也可以通过 name属性，即`element.username`

也可以通过id属性，即`element.user`

```js
const username1 = elements['username'];
const username2 = elements[0];
const username3 = elements['user'];

console.log(username1 === username2) // true
console.log(username2 === username3) // true
```



value，type，name这种是元素标准属性，所以也会是DOM节点的直接属性

```js
const username = elements['username'];

console.log(username.value); // JohnDoe
console.log(username.name); // username
console.log(username.id); // user
console.log(username.type); // text
```



`value`: 字符串类型属性，适用于所有 `<input>` 元素类型，包括 `checkbox`。

`checked`: 布尔类型属性，专门用于 `checkbox` 和 `radio` 类型的 `<input>` 元素



`value`和`checked` 都是标准属性，会作为对应DOM节点的直接属性被挂载

```js
const subscribe = elements['subscribe'];

console.log(subscribe.checked); // true
```



## 元素获取

获取元素的方式有两种:

1. 通过元素导航
2. 通过API直接获取

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83c7286574dc41e2a37d9c55d0f79eff~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)



获取一个节点或元素，如果没有获取到的时候，返回的结果都是nul

如果获取一系列的节点或元素的时候，如果没有获取到的时候，返回的是一个类空数组对象



### NodeList VS HTMLCollection

`NodeList`不是实时的，`HTMLCollection`是实时的

除了`getElementById`不是实时的「 因为它获取的永远都是一个元素 」,

其余`getElementByXxxx` 都是实时的，即获取结果是`HTMLCollection`

```js
const ulEl = document.getElementById('ul')
const liEls = document.querySelectorAll('li')
const liList = document.getElementsByTagName('li')

console.log(liEls) // => NodeList(3) [li, li, li]
console.log(liList) // => HTMLCollection(3) [li, li, li]

setTimeout(() => {
  ulEl.innerHTML = `${ulEl.innerHTML} <li>4</li>`
  console.log(liEls) // => NodeList(3) [li, li, li]
  console.log(liList) // => HTMLCollection(4) [li, li, li, li]
}, 2000)
```



`NodeList`和`HTMLCollection`是两个伪数组对象, 且都是可迭代对象，所以可以使用`for-of`循环

`NodeList`上单独实现了`forEach`方法，而`HTMLCollection`上没有单独实现`forEach`方法



### `querySelector` 和 `querySelectorAll`

+ `querySelector`获取到的是第一个符合条件的元素
+ `querySelectorAll`获取到的是所有符合条件的元素
+ `querySelector` 和 `querySelectorAll`和`getElementsByTagName`是唯一几个支持通配符选择器的方法



 



