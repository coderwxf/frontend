![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32aba40bc5b24fbd910b0dbd863ac642~tplv-k3u1fbpfcp-zoom-1.image)

```js
// 字面量形式创建数组
const arr1 = [] // => []

// 构造函数方式创建数组 => 数组本身也是一种特殊的对象

// 在使用Array构造函数的时候 new可以省略 但是并不被推荐
// new Array() === Array()
const arr2 = new Array() // => []

const arr3 = new Array(3) // => [empty * 3] --- 生成一个长度为3的初始化数组

const arr4 = new Array(3, 4, 5) // => [3, 4, 5] --- 生成数组并赋初始化值
const arr5 = new Array('3') // => ['3'] 
```

有empty元素的数组被称之为稀疏数组「空位数组」，在对数组迭代时，迭代方法会自动跳过empty元素「稀疏元素，空位元素」

反之没有empty元素的数组被称之为密集数组



直接使用`Array`构造函数创建存在历史遗留问题，所以通过构造方法创建数组时，可以使用`Array.of`方法

```js
console.log(Array.of(7)); // 输出: [7] (一个包含单个元素7的数组)
console.log(Array.of(1, 2, 3, 4)); // 输出: [1, 2, 3, 4]
console.log(Array.of()); // 输出: []
```



```js
const users = ['Klaus', 'Alex', 'Steven']

// 数组元素从 0 开始编号(索引 index)
console.log(users[0]) // Klaus

// 数组存在属性length 记录着数组对应的长度
console.log(users[users.length - 1]) // Steven

// 访问数组元素
console.log(users[1]) // => Alex
// 如果数组取值越界, 那么直接返回undefined
console.log(users[-1]) // => undefined
console.log(users[22]) // => undefined

console.log(users.at(1)) // => Klaus
console.log(users.at(-1)) // => Steven --- at方法支持负值
console.log(users.at(33)) // => undefined --- 如果 i >= 0，则与 arr[i] 完全相同
```



```js
let users = ['Klaus', 'Alex', 'Steven']

// 修改数组元素
users[1] = 'Jhon'
console.log(users) // => [ 'Klaus', 'Jhon', 'Steven' ]

users = ['Klaus', 'Alex', 'Steven']

// 新增数组元素（不推荐 推荐使用方法新增数组元素）
users[users.length] = 'Jhon'
console.log(users) // => [ 'Klaus', 'Alex', 'Steven', 'Jhon' ]

users[15] = 'Peter'
console.log(users) // => [ 'Klaus', 'Alex', 'Steven', 'Jhon', empty * 11, 'Peter' ]

// 清空数组
users.length = 0
console.log(users) // => []

users = ['Klaus', 'Alex', 'Steven']

// 删除数组元素(不推荐，推荐使用方法删除数组元素)
delete users[1]
console.log(users) // => [ 'Klaus', empty * 1, 'Steven' ]
```



```js
let users = ['Klaus', 'Alex', 'Steven']

// 在数组末尾添加元素
// 添加元素 可以一次添加一个 也可以一次添加多个
// push方法的返回值为修改后数组的个数
// push方法会修改原数组 - 非纯函数
users.push('Jhon')
users.push('Alice', 'Peter')

console.log(users)

users = ['Klaus', 'Alex', 'Steven']

// 在数组末尾移除元素
// 一次只能移除一个
// pop方法的返回值为移除的那个元素
// pop方法会修改原数组 - 非纯函数
users.pop()

console.log(users)
```



```js
let users = ['Klaus', 'Alex', 'Steven']

// 在数组头部添加元素
// 添加元素 可以一次添加一个 也可以一次添加多个
// unshift方法的返回值为修改后数组的个数
// unshift方法会修改原数组- 非纯函数
users.unshift('Jhon')
users.unshift('Alice', 'Peter')

console.log(users)

users = ['Klaus', 'Alex', 'Steven']

// 在数组头部移除元素
// 一次只能移除一个
// shift方法的返回值为移除的那个元素
// shift方法会修改原数组 - 非纯函数
users.shift()

console.log(users)
```

`shift`和`unshift`是在数组头部进行元素的增删，所以其在添加或移除元素后，需要进行数组的整体移动

而`pop`和`push`方法是直接在数组尾部进行元素的增删，其不需要进行数组的整体移动

所以`pop`和`push`的性能和执行速度相比`shift`和`unshift`更优，也更快



```js
let users = ['Klaus', 'Alex', 'Steven']

// splice方法不是纯函数，会修改原数组 - 非纯函数
// 参数1 - 从start位置开始，处理数组中的元素
// 参数2 - deleteCount:要删除元素的个数，如果为0或者负数表示不删除
// 参数3 - item1, item2, ...:在添加元素时，需要添加的元素
// 返回值 - 被删除元素组成的数组，如果没有删除元素，就返回空数组

// 删除元素
users.splice(1, 1) // => [ 'Klaus', 'Steven' ]

users = ['Klaus', 'Alex', 'Steven']

// 新增元素
users.splice(1, 0, 'Jhon') // => [ 'Klaus', 'Jhon', 'Alex', 'Steven' ]

users = ['Klaus', 'Alex', 'Steven']

// 替换元素
users.splice(1, 1, 'Peter') // => [ 'Klaus', 'Peter', 'Steven' ]
```



```js
const arr = ['Klaus', 'Alex', 'Steven']

// slice方法返回截取后的新数组 - 纯函数
console.log(arr.slice(1)) // => [ 'Alex', 'Steven' ]

// concat方法用于数组的拼接
const arr1 = ['Klaus', 'Steven']
const arr2 = ['Alex', 'Jhon']
const arr3 = ['Peter']

// push方法不会自动展开
// arr1.push(arr2)
// console.log(arr1) // => [ 'Klaus', 'Steven', [ 'Alex', 'Jhon' ] ]

// 数组的concat是纯函数，参数是任意类型的可变参数
// 如果参数是数组，会自动展开 - 只展开一层
const newArr = arr1.concat(arr2, arr3, 'May')
console.log(arr1) // => [ 'Klaus', 'Steven' ]
console.log(newArr) // => [ 'Klaus', 'Steven', 'Alex', 'Jhon', 'Peter','May' ]

// join方法 将数组安装参数拼接为一个字符串，默认的拼接符为逗号
console.log(arr.join('-')) // => Klaus-Alex-Steven
```



```js
const arr = ['Klaus', 'Alex', 'Klaus', 'Steven']

// indexOf lastIndexOf includes 方法的使用和字符串中对应方法的使用方式是完全一致的
// indexOf lastIndexOf includes 方法只适合于基本数据类型的查找，不适合引用类型查找
console.log(arr.indexOf('Klaus')) // => 0
console.log(arr.indexOf('Alex', 2)) // => -1

console.log(arr.lastIndexOf('Klaus')) // => 2
console.log(arr.includes('Klaus')) // => true
```



数组中的大多数高阶方法都支持传入两个参数：

1. 回调函数，回调函数的参数通常为`数据项`、`索引`、`数组本身`。
2. thisArg，用于指定回调函数内部的`this`指向。如果不指定`thisArg`，则回调函数的`this`默认遵循独立函数调用规则

> 是大多数，不是全部，例如`reduce`就不符合这个规则



```js
const books = [
  {
    name: '《算法导论》',
    price: 85.00
  },
  {
    name: '《UNIX编程艺术》',
    price: 59.00
  },
  {
    name: '《编程珠玑》',
    price: 39.00
  }
]
// 如果回调函数返回true, 那么find 和 findIndex 就会终止查找 并将对应结果返回

// find 找到符合条件元素 --- 找到返回对应元素，找不到返回undefined
console.log(books.find(book => book.price === 59))

// findIndex 找符合条件的元素的索引值 -- 找到返回对应的索引值，找不到返回-1
console.log(books.findIndex(book => book.price === 59))

// reverse() 方法将数组中元素的位置颠倒，并返回该数组 - 非纯方法
console.log(books.reverse())
```



```js
let arr = [10, 2, 5, 1, 9];

// sort对数组进行排序，并返回一个排序后的新数组 - 非纯函数
// 回调返回值大于0，则交互元素，返回值小于等于0时，则不交换
console.log(arr.sort((a, b) => a - b)) // => [ 1, 2, 5, 9, 10 ]

arr = [10, 2, 5, 1, 9]
// 回调返回值永远大于0，永远不交换，返回原数组
console.log(arr.sort(() => 1)) // => [ 10, 2, 5, 1, 9 ]

arr = [10, 2, 5, 1, 9]
// 回调返回值永远小于0, 永远都交换 「 类似于调用 reverse 方法 」
console.log(arr.sort(() => -1)) // => [ 9, 1, 5, 2, 10 ]
```



```js
const arr = new Array(3)

// fill方法用于填充数组 - 非纯函数
arr.fill(3)
console.log(arr) // => [ 3, 3, 3 ]
```



```js
let nums = [23, 34, 454, 3423, 123]

// map() 用于进行数组映射 - 纯函数
console.log(nums.map((item, index, arr) => item * item))

// filter() 用于过滤数组 - 纯函数 「 返回值为true的数据项才会被留下 」
console.log(nums.filter((item, index, arr) => item % 2 === 0))

// reduce的第一个参数为callback, 第二个参数为initalValue
// 1. 如果设置了initalValue
//    + 那么第一次执行的preV的值即为initalValue，item为nums[0]
//    + 第二次执行的时候，preV为上一次callback的返回值，item为nums[1]
//  依次类推，如果全部遍历完毕，那么就直接将callback的返回值作为reduce方法的返回值进行返回

// 2. 如果没有设置initalValue
//    + 那么第一个执行的preV的值为nums[0], item的值为nums[1]
//    + 第二次执行的preV的值为上一次callback的返回值，item的值为nums[2]
// 依次类推，如果全部遍历完毕，那么就直接将callback的返回值作为reduce方法的返回值进行返回

// 所以reduce方法一般可以用来做数组的累加操作 - 纯函数
// reduce的回调参数是 前一项，当前项，索引，数组本身
console.log(nums.reduce((preV, item, index, arr) => preV + item, 0))
```



```js
const nums = [10, 30, 45, 223]

// every 每一项都符合条件才返回true
console.log(nums.every(num => num % 2 === 0)) // => false

// some 只要有一项符合条件就返回true
console.log(nums.some(num => num % 2 === 0)) // => true
```



```js
const nums = ['1-1', '1-2', ['2-1', '2-2'], [['3-1', '3-2'], ['3-3', '3-4']]]

// 参数默认值为1
console.log(nums.flat()) // => [ '1-1', '1-2', '2-1', '2-2', [ '3-1', '3-2' ], [ '3-3', '3-4' ] ]

console.log(nums.flat(2))
/*
  =>
    [
      '1-1', '1-2',
      '2-1', '2-2',
      '3-1', '3-2',
      '3-3', '3-4'
    ]
*/

// 超出最大深度 就按照最大深度进行平铺
console.log(nums.flat(3))
/*
  =>
    [
      '1-1', '1-2',
      '2-1', '2-2',
      '3-1', '3-2',
      '3-3', '3-4'
    ]
*/
```



```js
const msgs = ['Hello Wolrd', 'Klaus', 'Hello EcmaScript 2022']

console.log(msgs.flatMap(item => item.split(' '))) // => [ 'Hello', 'Wolrd', 'Klaus', 'Hello', 'EcmaScript', '2022' ]

// 上述操作等价于
console.log(msgs.map(item => item.split(' ')).flat())
```



## 解构

JavaScript可以对对象或数组中进行解构操作

```js
const arr = ['Klaus', 'Alex', 'Steven',  undefined, 'Jhon']

// 基本使用
const [name1, name2] = arr
console.log(name1, name2) // => Klaus Alex
```



数组的解构是有顺序的， 如果某个数组元素项不需要解构，需要使用空位替代

```js
const arr = ['Klaus', 'Alex', 'Steven',  undefined, 'Jhon']

const [user1, , user2] = arr
console.log(user1, user2) // => Klaus Steven
```



如果每个元素值为undefined的时候，就会使用传入的默认值，其余情况就使用元素本身的值

```js
const [,,, username = 'default'] = arr
console.log(username) // => default
```



展开运算符接收一系列值，并转换为数组

```js
const arr = ['Klaus', 'Alex', 'Steven',  undefined, 'Jhon']

const [name, ...names] = arr
console.log(names) // => [ 'Alex', 'Steven', undefined, 'Jhon' ]
```



```js
// 嵌套解构
const arr = [[1], [2], [3], [4]]
const [[num1], [num2], [num3]] = arr
console.log(num1, num2, num3) // => 1 2 3
```

