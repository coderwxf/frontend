```js
// 变量声明
let userName
// 变量赋值
userName = 'Klaus'

// 声明同时直接赋值
let user = 'Klaus'

// 同时定义多个变量并赋值
let name = 'Klaus', age = 18

// 同时给多个变量赋相同的值
let name = userName = 'Klaus'
```

+ 如果一个变量未声明(declaration)就直接使用，那么会报错
+ 如果一个变量有声明，但是没有赋值，那么默认值是undefined，也就是说变量的默认值是undefined
+ 使用var声明的变量，本质是一个全局变量，会被自动挂载到globalThis上 --- 不推荐
+ 不使用var/let/const也可以声明一个变量，这种变量本质也是一个全局变量，且这种变量被称之为隐式全局变量 --- 不推荐



## let/const

在ES5中我们声明变量都是使用的`var`关键字, ES6开始通过`let、const` 来声明变量

`const`定义常量，但只限制栈内存变量对应地址不可修改，并不限制堆内存中存储的属性不可修改

```js
const user = {
	name: 'Klaus'
}

user.name = 'Steven'
console.log(user.name) // => Steven
```



`let/const`的特点:

1. 同一作用域内不能重复声明同名变量

   ```js
   var name = 'Klaus'
   let name = 'Klaus' // error 
   ```

   只要当前作用域对应词法环境中「 无论是哪一种环境记录 」只要存在同名变量，就不能再声明同名变量

   

2. let 和 const 存在作用域提升，但是也存在TDZ ( 暂时性死区 Temporal Dead Zone)

   ```js
   let msg = 'global msg'
   
   function foo() {
     console.log(msg) // error -> msg在foo函数内部形成了TDZ
     let msg = 'foo msg'
   }
   ```

   

   TDZ的本质是不允许在声明变量之前就使用变量，所以TDZ和代码编写位置没有任何关系，而是和运行代码时对应变量是否有被显示声明有关 「 是运行时TDZ 不是 词法TDZ 」

   ```js
   setTimeout(() => {
     // 虽然这行代码编写在变量声明之前, 但代码执行时变量a已被声明，所以可以正常打印变量a的值
     console.log(a) // => 112
   })
   
   let a = 112
   ```

   

3. let 和 const 声明的变量位于声明式环境记录，var声明的变量位于对象式环境记录 「 全局对象环境记录就是globalThis 」，所以var声明的变量会被挂载到globeThis上，而let和const不会

   ```js
   var msg = 'var variable'
   let username = 'Klaus'
   
   function foo() {
     debugger
   }
   
   foo()
   ```

   ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcaddf047045459cac225c7f72dea952~tplv-k3u1fbpfcp-zoom-1.image) 

   

4. 在ES6中，通过let、const、function、class声明的标识符具备块级作用域



## 块级作用域

在ES6之前 只有全局作用域和函数作用域，ES6及以后，新增了一种新的作用域 即块级作用域

在ES6中，通过let、const、function、class声明的标识符具备块级作用域

```js
{
  // 这是块级作用域 --- 只要大括号中编写的是代码，就形成代码块，并存在块级作用域
}

let age = 23
if (age > 18) {
  // 这是块级作用域
}

const num = 10
for(let i = 0; i < num; i++) {
  // 这是块级作用域
}

function foo() {
  // 这是块级作用域 --- 函数作用域可以看成是一种特殊的块级作用域
}
```



如果执行代码块，不会开启一个新的执行上下文，而是为当前活跃执行上下文关联一个单独的词法环境

```js
var msg = 'global msg'
const name = 'Klaus'
function foo() {}

{
  var height = 1.88
  let address = 'shanghai'
}
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4869a02f19a74318a77a32617b8f4960~tplv-k3u1fbpfcp-zoom-1.image) 



当代码块执行完毕后，会销毁代码块对应的词法环境,  所以代码块中声明的变量在代码块外无法被访问

```js
{
  const name = 'Klaus'
  let age = 23
  class Person {}
  var address = 'shanghai'
}

// var没有块级作用域，无视代码块，所以挂载到了全局执行上下文对应的对象式环境记录上
console.log(address) // => shanghai

// 对应的声明式词法环境记录已被移除，因此无法操作对应变量
console.log(name) // error
console.log(age) // error
const per = new Person() // error
```

```js
function foo() {
  // var虽然不认块级作用域，但认函数作用域
  // 这里的age被挂载到了函数执行上下文对应的对象式环境记录
  // 所以当foo执行完毕后，在外部无法访问变量age
  var age = 23
  console.log('inner', age)
}

foo()

console.log('outer', age)
```



函数是个特例，在非严格模式中，函数声明会被提升到代码块的顶部，并且可以在代码块后访问。

「 代码块前无法访问，因为函数只提升到了代码块的顶部，而不是全局的顶部 」

```js
// 代码块前，无法调用代码块中声明的函数
// foo() // error

{
  function foo() {
    console.log('foo')
  }
 }

// 代码块外可以访问代码块中定义的函数
foo()
```



在严格模式下，函数声明会严格遵守块级作用域。函数只在其所在的块内是可访问的。代码块外部无法访问该函数。

```js
// 使用use strict字符串开启严格模式
// 单引号和双引号都可以，但是不支持反引号
'use strict'

// 代码块前，无法调用代码块中声明的函数
// foo() // error

{
  function foo() {
    console.log('foo')
  }
 }

foo() // error
```

