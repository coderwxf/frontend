运算符分类:

+ 算术运算符
+ 赋值运算符
+ 关系(比较)运算符
+ 逻辑运算符



`2 + 3`中，`+`是运算符，2和3是运算元或叫运算目或操作数

所以按照运算元进行划分可以分为

1. 一元运算符
2. 二元运算符
3. 三元运算符



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a179968679c04299bf6fbd338b3cd400~tplv-k3u1fbpfcp-zoom-1.image) 

`a ** b`运算符等价于`Math.pow(a, b)`



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/976dce817dfc47c0abd7ee8700e2885f~tplv-k3u1fbpfcp-zoom-1.image) 

```js
let userName = nickName = 'Alex'

/*
	等价于
	1. nickName = 'Alex'
	2. let userName = 'Alex'
*/
```



对于普通赋值运算符，其所赋的值，会作为整个语句的返回值

```js
console.log(num = 2) // => 2
```



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f742a5826494502a08915976e57cad6~tplv-k3u1fbpfcp-zoom-1.image)

比较运算符的结果都是Boolean类型值

+ `==`  --- 相等，`!=` --- 不等 ==> 比较时存在隐式类型转换规则
+ `===` --- 严格相等 或叫 全等，`!==` --- 严格不相等 或叫 不全等 ==> 比较时不存在隐式类型转换



**相等的比较规则**

1. 如果两个值类型相同，直接比较。

2. 如果一个值是`null`，另一个是`undefined`，它们被认为是相等的

3. 如果一个值是null，另一个值不是undefined 或 null，它们被认为是不等的 

   「 不是转number  --- null被作为一种特殊对象进行处理 」

4. 如果一个值是对象，另一个是原始类型，对象会转换为原始类型后再进行比较

5. NaN 与任何值都不相等，包括它自己

6. 其余情况，转换为数值类型后再比较

```js
console.log(0 == null) // => false

console.log(null == null) // => true
console.log(null == undefined) // => true
```



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba8ae88facf477b938566d02021e3dc~tplv-k3u1fbpfcp-zoom-1.image) 

逻辑运算符的每个操作数都会先转换为布尔值后再判断

+ 逻辑或返回第一个假值对应原始值「不是布尔值」，全为真，返回最后一个操作数对应原始值

+ 逻辑或返回第一个真值对应原始值，全为真，返回最后一个操作数对应原始值

```js
console.log('' && 2 + 3) // => ''
console.log(1 + 1 && 2 + 3) // => 5

console.log(2 + 3 || '') // => 5
console.log('' || 4 + 6) // => 10
```



逻辑或可以用于设置默认值

```js
let userName = nickName || 'Alex'
```

但这么设置有一个问题是，所有falsy的值都会触发默认值，但一般只有变量值为undefined或null时，才需要触发对应默认值，所以更严谨的写法其实是

```js
let userName = ['null', 'undefined'].includes(nickname)
```

ES11中提供了空值合并运算符，其本质是上边写法对应的语法糖写法

```js
let userName = nickName ?? 'Alex'
```

在本例中，只有nickName的值是undefined和null时，才会触发对应默认值



逻辑与可以用来判断对象有值时才去调用对应属性或方法

```js
user && user.running && typeof user.running === 'function' && user.running()
```

但这么写法过于复杂，为此ES11提供了可选链操作符来简化这种写法

```js
user?.running?.()
```



可选链运算符可以用于以下几种情况

```js
user?.age
user?.friends?.[0]
user?.running?.()
```



```js
let str = 'Hello World'

// 转Boolean值
// 方式一
console.log(Boolean(str)) // => true

// 方式二
console.log(!!str) // => true
```



在 JavaScript 中，逻辑运算符 `与`、`或` 和 `非` 的优先级从高到低依次为：

1. **非 (`!`)**：最高优先级。
2. **与 (`&&`)**：次高优先级。
3. **或 (`||`)**：最低优先级。

```js
// 1. !4 => false
// 2. false % 2 ---> 0 % 2 => 0
// 注意:「 0 / 2 => 0 」 并且 「 0 % 2 => 0 」
console.log(!4 % 2) // => 0

console.log(!(4 % 2)) // => true

// 1. !5 => false
// 2. 2 && 3 => 3
// 2. false || 3 => 3
console.log(!5 || 2 && 3) // => 3
```

