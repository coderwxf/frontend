数组是一种有序的集合，元素按照插入的顺序排列。

通过索引可以方便地访问和操作数组中的元素。

+ 数组的索引值是从 0 开始的
+ 如果要访问数组的最后一个元素，可以使用 `array.length - 1` 这种方式
+ JavaScript 不支持通过负数索引访问元素



数组是一种数据结构，同时也是一种对象类型。数组有自己的构造函数，即 `Array`

我们可以通过字面量和构造函数两种方式来创建数组。

```js
let arr1 = [1, 2, 3]; // [1, 2, 3]

let arr2 = new Array(); // []

let arr3 = new Array('a', 'b', 'c'); // ['a', 'b', 'c']
```

```js
let arr1 = new Array(5); // [empty * 5]

let arr2 = new Array('5'); // ['5']
```

有empty元素的数组被叫做稀疏数组，否则就是密集数组

数组在迭代时，会自动跳过empty元素「 稀疏元素 」



**访问元素**

访问数组中的元素可以通过索引来实现：

```javascript
console.log(names[0]); // 输出 "abc"
```

除了使用中括号访问元素外，还可以使用 `at` 方法：

```javascript
console.log(names.at(0)); // 输出 "abc"
console.log(names.at(-1)); // 输出 "nba"
```

`at` 方法支持负数索引，从数组末尾开始计数。



**新增元素**

向数组中新增元素，可以通过以下方法：

```javascript
names.push("xyz");
console.log(names); // 输出 ["abc", "wzy", "nba", "xyz"]
```

不要通过直接指定索引来新增元素，因为这可能会在数组中留下空洞：

```javascript
names[10] = "james";
console.log(names); // 输出 ["abc", "wzy", "nba", "xyz", <6 empty items>, "james"]
```



**删除元素**

删除数组中的元素可以使用 `splice` 方法：

```javascript
names.splice(1, 1); // 删除索引为 1 的元素
console.log(names); // 输出 ["abc", "nba", "xyz"]
```

不要使用 `delete` 操作符删除数组元素，因为这会留下 `undefined`：

```javascript
delete names[1];
console.log(names); // 输出 ["abc", undefined, "xyz"]
```



**push**

1. 可以一次性插入多个元素
2. 返回新数组长度
3. 非纯函数



**pop**

1. 尾部删除，一次只能删除一个
2. 返回被删除的那个元素
3. 非纯函数



**unshift**

1. 头部插入，一次可以插入多个元素
2. 返回新数组长度
3. 非纯函数



**shift**

1. 头部删除，一次只能删除一个
2. 返回被删除的那个元素
3. 非纯函数



> 在数组的头部添加或删除元素（使用 `unshift` 和 `shift`）效率较低，因为需要移动所有后续元素。
>
> 而在尾部添加或删除元素（使用 `push` 和 `pop`）效率较高，因为不需要移动其它元素



**splice**

使用 `splice` 方法可以在数组的任意位置进行添加、删除或替换操作



`splice` 是非纯函数，语法格式如下:

```javascript
array.splice(start, deleteCount, item1, item2, ...);
```

- `start`: 开始操作的位置
- `deleteCount`: 要删除的元素个数
- `item1, item2, ...`: 要插入的新元素



```js
names.splice(1, 2); // 从索引1开始删除2个元素

names.splice(1, 0, 'newElement1', 'newElement2'); // 在索引1的位置插入新元素

names.splice(1, 2, 'newElement1', 'newElement2'); // 从索引1开始替换2个元素
```



**length**

```js
let array = ['a', 'b', 'c', 'd'];
console.log(array.length); // 输出：4
```

`length` 属性不仅可以读取，还可以写入。例如：

```javascript
let array = ['a', 'b', 'c', 'd'];
array.length = 2;
console.log(array); // 输出：['a', 'b']
```

将 `length` 设置为 2 后，数组被截断为前两个元素。同样地，将 `length` 设置为 0 可以清空数组。



**一些常用方法**

- `slice`：从数组中提取部分元素，返回新数组，不修改原数组。
- `concat`：合并多个数组，返回新数组，不修改原数组。
- `join`：将数组元素连接成一个字符串，不修改原数组。



**查找元素**

1. **indexOf**

   + 查找数组中某个元素的索引
   + 如果找到了该元素，则返回其索引；如果没有找到，则返回 -1
   + 这个方法适用于查找基本类型（如字符串、数字）的元素
   + 复杂数据类型 需要通过for循环自己迭代并根据属性特征进行匹配 「 find和findIndex是对应的简化方式 」

2. **find**

   + 用于查找数组中符合条件的第一个元素
   + 接受一个回调函数作为参数

   ```js
   let students = [
       { id: 100, name: "why", age: 18 },
       { id: 101, name: "james", age: 25 },
       { id: 102, name: "kobe", age: 30 }
   ];
   
   let foundStudent = students.find(student => student.id === 101);
   console.log(foundStudent);  // 返回 { id: 101, name: "james", age: 25 }
   ```

3. **findindex**

   + 用于查找数组中符合条件的第一个元素对应的索引
   + 接受一个回调函数作为参数

   ```js
   const numbers = [5, 12, 8, 130, 44];
   
   const index = numbers.findIndex(num => num > 100);
   
   if (index !== -1) {
     console.log('Found element');
   } else {
     console.log("No element greater than 100 found.");
   }
   ```

   

**some 和 every**

1. **some**

   + 数组中必须有一个元素通过了测试

   + 如果找到一个满足条件的元素，它将返回 `true`，否则返回 `false`。

   + 接受一个回调函数作为参数

   ```js
   const numbers = [1, 2, 3, 4, 5];
   
   const hasEvenNumber = numbers.some(num => num % 2 === 0);
   
   console.log(hasEvenNumber); // true
   ```

   

2. **every**

   + 数组中的每一个元素都必须通过测试
   + 如果数组中的所有元素都通过了测试，则返回 `true`；否则返回 `false`

   + 接受一个回调函数作为参数

   ```js
   const numbers = [2, 4, 6, 8];
   
   const allEven = numbers.every(num => num % 2 === 0);
   
   console.log(allEven); // true
   ```



> 绝大多数的数组高阶函数都接收两个参数
>
> 1. 回调 `(item, index, arr) => { ...}`
> 2. `thisArg` 用于修正回调中this的指向
>
> 注意是绝大多数，不是全部。例如`reduce`方法的第二个参数是`initalCount`不是`thisArg`



+ **includes**: 用于检查数组中是否包含某个元素 「 数组和字符串都可用 」
+ **findIndex**: 用于查找某个元素的索引
+ **reverse**: 数组反转, 非纯函数
+ **sort**: 数组排序 「 如果回调的返回值是true，则交互对应的两个元素 」

```js
let numbers = [21, 5, 4, 15, 100, 88];

console.log(numbers.sort((a, b) => a - b)); // 升序
// [4, 5, 15, 21, 88, 100]

console.log(numbers.sort((a, b) => b - a));  // 降序
// [4, 5, 15, 21, 88, 100]
```

```js
const arr = [1, 2, 3]
const str = 'Hello World'

// includes可以使用在数组对象上
console.log(arr.includes(2)) // => true
console.log(arr.includes(2, 2)) // => false

// includes可以使用在字符串对象上
console.log(str.includes('H')) // => true
console.log(str.includes('H', 1)) // => false
```



## 扁平化

```js
const nums = ['1-1', '1-2', ['2-1', '2-2'], [['3-1', '3-2'], ['3-3', '3-4']]]

// 参数默认值为1
console.log(nums.flat()) // => [ '1-1', '1-2', '2-1', '2-2', [ '3-1', '3-2' ], [ '3-3', '3-4' ] ]

console.log(nums.flat(2))
/*
  =>
    [
      '1-1', '1-2',
      '2-1', '2-2',
      '3-1', '3-2',
      '3-3', '3-4'
    ]
*/

// 超出最大深度 就按照最大深度进行平铺
console.log(nums.flat(3))
/*
  =>
    [
      '1-1', '1-2',
      '2-1', '2-2',
      '3-1', '3-2',
      '3-3', '3-4'
    ]
*/
```



1. 先拍平
2. 再执行flat方法 --- 只能是一层

```js
const msgs = ['Hello Wolrd', 'Klaus', 'Hello EcmaScript 2022']

console.log(msgs.flatMap(item => item.split(' '))) // => [ 'Hello', 'Wolrd', 'Klaus', 'Hello', 'EcmaScript', '2022' ]
```



## at方法

```js
const str = 'Hello World'
const arr = [1, 2, 3]

// 字符串和数组 有一个新增方法 at
// 可以通过索引值 去获取对应位置上的元素

// at方法支持负值，最后一位是-1，没有-0这种概念
console.log(str.at(1)) // => e
console.log(str.at(-1)) // => d

console.log(arr.at(1)) // => 2
console.log(arr.at(-1)) // => 3
```

