## 包装类

默认情况，当我们调用一个原始类型的属性或者方法时，会进行如下操作:

+ `根据原始值`，创建一个原始类型对应的包装类型对象

+ 调用对应的属性或者方法，返回一个新的值

+ 方法和属性使用完毕后，销毁创建的包装类对象



1. null、undefined没有任何的方法和属性，因为null和undefined没有对应的包装类

2. bigint和symbol获取包装类没有意义，如果要获取他们的包装类需要通过`Object`方法

3. 虽然规范上要求调用基本数据类型的属性和方法的时候，需要先转换为对应的包装类

   但是有些时候，JS引擎内部可以直接拿到对象的属性或操作对象的方法，而不需要转换为对应的包装类

   因此JS引擎出于优化的角度，其可以跳过创建包装类的过程在内部直接完成属性的获取或者方法的调用

```js
// 在主动创建包装类的时候
// 如果加上new关键字，会返回对应的包装类对象
// 如果不加上对应的new关键字，就直接返回对应的基本类型值，也就是参数值
const str1 = new String('Hello') // => String {'Hello'}
const str2 = String('Hello') // => Hello
```



### Number

```js
// 这种直接定义在构造函数上的方法和属性被称之为类方法和类属性(也可以被称之为静态方法和静态属性)

// 最大的正Number值
console.log(Number.MAX_VALUE)
// 最小的正Number值
console.log(Number.MIN_VALUE)

// 最大的不会失精的整数 --- 正数
console.log(Number.MAX_SAFE_INTEGER)
// 最小的不会失精的整数 --- 负数
console.log(Number.MIN_SAFE_INTEGER)
```



```js
const num = 123

console.log(num.toString()) // => 123

// 输出的其它进制字符串 没有0X前缀
console.log(num.toString(2)) // => 1111011
```



```js
// toFixed(digits)对数字小数进行四舍五入，并返回字符串结果值
// digits的默认值「缺省值」为 0
const num = 3.14159

console.log(num.toFixed()) // => 3
console.log(num.toFixed(3)) // => 3.142
```

`parseInt`和`parseFloat`用于将字符串转数值 「 不会四舍五入 」

```js
const num = '3.525'

console.log(Number.parseInt(num)) // => 3
console.log(Number.parseFloat(num)) // => 3.525

// parseInt方法 和 parseFloat方法 不仅存在于Number对象上，同时存在于window对象上
console.log(parseInt === Number.parseInt) // => true
console.log(parseFloat === Number.parseFloat) // => true
```



```js
// 以下转换方式以parseInt为例，parseFloat同理
console.log(parseInt(23)) // => 如果参数是Number类型，不进行转换，直接返回
console.log(parseInt(false)) // => 如果参数不是Number类型或String类型值，直接返回NaN

// 如果参数类型为数字开头字符串，会先从头开始尽可能的截取成合法的数字后再进行换行
// 这是parseInt和parseFloat于Number方法最大的区别
console.log(parseInt('123a234')) // => 123
console.log(parseInt('123.')) // => 123
console.log(parseFloat('123.223a24213')) // => 123.223
console.log(parseFloat('123.')) // => 123

// 如果参数不是以数字开头的字符串，直接返回NaN
console.log(parseInt('a23')) // => NaN
```



```js
// isNaN 会先调用Number方法转number后再判断是不是NaN
console.log(isNaN(NaN)) // true
console.log(isNaN(undefined)) // true

// Number.isNaN 不会进行任何类型转换，只有在参数为NaN时才返回true
console.log(Number.isNaN(NaN)) // true
console.log(Number.isNaN(undefined)) // false
```



```js
// 判断是不是整数
console.log(Number.isInteger(23)) // true
console.log(Number.isInteger(23.22)) // false
```



```js
// 判断参数是否 不是 Infinity 或 -Infinity
console.log(Number.isFinite(2)) // true
console.log(Number.isFinite(1 / 0)) // false
```



### String

```js
const str = 'Hello World'

console.log(str[4]) // => o
console.log(str.charAt(4))  // => o

// 区别是索引的方式没有找到会返回undefined，而charAt没有找到会返回空字符串
console.log(str[20]) // => undefined
console.log(str.charAt(20)) // => ''(空字符串)
```



字符串内部解析时，是通过字符数组进行解析。所以字符串可以通过`for - in`迭代，也可以通过`for - of`迭代

字符串具有`不可变性`，所以在JS中很多改变字符串的操作都是生成了一个新的字符串，而不会修改原本的那个字符串

```js
const str = 'Hello World'

// 这种修改方式 在JS中是不被允许的
str[4] = 'A'

console.log(str) // => Hello World
```



```js
const str = 'Hello World'

// 将所有的字符转成小写
console.log(str.toLowerCase()) // => hello world

// 将所有的字符转成大写
console.log(str.toUpperCase()) // => HELLO WORLD

// 返回的都是新字符串，并不会修改原本的字符串
console.log(str) // => Hello World
```



```js
const str = 'Hello World'

// indexOf(str, startIndex)
// 1. 多个符合条件的值 只会找到第一个
// 2. startIndex的默认值为0
// 3. 如果存在，返回str的首字母对应的索引值。如果不存在, 返回-1、
console.log(str.indexOf('World')) // => 6

// 有startIndex, 是在 str.slice(startIndex)返回的字符串中进行查找
// 但实际返回的索引是 在原字符串中对应的索引值
console.log(str.indexOf('World', 6)) // => 6
console.log(str.indexOf('World', 7)) // => -1
```



```js
const str = 'Hello World'

// lastIndexOf(str, startIndex) => 多个符合条件的值 值返回最后一个
// lastIndexOf的使用方式和indexOf是完全一致的，唯一的区别是，lastIndexOf的索引值是从后往前的计算的「从-1开始计算」
// 返回的索引值是前置索引值，不是后置索引值
console.log(str.lastIndexOf('World')) // => 6
console.log(str.lastIndexOf('World', 6)) // => 6
console.log(str.lastIndexOf('World', 5)) // => -1
```



```js
const str = 'Hello World'

// includes(str, index) 是字符串和数组上的方法，用于进行字符串的查找
console.log(str.includes('World')) // => true
console.log(str.includes('World', 7)) // => false
```



```js
const str = 'Hello World'

// 字符串以参数对应的字符串开头
console.log(str.startsWith('Hello')) // => true

// 字符串以参数对应的字符串结尾
console.log(str.endsWith('World')) // => false

// startsWith(str, index) --- 第二个参数为从index索引开始进行判断
console.log(str.startsWith('World', 6)) // => true

// endsWith(str, length) --- 第二个参数为 在length为长度的字符串内进行匹配
console.log(str.endsWith('Hello', 5)) // => true
```



```js
const str = 'Hello World'

// 查找到对应的字符串，并且使用新的字符串进行替代
// 参数一 既可以是字符串，也可以是RegExp
// 参数二 既可以是字符串，也可以是一个函数
console.log(str.replace('World', 'JavaScript')) // => Hello JavaScript

console.log(str.replace('World', () => 'HTML'))
```



```js
const str = 'Hello World'

// slice(start, end) => 截取[start, index)对应的子串
// 返回新字符串 - 纯函数
// 如果不写end表示 从start开始直接截取后面全部字符串
// end支持负数，-1表示最后一个字符，-2表示倒数第二个字符，。。。依次类推
console.log(str.slice(3, 7)) // => lo W
console.log(str.slice(3)) // => lo World
console.log(str.slice(3, -3)) // => lo Wo
```



```js
const str = 'Hello World'

// substr(start, length) - 非标准方法，不推荐使用
console.log(str.substr(3, 6)) // => lo Wor
console.log(str.substr(3, 22)) // => lo World
```



```js
const str = 'Hello World'

// substring(start, end) => 截取索引为[start, end)的子串
console.log(str.substring(3, 7)) // => lo W

// substring第二个参数不传，表示截取到字符串的末尾
console.log(str.substring(3)) // => lo World

// substring第二个参数不支持负值
// substring(start, end) 如果end为负值 为自动进行容错处理，转换为 substring（0, start）
console.log(str.substring(3, -1)) // => Hel
```



```js
const user1 = 'Klaus'
const user2 = 'Steven'
const user3 = 'Alex'

// 字符串拼接方式1 +
console.log(user1 + ' ' + user2 + ' ' + user3) // => Klaus Steven Alex

// 字符串拼接方式2 concat方法
// concat方法会将拼接后的字符串作为函数的返回值进行返回, 所以concat方法可以进行链式调用
console.log(user1.concat(' ' + user2).concat(' ' + user3)) // => Klaus Steven Alex

// concat的参数是可变参数，也就意味着其可以接收任意多个实参值
console.log(user1.concat(' ' + user2, ' ' + user3)) // => Klaus Steven Alex
```



```js
const str = '    Hello World    '

// 去除首尾空格
console.log(str.trim()) // => Hello World

// 去除首部空格
console.log(str.trimStart()) // => World   （尾部有未移除的空格）

// 去除尾部空格
console.log(str.trimEnd()) // =>    World （首部有未移除的空格）
```



```js
const str = 'Hello World'

// 如果不传入分隔符，那么就不进行分割，直接将原字符串放入一个新数组中
console.log(str.split()) // => ['Hello World']

// 指定对应的分隔符
console.log(str.split(' ')) // => [ 'Hello', 'World' ]

// 第二个参数 用来返回切片的数量
console.log(str.split(' ', 1)) // => [ 'Hello' ]
```



```js
const strs = ['Hello', 'World']

// 以参数作为拼接符 对数组进行拼接操作
console.log(strs.join('*')) // => Hello*World

// 默认的拼接符为 逗号
console.log(strs.join()) // => Hello,World
```

```js
const str = '1'

// padStart(length, pad) 
// 1. pad转换为字符串后，必须长度为1，否则会使用第一个字符
// 2. 从左开始填充，直到长度到length 「 如果不填充，以满足长度需求则静默失效 」
// 3. pad的默认值是空格
console.log(str.padStart(2, 0)) // => 01
console.log(typeof str.padStart(2, 0)) // => string

// padEnd(length, pad) - 从后边填充，方法和padStart完全一致
console.log(str.padEnd(2, 0)) // => 10
console.log(typeof str.padEnd(2, 0)) // => string
```



## Math

Math是一个内置对象(不是一个构造函数)，它拥有一些数学常数属性和数学函数方法

| 常用属性 | 说明                   |
| -------- | ---------------------- |
| PI       | 圆周率，约等于 3.14159 |

| 常用方法       | 说明                                                   |
| -------------- | ------------------------------------------------------ |
| Math.floor     | 向下舍入取整                                           |
| Math.ceil      | 向上舍入取整                                           |
| Math.round     | 四舍五入取整<br /> 返回值类型是Number                  |
| Math.random    | 生成0~1的随机数<br /> 返回值范围[0, 1)之间的整数或小数 |
| Math.pow(x, y) | 返回x的y次幂<br />等价于`x ** y`                       |

```js
// 生成 [5, 50) 之间的随机整数
// Math.floor(Math.random * (y - x)) + x => 生成[x, y)之间的随机整数 「 （大-小）+ 小 」
Math.floor(Math.random() * 45) + 5
```



## Date

### 分类

**格林威治时间**

英国伦敦的皇家格林威治( Greenwich )天文台的标准时间(刚好在本初子午线经过的地方)，这个时间也称之为GMT(Greenwich Mean Time)

其他时区根据标准时间来确定自己的时间，往东的时区(GMT + hh:mm)，往西的时区(GMT - hh:mm)

**世界时**

由于地震、潮汐等自然因素的影响，地球的自转速度并不完全恒定，导致 GMT 和基于地球自转的时间测量可能会有纳秒级的误差

因此会造成GMT时间有一定的误差，于是就提出了根据原子钟计算的标准时间UTC(Coordinated Universal Time)

在浏览器中，GMT时间表示，是按照UTC格式时间再加上对应的时区值进行计算得到



### 基本使用

根据当前时间戳生成对应时间

```js
const date = new Date();
console.log(date); // 直接打印，直接调用toString方法输出本地日期字符串
```



传入日期格式字符串，解析为UTC零时区时间，然后在根据时区自动调整

只有年份是必传的，日和月默认值都是1，其余默认值都是0

```js
const date = new Date('2022-02-13');
console.log(date); // => Sun Feb 13 2022 08:00:00 GMT+0800 (中国标准时间)
```



传入时间戳

```js
const date = new Date(1652693601880);
console.log(date); // => Mon May 16 2022 17:33:21 GMT+0800 (中国标准时间)
```



传入多个值，对应年，月，日，时，分，秒，毫秒

至少传入2个参数，也就是年和月，其余参数可以省略 「 以区分时间戳 」

日期不传 默认值为1， 其余不传默认值皆为0

```js
const date5 = new Date(2022, 02, 13, 08, 22, 45, 222);
console.log(date5); // => Sun Mar 13 2022 08:22:45 GMT+0800 (中国标准时间)
```



### 时间戳

计算机中的时间戳分为两种

| 种类        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| 时间戳      | 它是一个整数值，表示自1970年1月1日00:00:00 UTC以来的毫秒数。<br />时间戳的长度通常为13位。JavaScript采用的就是这种毫秒为单位的时间戳。 |
| Unix 时间戳 | 它是一个整数值，表示自1970年1月1日00:00:00 UTC以来的秒数。<br />时间戳的长度通常为10位。许多编程语言和系统，包括Go语言，采用的就是Unix时间戳。 |

```js
// 当前时间对应的时间戳
const now = Date.now()

// date重写了valueof方法，其本质调用的是getTime方法以返回时间戳
console.log(date.valueOf()) // => 1644710400000
console.log(date.getTime()) // => 1644710400000

// 加上+或-号，本质是在转number也就是调用valueof方法
console.log(+date) // => 1644710400000
```



`Date.parse(dateString)` 方法可以从符合特定格式的字符串中读取日期，并返回对应的时间戳（自1970年1月1日以来的毫秒数）。具体来说：

1. `Date.parse(dateString)` 和 `new Date(dateString).getTime()` 通常会返回相同的时间戳。
2. `Date.parse(dateString)` 方法要求参数字符串符合 RFC2822 或 ISO 8601 日期格式。如果字符串格式符合这些标准，它将能够正确解析日期。
3. 虽然 `Date.parse(dateString)` 可能能够解析某些非标准格式的日期字符串，但这种解析行为并不总是可靠，因此结果可能因浏览器的不同而异。
4. 如果提供的字符串无法解析为有效日期，`Date.parse(dateString)` 将返回 `NaN`，表示解析失败。

```js
console.log(Date.parse('Mon May 16 2022 19:32:45 GMT+0800 (中国标准时间)')) // => 1652700765000
```



### 日期字符串格式

| 标准     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| RFC 2822 | 用于电子邮件和其他基于互联网的协议中日期和时间的表示方式。<br />日期格式是“日-月-年”，时间使用24小时制，并附有时区信息<br />时区表示形式为四位数的偏移量（如 `-0400` 表示 UTC-4），或者使用 "GMT" 表示 UTC |
| ISO 8601 | ISO 8601 是一种国际通用的日期和时间表示标准，<br />采用“年-月-日”的顺序，并使用"T"分隔日期和时间部分，时间使用24小时制<br />时区可以使用“Z”表示零时区（UTC），也可以是带正负号的偏移量（如 `+08:00` 表示 UTC+8）。描述准确。 |

| 标准     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| RFC 2822 | Thu, 07 Oct 2023 12:00:00 GMT<br />Thu, 07 Oct 2023 09:30:00 -0400 |
| ISO 8601 | 2022-05-16T09:24:22.113Z<br />2022-05-03T17:30:08+08:00      |

在浏览器中，默认日期输出格式是 `Sat Oct 07 2023 17:20:59 GMT+0800 (中国标准时间)`

这是编程语言中特有日期格式，常用于JavaScript和Python等编程语言环境中

可以看成是ISO日期格式的一种变形，也是一种通用格式



在浏览器中，默认日期输出格式类似于 `Sat Oct 07 2023 17:20:59 GMT+0800 (中国标准时间)`

这种格式一般是编程语言默认输出格式，例如JavaScript和Python

它包含了星期几、月、日、年、时间、时区偏移量和时区名称，并自动进行时区转换



在 Node.js 环境中，默认日期输出格式是 ISO 8601 格式，例如 `2024-08-24T02:56:44.757Z`

输出的时间总是 UTC 时间，而不考虑当前环境的时区



一些其他日期格式，如 `2022-02-12 12:03:25.333` 和 `2022/02/12 12:03:25.333`

都是为了方便阅读而产生的日期格式。这些格式通常不显示具体的时区，显示的都是当前时区对应的时间。



### ISO转换标准

| 标识 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| YYYY | 年份，0000 ~ 9999<br />YYYY表示四位年份<br />YY表示两位年份  |
| MM   | 月份，01 ~ 12<br />月份使用MM表示，以区分 分钟               |
| DD   | 日，01 ~ 31                                                  |
| T    | 分隔日期和时间，没有特殊含义，可以省略                       |
| HH   | 小时，00 ~ 23<br />HH表示24小时制<br />hh表示12小时制        |
| mm   | 分钟，00 ~ 59<br />分钟使用mm表示，以区分 月份               |
| ss   | 秒，00 ~ 59                                                  |
| .sss | 毫秒                                                         |
| Z    | 时区<br />Z表示零时区<br />其他时区可以用±HH:mm表示，例如+08:00表示东八区 |



### 日期格式之间的相互转换

**编程语言格式**

```js
const date = new Date()

// Wed Aug 07 2024 20:33:17 GMT+0800 (中国标准时间)
console.log(date.toString())

// Wed Aug 07 2024
console.log(date.toDateString())

// 20:33:17 GMT+0800
console.log(date.toTimeString())
```



**ISO格式**

```js
const date = new Date()

// 2024-08-07T12:33:17.768Z
console.log(date.toISOString())

// 2024-08-07T12:33:17.768Z
console.log(date.toJSON())
```



**RFC格式**

```js
const date = new Date()

// Wed, 07 Aug 2024 12:40:45 GMT
console.log(date.toUTCString())
```



**本地格式**

```js
const date = new Date()

// 2024/8/7 20:33:17
console.log(date.toLocaleString())

// 2024/8/7
console.log(date.toLocaleDateString())

// 20:33:17
console.log(date.toLocaleTimeString())
```



### 获取和设置时间信息

我们在对日期进行设置的时候，如果设置的值超出了对应数值的范围，JavaScript会进行自动校准

| 获取方法          | 说明                                                         | 设置方法          |
| ----------------- | ------------------------------------------------------------ | ----------------- |
| getFullYear()     | 获取年份(4 位数)                                             | setFullYear()     |
| getMonth()        | 获取月份，从 0 到 11<br />注意: 月份是从0开始计算的          | setMonth()        |
| getDate()         | 获取当月的具体日期，从 1 到 具体月份的最大值                 | setDate()         |
| getHours()        | 获取小时                                                     | setHours()        |
| getMinutes()      | 获取分钟                                                     | setMinutes()      |
| getSeconds()      | 获取秒钟                                                     | setSeconds()      |
| getMilliseconds() | 获取毫秒                                                     | setMilliseconds() |
| getDay()          | 获取一周中的第几天，从 0(星期日)到 6(星期六)<br />注意: 1. 在浏览器中 一周开始的日期为周日<br />2. 周几的计算也是从0开始计算的 | 无                |
| getTime           | 获取时间戳                                                   | setTime           |

```js
const date = new Date()

console.log(date) // => 2022-05-16T10:59:12.232Z

// date中的getYear方法已经被弃用
console.log(date.getFullYear()) // => 2022
console.log(date.getMonth() + 1) // => 5
console.log(date.getDate()) // => 16
console.log(date.getHours()) // => 18
console.log(date.getMinutes()) // => 59
console.log(date.getSeconds()) // => 12
console.log(date.getMilliseconds()) // => 232
console.log(date.getDay() + 1) // => 2
```

```js
const date = new Date()

date.setDate(32)

// 因为5月份最大的日期值为31天，所以32越界了
// JS自动修正 将5月32日 自动修正为了 6月1日
console.log(date) // => 2022-06-01T11:01:18.820Z
```





### 通过时间戳计算时分秒

如果我们有一个三位数，我们希望分别取出其百位，十位，个位上的值，我们可以使用如下方式

```js
const num = 234

console.log(Math.floor(num / 100)) // => 2 - 百位
console.log(Math.floor(num / 10) % 10) // => 3 - 十位
console.log(num % 10) // => 4 - 个位
```



如果我们有一个时间戳，想要获取其对应的时，分，秒，也可以使用类似的方式

```js
const now = new Date()

console.log(now) // => 2022-05-21T04:57:40.413Z

// 计算当前时间的时分秒，需要先计算出当前时间和单日零点之间的时间戳
// 日期是一个对象，所以需要重新新建一个新的日期对象
const yesterday = new Date()

// 将新的日期对象的时间设置为当日零点
// 对于setHours 除了可以设置小时，也可以设置分钟... 一直可以设置到毫秒
// 对于setMinutes, setSeconds 之类的函数都是类似的
yesterday.setHours(0, 0, 0)

// 计算时间戳的差值，并将毫秒制转换为秒制
const intervalTime = Math.floor((now - yesterday) / 1000)

// 根据时间戳的差值，计算时分秒
console.log(Math.floor(intervalTime / (60 * 60))) // => 12 - 时
console.log(Math.floor(intervalTime / 60) % 60) // => 57 - 分
console.log(intervalTime % 60) // => 39 - 秒
```



