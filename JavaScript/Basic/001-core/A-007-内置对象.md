## 包装类

默认情况，当我们调用一个原始类型的属性或者方法时，会进行如下操作:

+ `根据原始值`，创建一个原始类型对应的包装类型对象

+ 调用对应的属性或者方法，返回一个新的值

+ 方法和属性使用完毕后，销毁创建的包装类对象



1. null、undefined没有任何的方法和属性，因为null和undefined没有对应的包装类

2. bigint和symbol获取包装类没有意义，如果要获取他们的包装类需要通过`Object`方法

3. 虽然规范上要求调用基本数据类型的属性和方法的时候，需要先转换为对应的包装类

   但是有些时候，JS引擎内部可以直接拿到对象的属性或操作对象的方法，而不需要转换为对应的包装类

   因此JS引擎出于优化的角度，其可以跳过创建包装类的过程在内部直接完成属性的获取或者方法的调用

```js
// 在主动创建包装类的时候
// 如果加上new关键字，会返回对应的包装类对象
// 如果不加上对应的new关键字，就直接返回对应的基本类型值，也就是参数值
const str1 = new String('Hello') // => String {'Hello'}
const str2 = String('Hello') // => Hello
```



### Number

```js
// 这种直接定义在构造函数上的方法和属性被称之为类方法和类属性(也可以被称之为静态方法和静态属性)

// 最大的正Number值
console.log(Number.MAX_VALUE)
// 最小的正Number值
console.log(Number.MIN_VALUE)

// 最大的不会失精的整数 --- 正数
console.log(Number.MAX_SAFE_INTEGER)
// 最小的不会失精的整数 --- 负数
console.log(Number.MIN_SAFE_INTEGER)
```

```js
const num = 123

console.log(num.toString()) // => 123

// 输出的其它进制字符串 没有0X前缀
console.log(num.toString(2)) // => 1111011
```

```js
// toFixed(digits)对数字小数进行四舍五入，并返回字符串结果值
// digits的默认值「缺省值」为 0
const num = 3.14159

console.log(num.toFixed()) // => 3
console.log(num.toFixed(3)) // => 3.142
```

`parseInt`和`parseFloat`用于将字符串转数值 「 不会四舍五入 」

```js
const num = '3.525'

console.log(Number.parseInt(num)) // => 3
console.log(Number.parseFloat(num)) // => 3.525

// parseInt方法 和 parseFloat方法 不仅存在于Number对象上，同时存在于window对象上
console.log(parseInt === Number.parseInt) // => true
console.log(parseFloat === Number.parseFloat) // => true
```

```js
// 以下转换方式以parseInt为例，parseFloat同理
console.log(parseInt(23)) // => 如果参数是Number类型，不进行转换，直接返回
console.log(parseInt(false)) // => 如果参数不是Number类型或String类型值，直接返回NaN

// 如果参数类型为数字开头字符串，会先从头开始尽可能的截取成合法的数字后再进行换行
// 这是parseInt和parseFloat于Number方法最大的区别
console.log(parseInt('123a234')) // => 123
console.log(parseInt('123.')) // => 123
console.log(parseFloat('123.223a24213')) // => 123.223
console.log(parseFloat('123.')) // => 123

// 如果参数不是以数字开头的字符串，直接返回NaN
console.log(parseInt('a23')) // => NaN
```



### String

```js
const str = 'Hello World'

console.log(str[4]) // => o
console.log(str.charAt(4))  // => o

// 区别是索引的方式没有找到会返回undefined，而charAt没有找到会返回空字符串
console.log(str[20]) // => undefined
console.log(str.charAt(20)) // => ''(空字符串)
```



字符串内部解析时，是通过字符数组进行解析。所以字符串可以通过`for - in`迭代，也可以通过`for - of`迭代

> for key in xxx => key的类型是字符串类型值



字符串具有`不可变性`，所以在JS中很多改变字符串的操作都是生成了一个新的字符串，而不会修改原本的那个字符串

```js
const str = 'Hello World'

// 这种修改方式 在JS中是不被允许的
str[4] = 'A'

console.log(str) // => Hello World
```



```js
const str = 'Hello World'

// 将所有的字符转成小写
console.log(str.toLowerCase()) // => hello world

// 将所有的字符转成大写
console.log(str.toUpperCase()) // => HELLO WORLD

// 返回的都是新字符串，并不会修改原本的字符串
console.log(str) // => Hello World
```

```js
const str = 'Hello World'

// indexOf(str, startIndex)
// 1. 多个符合条件的值 只会找到第一个
// 2. startIndex的默认值为0
// 3. 如果存在，返回str的首字母对应的索引值。如果不存在, 返回-1、
console.log(str.indexOf('World')) // => 6

// 有startIndex, 是在 str.slice(startIndex)返回的字符串中进行查找
// 但实际返回的索引是 在原字符串中对应的索引值
console.log(str.indexOf('World', 6)) // => 6
console.log(str.indexOf('World', 7)) // => -1
```

```js
const str = 'Hello World'

// lastIndexOf(str, startIndex) => 多个符合条件的值 值返回最后一个
// lastIndexOf的使用方式和indexOf是完全一致的，唯一的区别是，lastIndexOf的索引值是从后往前的计算的「从-1开始计算」
// 返回的索引值是前置索引值，不是后置索引值
console.log(str.lastIndexOf('World')) // => 6
console.log(str.lastIndexOf('World', 6)) // => 6
console.log(str.lastIndexOf('World', 5)) // => -1
```

```js
const str = 'Hello World'

// includes(str, index) 是字符串和数组上的方法，用于进行字符串的查找
console.log(str.includes('World')) // => true
console.log(str.includes('World', 7)) // => false
```

```js
const str = 'Hello World'

// 字符串以参数对应的字符串开头
console.log(str.startsWith('Hello')) // => true

// 字符串以参数对应的字符串结尾
console.log(str.endsWith('World')) // => false

// startsWith(str, index) --- 第二个参数为从index索引开始进行判断
console.log(str.startsWith('World', 6)) // => true

// endsWith(str, length) --- 第二个参数为 在length为长度的字符串内进行匹配
console.log(str.endsWith('Hello', 5)) // => true
```

```js
const str = 'Hello World'

// 查找到对应的字符串，并且使用新的字符串进行替代
// 参数一 既可以是字符串，也可以是RegExp
// 参数二 既可以是字符串，也可以是一个函数
console.log(str.replace('World', 'JavaScript')) // => Hello JavaScript

console.log(str.replace('World', () => 'HTML'))
```

```js
const str = 'Hello World'

// slice(start, end) => 截取[start, index)对应的子串
// 返回新字符串 - 纯函数
// 如果不写end表示 从start开始直接截取后面全部字符串
// end支持负数，-1表示最后一个字符，-2表示倒数第二个字符，。。。依次类推
console.log(str.slice(3, 7)) // => lo W
console.log(str.slice(3)) // => lo World
console.log(str.slice(3, -3)) // => lo Wo
```

```js
const str = 'Hello World'

// substr(start, length) - 非标准方法，不推荐使用
console.log(str.substr(3, 6)) // => lo Wor
console.log(str.substr(3, 22)) // => lo World
```

```js
const str = 'Hello World'

// substring(start, end) => 截取索引为[start, end)的子串
console.log(str.substring(3, 7)) // => lo W

// substring第二个参数不传，表示截取到字符串的末尾
console.log(str.substring(3)) // => lo World

// substring第二个参数不支持负值
// substring(start, end) 如果end为负值 为自动进行容错处理，转换为 substring（0, start）
console.log(str.substring(3, -1)) // => Hel
```

```js
const user1 = 'Klaus'
const user2 = 'Steven'
const user3 = 'Alex'

// 字符串拼接方式1 +
console.log(user1 + ' ' + user2 + ' ' + user3) // => Klaus Steven Alex

// 字符串拼接方式2 concat方法
// concat方法会将拼接后的字符串作为函数的返回值进行返回, 所以concat方法可以进行链式调用
console.log(user1.concat(' ' + user2).concat(' ' + user3)) // => Klaus Steven Alex

// concat的参数是可变参数，也就意味着其可以接收任意多个实参值
console.log(user1.concat(' ' + user2, ' ' + user3)) // => Klaus Steven Alex
```

```js
const str = '    Hello World    '

// 去除首尾空格
console.log(str.trim()) // => Hello World
```

```js
const str = 'Hello World'

// 如果不传入分隔符，那么就不进行分割，直接将原字符串放入一个新数组中
console.log(str.split()) // => ['Hello World']

// 指定对应的分隔符
console.log(str.split(' ')) // => [ 'Hello', 'World' ]

// 第二个参数 用来返回切片的数量
console.log(str.split(' ', 1)) // => [ 'Hello' ]
```

```js
const strs = ['Hello', 'World']

// 以参数作为拼接符 对数组进行拼接操作
console.log(strs.join('*')) // => Hello*World

// 默认的拼接符为 逗号
console.log(strs.join()) // => Hello,World
```

```js
const str = '1'

// padStart(length, pad) 
// 1. pad转换为字符串后，必须长度为1，否则会使用第一个字符
// 2. 从左开始填充，直到长度到length 「 如果不填充，以满足长度需求则静默失效 」
console.log(str.padStart(2, 0)) // => 01
console.log(typeof str.padStart(2, 0)) // => string

// padEnd(length, pad) - 从后边填充，方法和padStart完全一致
console.log(str.padEnd(2, 0)) // => 10
console.log(typeof str.padEnd(2, 0)) // => string
```



## Math

Math是一个内置对象(不是一个构造函数)，它拥有一些数学常数属性和数学函数方法

| 常用属性 | 说明                   |
| -------- | ---------------------- |
| PI       | 圆周率，约等于 3.14159 |

| 常用方法       | 说明                                                   |
| -------------- | ------------------------------------------------------ |
| Math.floor     | 向下舍入取整                                           |
| Math.ceil      | 向上舍入取整                                           |
| Math.round     | 四舍五入取整<br /> 返回值类型是Number                  |
| Math.random    | 生成0~1的随机数<br /> 返回值范围[0, 1)之间的整数或小数 |
| Math.pow(x, y) | 返回x的y次幂<br />等价于`x ** y`                       |

```js
// 生成 [5, 50) 之间的随机整数
// Math.floor(Math.random * (y - x)) + x => 生成[x, y)之间的随机整数 「 （大-小）+ 小 」
Math.floor(Math.random() * 45) + 5
```

