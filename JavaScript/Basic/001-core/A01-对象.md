## 基本使用

对象的键的类型是 `string | number | symbol`  「 number在使用时会自动转换为string 」

对象的值的类型是`unknown`

```js
const address = 'address'

const firend = {
  name: 'Klaus',
  // 普通字符串可以省略引号
  age: 23,
  // key是不合法字符串时，需要加上引号
  'firend-name': 'Alex',
  // 计算属性，其中可以是JavaScript表达式 
  ['last'+'name']: 'Wang',
  [address]: 'shanghai'
 	// 函数是特殊可执行属性，被称之为方法
  run() {
    console.log('running')
  }
}
```

> 变量可以被认为JavaScript表达式的一种
>
> 1. 变量可以放在return后边
> 2. 变量在实际运行时，其实是替换成了对应的值



### 创建方式

1. 字面量形式
2. `new Object` + 添加属性 
3. 通过构造函数



`new Object` + 添加属性 本质是 字面量类型的语法糖形式 

```js
const obj = {} // 等价于 const obj = new Object()
```

所以多个字面量实际是不同的对象

```js
const obj1 = {}
const obj2 = {}
console.log(obj1 === obj2) // => false
```



### crud

```js
user.name // 属性的默认值是undefined

// 中括号也用于取值，其中存入任何合法的JavaScript表达式
user[address]
// 如果值是不合法JavaScript字符串时，也可以使用中括号语法
user['friend-name']

user.age = 18 // 有则修改，无则添加

delete user.height // 删除属性 
```

> `delete` 操作符用于删除对象的属性，它的返回值是一个布尔值, 用于表示是否删除成功
>
> 1. 删除不存在的属性，会静默失效，且被认定为删除成功
> 2. 只有属性描述符的`configurable`的值为false，才会删除失败



## 遍历

**遍历方式**

1. 普通for循环
2. for key in [obj | array | string] 「  string 会被识别为字符数组 」
3. for value of Iterator



**获取所有属性**

1. 获取**自身可枚举属性**， 不包括 symbol类型属性，原型属性 和 不可枚举属性，返回值是数组
   + `Object.keys()`
   + `Object.values()`
   + `Object.entries()`

2. `for value of iterator` 会迭代 自身及原型上的 所有 可迭代非Symbol属性

   原型上属性一般不需要再迭代时使用，一般结合`Object.hasOwn`方法一起使用

3. `Object.getOwnPropertyNames` 获取自身所有非symbol属性， 无论是否可迭代，返回值是数组

4. `Object.getOwnPropertySymbols` 获取自身所有symbol属性，无论是否可迭代，返回值是数组

5. `Reflect.ownKeys` 等价于`[...Object.getOwnPropertyNames, Object.getOwnPropertySymbols]` 



## 批量创建对象

### 工厂函数

工厂函数是一种设计模式

```js
// 工厂函数创建
function createUser(name, age) {
  let user = {}
  user.name = name
  user.age = age
  return user
}

// user1 和 user2 的类型是Object
const user1 = createUser('Klaus', 23)
const user2 = createUser('Alex', 24)
```

缺点: user1  和 user2 类型都是 Object实例，无法具体细分



### 构造函数

在ES5之前，通过function来声明一个构造函数，之后通过new关键字来对其进行调用

在ES6之后，JavaScript可以像别的语言一样，通过class来声明一个类

```js
function User(name, age) {
  this.name = name
  this.age = age
}

// user3 和 user4 的类型是 User
const user3 = new User('Klaus', 23)
const user4 = new User('Alex', 24)
```

构造函数本质是内部简化了的工厂函数

构造函数new执行的流程

1. 初始化空对象 `工厂函数中的 let user = {}`
2. 将this的值初始化为新初始化的空对象
3. 构造函数的显示原型 指向  实例的隐式原型
4. 执行内部逻辑
5. 返回值
   + 构造函数本身返回了对象，使用显示返回的对象
   + 构造函数本身返回了非对象 「字符串，undefined等」, 使用this指向的那个新初始化对象 `工厂函数中的return user`



**构造函数相比工厂函数最大的优势是，在执行构造函数时，会将实例的类型更加具体化**



```js
// 构造函数也可以当做普通函数进行调用，但这样调用没有意义
function User(username, age) {
  this.username = username
  this.age = age
}

console.log(User('Klaus', 34))  // => undefined

// 默认调用下，this指向globalThis，所以username和age会被挂载到GO上
// 但是在严格模式下，this无法指向globalThis，其值是undefined, 因此会报错
console.log(username, age)
```



## Object.defineProperty

`Object.defineProperty()`用于对对象属性进行更细致的控制

1. 用于添加新属性或修改现有属性
2. 返回值是对象本身
3. 会直接修改对象，不是纯函数，因此返回值很少使用

```js
// 设置一个
const obj = Object.defineProperty(obj, key, descriptor)

// 设置一群
Object.defineProperties(obj, Record<key, descriptor>)
```



## descripter

descripter是一个对象，被称之为属性描述符对象

可以分为两类

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0de9223530e1451194c5798b47ac4fe7~tplv-k3u1fbpfcp-zoom-1.image) 



### 数据属性描述符

| 属性描述符       | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| [[Configurable]] | 属性是否可以使用delete删除，属性的数据描述符是否可以被再次修改 |
| [[Enumerable]]   | 属性是否是可迭代的(即可以使用for-in循环，Object.keys等获取)  |
| [[Writable]]     | 属性是否是只读的                                             |
| [[value]]        | 属性值，读取属性时会返回该值，修改属性时，会对其进行修改     |

1. 对于属性描述符(除[[value]]外)，其余描述符的默认值如下:
   + 当我们直接在一个对象上定义某个属性时，默认值为true
   + 当我们通过属性描述符定义一个属性时，默认值为false

2, 对于属性描述符[[value]], 默认值为undefined

> 对于不可枚举的属性，如果直接打印一个对象的时候，依旧可以在打印的对象中看到对应的不可枚举属性，但是其颜色会比正常属性要淡，表明其是一个不可枚举属性，在遍历的时候不会被输出



### 存储属性描述符

| 属性描述符       | 功能                                       |
| ---------------- | ------------------------------------------ |
| [[Configurable]] | 和数据属性描述符中[[Configurable]]规则一致 |
| [[Enumerable]]   | 和数据属性描述符中[[Enumerable]]规则一致   |
| [[get]]          | 获取属性时会执行的函数。默认为undefined    |
| [[set]]          | 设置属性时会执行的函数。默认为undefined    |



#### 获取属性描述符

```js
Object.getOwnPropertyDescriptor(obj, key)

Object.getOwnPropertyDescriptors(obj)
```



## 限制对象

`Object.preventExtensions(obj)` -- 禁止添加新属性

`Object.seal(obj)` -- 不能删除属性 也不能修改属性描述符

`Object.freeze(obj)` -- 不能修改属性值

「 规则，从下到上依次宽松 」



## 相关方法

### Object.create

```js
const child = Object.create(parent, descriptor)
```

1. 将child的隐式原型设置为parent对象
2. parent可以为null，表示child是顶层对象
3. descriptor是属性描述符对象，会被添加到child对象上

```js
const obj = {
  name: 'Klaus',
  age: 23
}

const user = Object.create(obj, {
  address: {
    value: 'address',
    enumerable: true,
    configurable: true
  }
})
```





### setPrototypeOf/getPrototypeOf/isPrototypeOf

`Object.setPrototypeOf(obj, prototype)` --- 设置对象

`Object.getPrototypeOf(obj)` --- 获取原型

`obj.isPrototypeOf(obj)` --- 检测某个对象是否在当前对象的原型链上

```js
const obj = {
  name: 'Klaus',
  age: 23
}

const user = {}

// 设置user的原型对象为obj对象
Object.setPrototypeOf(user, obj)

// 获取user对象的原型对象
console.log(Object.getPrototypeOf(user) === obj) // => true
```

浏览器内部在设置原型链的时候，会进行一定程度的优化操作

而`Object.setPrototypeOf(obj)`会破坏现有原型链，此时浏览器需要清除之前的优化 「 例如缓存优化等 」在重新修改原型链后重新进行优化，所以`Object.setPrototypeOf(obj)`相对比较消耗性能

推荐使用`Object.create`, 因为是新建一个原型链，而不是破坏现有原型链



```js
const obj = {
  name: 'Klaus',
  age: 23
}

const user = Object.create(obj)

// obj.isPrototypeOf(obj) 是对象 是否在对象的原型链上
// obj instanceOf Constuctor 是 构造函数的显示原型对象 是否在对象的原型链上
console.log(obj.isPrototypeOf(user)) // => true
```





### hasOwnProperty/hasOwn

`hasOwnProperty` 判断属性是否是对象自身属性

```js
const obj = {
  name: 'Klaus',
  age: 23
}

const user = Object.create(obj)
user.address = 'shanghai'

console.log(user.hasOwnProperty('name')) // => false
console.log(user.hasOwnProperty('address')) // => true
```

但`hasOwnProperty`又一个弊端

```js
const user = Object.create(null, { name: 'Klaus' })

// user对象没有隐式原型
console.log(user.hasOwnProperty('name')) // error
```

为了解决这个问题，ECMAScirpt提供了`Object.hasOwn`

```js
const user = Object.create(null, { name: 'Klaus' })

console.log(Object.hasOwn('name')) // => true
```



## 相关操作符

### in 

`property in obj` -- 属性是否在对象及对象原型上

```js
const obj = {
  name: 'Klaus',
  age: 23
}

const user = Object.create(obj)
user.address = 'shanghai'

console.log('name' in user) // => true
console.log('address' in user) // => true
```



### instanceOf

`instance instanceOf contructor` -- 构造函数的显示原型是否存在于实例的原型链上

```js
function Person(name, age) {
  this.name = name
  this.age = age
}

function Student(name, age, sno) {
  Person.call(this, name, age)
  this.sno = sno
}

Object.setPrototypeOf(Student.prototype, Person.prototype)

const stu = new Student('Klaus', 23, 1810166)

console.log(stu instanceof Student) // => true
console.log(stu instanceof Person) // => true
```

