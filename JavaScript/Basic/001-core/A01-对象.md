## 基本使用

对象key的类型是`symbol | string`，如果key的类型不是key会转换为字符串后再使用 

对象key的推荐类型是 `string | number | symbol`,  其余类型就不推荐使用了

对象的值的类型是`unknown`， 也就是任意类型都可以

```js
const address = 'address'
const height: 1.88

const firend = {
  name: 'Klaus',
  // 普通字符串可以省略引号
  age: 23,
  
  // key是不合法字符串时，需要加上引号
  'firend-name': 'Alex',
  
  // 计算属性，其中可以是JavaScript表达式 
  ['last'+'name']: 'Wang',
  [address]: 'shanghai'
 	
  // 等价于 height: height
  height,
  
  // 函数是特殊可执行属性，被称之为方法
  // 等价于 run: function() { ... }
  run() {
    console.log('running')
  }
}
```

> 变量可以被认为JavaScript表达式的一种
>
> 1. 变量可以放在return后边
> 2. 变量在实际运行时，其实是替换成了对应的值



### 创建方式

1. 字面量形式
2. `new Object` + 添加属性 
3. 通过构造函数



`new Object` + 添加属性 本质是 字面量类型的语法糖形式 

```js
const obj = {} // 等价于 const obj = new Object()
```

所以多个字面量实际是不同的对象

```js
const obj1 = {}
const obj2 = {}
console.log(obj1 === obj2) // => false
```



### crud

```js
user.name // 属性的默认值是undefined

// 中括号也用于取值，其中存入任何合法的JavaScript表达式
user[address]
// 如果值是不合法JavaScript字符串时，也可以使用中括号语法
user['friend-name']

user.age = 18 // 有则修改，无则添加

delete user.height // 删除属性 
```

> `delete` 操作符用于删除对象的属性，它的返回值是一个布尔值, 用于表示是否删除成功
>
> 1. 删除不存在的属性，会静默失效，且被认定为删除成功
> 2. 只有属性描述符的`configurable`的值为false，才会删除失败



## 遍历

**遍历方式**

1. 普通for循环
2. for key in [obj | array | string] 「  string 会被识别为字符数组 」
3. for value of Iterator



**获取所有属性**

1. 获取**自身可枚举属性**， 不包括 symbol类型属性，原型属性 和 不可枚举属性，返回值是数组
   + `Object.keys()`
   + `Object.values()`
   + `Object.entries()`

2. `for value of iterator` 会迭代 自身及原型上的 所有 可迭代非Symbol属性

   原型上属性一般不需要再迭代时使用，一般结合`Object.hasOwn`方法一起使用

3. `Object.getOwnPropertyNames` 获取自身所有非symbol属性， 无论是否可迭代，返回值是数组

4. `Object.getOwnPropertySymbols` 获取自身所有symbol属性，无论是否可迭代，返回值是数组

5. `Reflect.ownKeys` 等价于`[...Object.getOwnPropertyNames, Object.getOwnPropertySymbols]` 



## 批量创建对象

### 工厂函数

工厂函数是一种设计模式

```js
// 工厂函数创建
function createUser(name, age) {
  let user = {}
  user.name = name
  user.age = age
  return user
}

// user1 和 user2 的类型是Object
const user1 = createUser('Klaus', 23)
const user2 = createUser('Alex', 24)
```

缺点: user1  和 user2 类型都是 Object实例，无法具体细分



### 构造函数

在ES5之前，通过function来声明一个构造函数，之后通过new关键字来对其进行调用

在ES6之后，JavaScript可以像别的语言一样，通过class来声明一个类

```js
function User(name, age) {
  this.name = name
  this.age = age
}

// user3 和 user4 的类型是 User
const user3 = new User('Klaus', 23)
const user4 = new User('Alex', 24)
```

构造函数本质是内部简化了的工厂函数

构造函数new执行的流程

1. 初始化空对象 `工厂函数中的 let user = {}`
2. 将this的值初始化为新初始化的空对象
3. 构造函数的显示原型 指向  实例的隐式原型
4. 执行内部逻辑
5. 返回值
   + 构造函数本身返回了对象，使用显示返回的对象
   + 构造函数本身返回了非对象 「字符串，undefined等」, 使用this指向的那个新初始化对象 `工厂函数中的return user`



**构造函数相比工厂函数最大的优势是，在执行构造函数时，会将实例的类型更加具体化**



```js
// 构造函数也可以当做普通函数进行调用，但这样调用没有意义
function User(username, age) {
  this.username = username
  this.age = age
}

console.log(User('Klaus', 34))  // => undefined

// 默认调用下，this指向globalThis，所以username和age会被挂载到GO上
// 但是在严格模式下，this无法指向globalThis，其值是undefined, 因此会报错
console.log(username, age)
```



## 解构

JavaScript可以对对象或数组中进行解构操作

```js
const user = {
  name: 'Klaus',
  age: 24,
  address: 'shanghai'
}

// 基本使用
// 对象的解构是基于key，所以对象的解构没有顺序
const { name, address } = user
console.log(name, address) // => Klaus shanghai
```



```js
const user = {
  name: 'Klaus',
  age: 24,
  address: 'shanghai'
}

// 重命名
const { age: userAge } = user // => 等价于 const userAge = user.age
console.log(userAge) // => Klaus
// console.log(age) // error
```



```js
const user = {
  name: 'Klaus',
  age: 24,
  address: 'shanghai'
}

// 默认值
// 当解构出来的值为undefined的时候，就会使用默认值
const { gender = 'male' } = user
console.log(gender) // => male
```



```js
const user = {
  name: 'Klaus',
  age: 24,
  address: 'shanghai'
}

// 将剩余key解构到一个新对象中
const {address: userAddress, ...userInfo} = user
console.log(userInfo) // => { name: 'Klaus', age: 24 }
```



```js
// 嵌套解构
const user = {
  name: 'Klaus',
  age: 23,
  friend: {
    name: 'Alex'
  }
}

const {friend: { name }} = user
console.log(name) // => Alex
```



## Object.defineProperty

`Object.defineProperty()`用于对对象属性进行更细致的控制

1. 用于添加新属性或修改现有属性
   + 如果修改现有属性，执行的是`Object.assign(旧描述符，新描述符)`，不是执行替换操作
2. 返回值是对象本身
3. 会直接修改对象，不是纯函数，因此返回值很少使用

```js
// 设置一个
const obj = Object.defineProperty(obj, key, descriptor)

// 设置一群
Object.defineProperties(obj, Record<key, descriptor>)
```



## descripter

descripter是一个对象，被称之为属性描述符对象

可以分为两类

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0de9223530e1451194c5798b47ac4fe7~tplv-k3u1fbpfcp-zoom-1.image) 



### 数据属性描述符

| 属性描述符       | 功能                                                         |
| ---------------- | ------------------------------------------------------------ |
| [[Configurable]] | 属性是否可以使用delete删除，属性的数据描述符是否可以被再次修改 |
| [[Enumerable]]   | 属性是否是可迭代的(即可以使用for-in循环，Object.keys等获取)  |
| [[Writable]]     | 属性是否是只读的                                             |
| [[value]]        | 属性值，读取属性时会返回该值，修改属性时，会对其进行修改     |

1. 对于属性描述符(除[[value]]外)，其余描述符的默认值如下:
   + 当我们直接在一个对象上定义某个属性时，默认值为true
   + 当我们通过属性描述符定义一个属性时，默认值为false

2, 对于属性描述符[[value]], 默认值为undefined

> 对于不可枚举的属性，如果直接打印一个对象的时候，依旧可以在打印的对象中看到对应的不可枚举属性，但是其颜色会比正常属性要淡，表明其是一个不可枚举属性，在遍历的时候不会被输出



### 存储属性描述符

| 属性描述符       | 功能                                       |
| ---------------- | ------------------------------------------ |
| [[Configurable]] | 和数据属性描述符中[[Configurable]]规则一致 |
| [[Enumerable]]   | 和数据属性描述符中[[Enumerable]]规则一致   |
| [[get]]          | 获取属性时会执行的函数。默认为undefined    |
| [[set]]          | 设置属性时会执行的函数。默认为undefined    |



#### 获取属性描述符

```js
Object.getOwnPropertyDescriptor(obj, key)

Object.getOwnPropertyDescriptors(obj)
```



## 限制对象

### 禁止扩展

| 操作           | 是否允许 |
| -------------- | -------- |
| 新增属性       | 不允许   |
| 修改属性       | 允许     |
| 删除属性       | 允许     |
| 修改属性描述符 | 允许     |

```js
const user = {
  name: 'Klaus'
}

// 阻止扩展
Object.preventExtensions(user)

// 检测对象是否被阻止扩展
console.log(Object.isExtensible(user)) // => false
```



### 封存对象

| 操作           | 是否允许 |
| -------------- | -------- |
| 新增属性       | 不允许   |
| 修改属性       | 允许     |
| 删除属性       | 不允许   |
| 修改属性描述符 | 不允许   |

```js
const user = {
  name: 'Klaus'
}

// 密封对象
Object.seal(user)

// 检测对象是否被密封
console.log(Object.isSealed(user)) // => true
```



### 冻结对象

| 操作           | 是否允许 |
| -------------- | -------- |
| 新增属性       | 不允许   |
| 修改属性       | 不允许   |
| 删除属性       | 不允许   |
| 修改属性描述符 | 不允许   |

```js
const user = {
  name: 'Klaus'
}

// 冻结对象
Object.freeze(user)

// 检测对象是否被冻结
console.log(Object.isFrozen(user)) // => true
```



## 相关方法

### Object

1. 如果参数是对象，直接返回
2. 如果参数不是对象，尽可能转对象 「 包装类 」
3. 如果参数没法转换为对象，直接返回空对象

```js
console.log(Object({ name: 'Klaus' })) // => { name: 'Klaus' }
console.log(Object(123)) // => [Number: 123]
console.log(Object(null)) // => {}
```



### Object.create

```js
const child = Object.create(parent, descriptor)
```

1. 将child的隐式原型设置为parent对象
2. parent可以为null，表示child是顶层对象
3. descriptor是属性描述符对象，会被添加到child对象上

```js
const obj = {
  name: 'Klaus',
  age: 23
}

const user = Object.create(obj, {
  address: {
    value: 'address',
    enumerable: true,
    configurable: true
  }
})
```



### setPrototypeOf/getPrototypeOf/isPrototypeOf

`Object.setPrototypeOf(obj, prototype)` --- 设置对象

`Object.getPrototypeOf(obj)` --- 获取原型

`obj.isPrototypeOf(obj)` --- 检测某个对象是否在当前对象的原型链上

```js
const obj = {
  name: 'Klaus',
  age: 23
}

const user = {}

// 设置user的原型对象为obj对象
Object.setPrototypeOf(user, obj)

// 获取user对象的原型对象
console.log(Object.getPrototypeOf(user) === obj) // => true
```



`Object.create`是新建一个对象并设置其原型链，`Object.setPrototypeof`是修改现有原型链

相比`Object.create`,  `Object.setPrototypeof`性能更低，因为需要破坏之前的原型链，重新设置后再重新执行优化操作。

并且`Object.setPrototypeof`的影响范围也比`Object.create`要大上许多

因此更推荐使用`Object.create`来设置原型链



```js
const obj = {
  name: 'Klaus',
  age: 23
}

const user = Object.create(obj)

// obj.isPrototypeOf(obj) 是对象 是否在对象的原型链上
// obj instanceOf Constuctor 是 构造函数的显示原型对象 是否在对象的原型链上
console.log(obj.isPrototypeOf(user)) // => true
```



### hasOwnProperty/hasOwn

`hasOwnProperty` 判断属性是否是对象自身属性

```js
const obj = {
  name: 'Klaus',
  age: 23
}

const user = Object.create(obj)
user.address = 'shanghai'

console.log(user.hasOwnProperty('name')) // => false
console.log(user.hasOwnProperty('address')) // => true
```

但`hasOwnProperty`又一个弊端

```js
const user = Object.create(null, { 
  name: {
  	value: 'Klaus',
  	configurable: true
	} 
})

// user对象没有隐式原型
console.log(user.hasOwnProperty('name')) // error
```

为了解决这个问题，ECMAScirpt提供了`Object.hasOwn`

```js
const user = Object.create(null, { 
  name: {
  	value: 'Klaus',
  	configurable: true
	} 
})

console.log(Object.hasOwn(user, 'name')) // => true
```



### is

`Object.is` 是 JavaScript 中一个用于比较两个值是否相同的方法

在绝大多数情况下，采用严格相等，但和严格相等不同的是，`Object.is`存在如下规则

1. `NaN` 被认为是相同的值
2. `+0` 和 `-0` 被认为是不同的值



## 相关操作符

### in 

`property in obj` -- 属性是否在对象及对象原型上

```js
const obj = {
  name: 'Klaus',
  age: 23
}

const user = Object.create(obj)
user.address = 'shanghai'

console.log('name' in user) // => true
console.log('address' in user) // => true
```



### instanceOf

`instance instanceOf contructor` -- 构造函数的显示原型是否存在于实例的原型链上

```js
function Person(name, age) {
  this.name = name
  this.age = age
}

function Student(name, age, sno) {
  Person.call(this, name, age)
  this.sno = sno
}

Object.setPrototypeOf(Student.prototype, Person.prototype)

const stu = new Student('Klaus', 23, 1810166)

console.log(stu instanceof Student) // => true
console.log(stu instanceof Person) // => true
```



## Object

**Object对象是所有对象的父类**

在JavaScript中，继承本质使用的是寄生组合式继承，因此当一个构造函数的显示原型在当前实例的原型链上，那么就可以认为该构造函数是当前实例的祖先类

而按照JavaScript的原型链规则，原型链的尽头是`Object.prototype`，因此我们可以认为`Object是所有类的父类`

所以一些公共的属性和方法，如`hasOwnProperty`,`toString`,`valueOf`等，也都被设置到了`Object.prototype`上，以确保这些属性和方法可以被所有实例所访问
