函数使用分为两个步骤:

1. 函数声明
2. 函数调用

函数声明好后不会被调用，除非我们主动进行调用，并可以进行多次重复调用



```js
const fun = () => {}
console.log(typeof fun) // => function
```



```js
// 函数声明
function foo() {}

// 函数表达式
const baz = () => {}
```



```js
// 函数表达式的本质是将函数赋值给了一个变量
const baz =  function foo() {
  console.log(foo) // foo只在函数内部有效，外部将失效
  console.log('Hello World')
}

baz() // success
foo() // error
```



## 属性

| 属性   | 说明                                                 |
| ------ | ---------------------------------------------------- |
| name   | 存储了函数的名称                                     |
| length | 记录着第一个有默认值参数或剩余参数之前的所有形参个数 |

```js
function fun(name = 23, age, ...args) {}

fun('Klaus', 25, 1.73, 'shanghai')

console.log(fun.length) // => 0
```



## 参数

函数的形参用于接收实参，可以理解为是函数中特殊的变量，这些变量的默认值是undefined



## 语法糖

语法糖是对另一种语法的简化或优化写法，这种写法相对于原有写法更为的方便或阅读性更强，但他们的底层机制和原理都是一致的。



## 头等公民

JavaScript支持函数式编程，函数本质也是一种特殊的对象, 是一种可以被重复执行的特殊变量

所以函数名的命名规则和普通变量规则完全一致，因为函数可执行，所以一般采用动词

```js
function fun() {}

// 函数上有一个特殊的属性name，其值为函数名
console.log(fun.name) // => 'fun'
```



## arguments

1. 存在于非箭头函数中
2. 伪数组对象
3. 存入所有的实参

```js
// arguments 的结构类似于如下形式 --- 伪代码
{
  '0': 'Klaus',
  '1': '23',
  // arguments的长度
  length: 2,
  // callee指向的是函数自身，可以使用这个属性来进行递归调用
  callee: 函数自身
}
```



### 伪数组转数组

1. `Array.prototype.slice.call(argumengt)`
   + slice是纯函数
   + 不传默认就是浅拷贝
2. `Array.from(iterator)`
3. `[...argument]`



### reset

1. 例如`...args`  --- 用于接收所有没有形参接收的实参

2. `rest参数`的类型是数组

3. 必须位于参数列表的最后

4. 用于取代`arguments`

   



## 递归

1. 函数自己调用自己
2. 必须存在结束条件 --- 避免无限递归，导致栈内存溢出
3. 递归是将一个复杂的任务，转化成可以重复执行的相同简单任务
4. 可以使用递归实现的，也可以使用for循环实现
   + for循环 - 可读性差，性能相对较高
   + 递归 - 可读性强，性能相对较差



## 作用域

1. 局部变量
2. 全局变量



### 外部变量 vs 自由变量

在当前作用域外定义的变量，就是外部变量

如果一个外部变量在当前作用域内被使用了，这个变量就变成了自由变量

也就是说自由变量是一种特殊的外部变量



### 作用域链

1. 在自己当前作用域中查找，找到就使用，没有找到就去上层作用域中进行查找
2. 在上层作用域查找，找到就使用，没有找到就再去上层作用域中进行查找
3. 依次类推，直到全局作用域，找到就使用，没有找到就去GO(windows对象)上进行查找
4. 如果GO中，依旧没有，报错





## Function

通过funciton关键字创建函数的本质是通过`new Function`创建了一个函数实例

```js
new Function(...args, functionBody)
```

```js
const sum = new Function('a', 'b', 'return a + b');
const foo = new Function('console.log("hello world")')
```



## 构造函数

```js
function Dog() {}

// Dog实例进行调用的方法被称之为 实例方法
Dog.prototype.running = () => console.log('running')
// Dog实例使用的属性被称之为 实例属性
Dog.prototype.name = '大黄'

// 挂载到构造函数上的方法 被称之为类方法
Dog.playing = () => console.log('playing')
// 挂载(添加)到构造函数上的属性 被称之为类属性
Dog.bread = '柴犬'
```



## 分类

**回调函数**

1. 将一个函数作为参数传入另一个函数中
2. 在另一个函数的执行的某一个时刻，会对我们所传入的那个函数进行调用

那么我们就将作为参数传入的那个函数，称之为回调函数



**高阶函数**

高阶函数(Higher-order function)必须至少满足两个条件之一:

+ 接受一个或多个函数作为输入
+ 输出一个函数



**纯函数**

1. **确定性**：相同的输入总是产生相同的输出。

2. **无副作用**：不依赖外部状态 「 如不使用全局变量 」，也不改变外部状态「如修改全局状态，修改外部存储，通过I/O设备产生输入和输出等」

   

**副作用**: 函数的本质是对参数进行处理并返回结果, 除此之外的额外功能都是副作用

   

纯函数相比非纯函数更简单干脆，因为它们在使用或移除时，对整体的影响较小，不容易产生bug

虽然并不是所有函数都必须是纯函数，但在某些场景下，纯函数的使用是非常有益的。

例如，在组件化开发中，组件应该像纯函数一样使用，以避免直接修改props，从而提高代码的可维护性和可预测性



**匿名函数**

没有函数名的函数

一般用于：

1. 函数表达式
2. IIFE



**立即执行函数表达式**

定义完函数后立即执行

```js
const userName = (name => {
  console.log('Hello World')
  return name
})('Klaus')

console.log(userName)
```



主要作用:

1. 创建独立作用域，避免污染全局变量 「 一般结合闭包一起使用 」
2. 早期的模块化



常见写法：

```js
(
  () => console.log('Hello World')
)()

(
  () => console.log('Hello World')()
)

!function() {
  console.log('Hello World')
}()

// 以!, +, - 开头 且IIFE使用箭头函数写法时
// 需要将函数定义 或 IIFE整体 使用小括号进行包裹
// 以方便JS Engine 将他们识别为一个整体，并正确转换为表达式
+(() => console.log('Hello World')())
+(() => console.log('Hello World'))()
```



以下写法是错误的，因为foo函数会被识别为是函数声明，而在IIFE中，必须是一个函数表达式，不能是函数声明

```js
function foo() {}()
```



## 函数柯里化

柯里化（Currying）是一种将具有多个参数的函数转换为一系列函数的方法，每个函数只接受一个参数，并返回一个新函数以处理下一个参数。「 单一职责原则 」

```js
// 在本案例中，日志的第一个类型往往是固定的，所以我们可以将日志打印函数转换为柯里化函数
const log = type => msg => console.log(`${type} : ${msg}`)

const fixLog = log('fix')

fixLog('修复功能1')
fixLog('修复功能2')
fixLog('修复功能3')

const featureLog = log('feature')

featureLog('新功能1')
featureLog('新功能2')
featureLog('新功能3')
```



柯里化函数虽然将函数逻辑进行了拆分，但是其也构成了闭包，增加了内存消耗。

因此虽然柯里化函数在某种程度上可以简化函数的调用，但是不应该频繁使用柯里化函数，而是只在必要的情况下，再去使用函数的柯里化



### 自动化

```js
function curryFun(fn) {
  let params = []

  // 不能是箭头函数，避免外部修改内部this
  return function curry(...args) {
    if (args.length) {
      // 保存参数
      params = [...params, ...args]
      // 返回的是curry不是fn，确保后续函数调用时，使用的同一个params
      return curry
    } else {
      // 函数调用
      return fn.call(this, ...params)
    }

  }
}

// test code
const sum = (num1, num2, num3) => console.log(num1 + num2 + num3)

const currySum = curryFun(sum)

currySum(10)(20)(30)()
currySum(10, 20)(30)()
currySum(10, 20, 30)()
```



## 组合函数

组合函数使用了名为组合模式的设计模式

本质就是对多次函数调用的组合封装

```js
function sum(num1, num2) {
  return num1 + num2
}

function doubleNum(num) {
  return num ** 2
}

// 每次这么调 必然存在重复代码
console.log(doubleNum(sum(2, 3)))
console.log(doubleNum(sum(22, 3)))
console.log(doubleNum(sum(2, 23)))

// 构建组合函数
function genComposeFun(fn1, fn2) {
  return function(...args) {
    return fn2(fn1(...args))
  }
}

const composeFun = genComposeFun(sum, doubleNum)
console.log(composeFun(1, 3))
```



### 自动化

```js
function composeFn(...fns) {
  // 这里隐藏对边界情况(edge case)的处理
  // 1. 没有传入函数的情况
  // 2. fns中的值可能不是函数的情况

  // 临时接收函数返回值
  let res

  // 不能是箭头函数，避免使用者通过以下方式调用
  // const fn = composeFn(...) fn.call(xxx, ....)
  return function(...args) {
    // for key in fns --- typeof key -> string
    for (const index in fns) {
      // for - in 会迭代原型属性
      if (!Reflect.has(fns, index)) return

      const fn = fns[index]

      // 第一次接收参数并调用，第二次直接使用第一次调用的结果
      res = +index === 0 ? fn.call(this,  ...args) : fn.call(this, res)

      if (+index === fns.length - 1) {
        return res
      }
    }
  }
}

// TEST CODE
function sum(num1, num2) {
  return num1 + num2
}

function doubleNum(num) {
  return num ** 2
}

const fn = composeFn(sum, doubleNum)

console.log(fn(10, 20))
console.log(fn(20, 30))
```



## 常见编写风格

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7eb4fd6fd4fa4dc987efaf6c3ce89a4f~tplv-k3u1fbpfcp-zoom-1.image) 



## debug

bug是代码错误，debug就是找到代码错误并修复他

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b06461e8800048e1bbfa9ee40e4c8db1~tplv-k3u1fbpfcp-zoom-1.image) 

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c76152bd12143da89cb6e350cc62dc9~tplv-k3u1fbpfcp-zoom-1.image) 



