每个函数完成的功能可能不同，但他们的本质都是某段特定功能代码的封装。

我们可以调用这些默认提供的函数，也可以编写自己的函数。

编写函数主要包含两步：函数的声明和函数的调用



函数的作用在于提高代码的编写效率和复用性，同时提供了更高的灵活性

`while`或`for`循环在某一时刻会重复执行多次，而函数则可以在需要时随时多次调用。



## 注意点:

1. 函数声明后，默认情况下其中的代码不会执行，只有在调用函数时，代码才会执行。
2. 函数本质是一种特殊对象，所以函数名的命名规则与变量名的命名规则一致。
3. 函数一般都是可执行的，所以函数名通常使用动词来命名



## 返回值

1. **默认返回值**：如果函数没有使用 `return` 关键字，那么它默认返回 `undefined`。
2. **显式返回 `undefined`**：我们可以显式地返回 `undefined`。
3. **立即停止执行**：当函数执行到 `return` 语句时，它会立即停止执行，并返回指定的值，后续的代码将不会执行。



## 语法糖

语法糖是一种简写或特殊的写法，相比于原有的写法，它更加方便或可读性更强

例如`1_0000_0000`是`100000000`对应的语法糖



## arguments

在函数内部，有一个特别的对象，叫做 `arguments` 对象

这个对象不是数组，而是一个类数组对象 『 伪数组对象 』

伪数组是对象，不是数组。可以通过索引访问元素以及调用length属性，但是没有办法调用数组相关方法和数组其它属性

`arguments`接收所有的实参，无论是显示声明的，还是没有显示声明的

`arguments` 对象在普通函数中存在，但在箭头函数中不存在



在 ES6 之后，使用剩余参数（rest parameters）来代替 `arguments` 对象

剩余参数是真正的数组

```js
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(10, 20, 30)); // 输出 60
```



## 递归

递归是一种将复杂任务分解为简单任务的编程思想，通过函数调用自身来实现。递归函数必须要有一个结束条件，以避免无限调用。

能使用递归实现的方法，一定也能通过for循环来实现。递归实现代码简洁，但性能稍差；for循环实现稍复杂，但性能较好



## 作用域

- **定义**：作用域是指变量或函数在程序中的可访问范围。
- **JavaScript作用域**：
  - 全局作用域
  - 函数作用域
  - 块级作用域（ES6引入）



## 变量分类

1. **全局变量**: 全局可访问变量
2. **局部变量**: 定义在函数或代码块中的变量
3. **外部变量**: 在函数或代码块内部访问的外部作用域的变量



#### 函数声明和函数表达式的区别

1. **语法不同**：
   - 函数声明是一个独立的语句。
   - 函数表达式是一个表达式。

2. **创建时机不同**：
   - 函数声明在JavaScript引擎解析代码时就已经创建。
   - 函数表达式在执行到该行代码时才创建。
   - 这就是为什么函数声明可以在声明之前调用，而函数表达式则不行，因为它在执行到定义那行代码之前是`undefined`。

在开发中，通常优先使用函数声明，因为它可以使代码更加灵活，可以在函数声明之前调用函数。函数表达式一般用于特定场景，如匿名函数和立即执行函数（IIFE）。



## 头等函数

函数可以作为其他函数的参数、返回值，或者赋值给变量，在变量之间传递，或者存储到其他数据结构中（如数组、对象）。这种编程方式也称为“函数式编程”。



## 回调函数

回调函数是指一个函数作为另一个函数的参数传递，并在适当的时候被另一个函数调用



## 高阶函数

高阶函数是指接受一个或多个函数作为参数，或者返回一个函数的函数



## 匿名函数

匿名函数是指没有函数名的函数，常用于将函数作为参数传递或立即执行

```js
const anonFunc = function() {
  console.log("This is an anonymous function.");
};

anonFunc(); // 输出 "This is an anonymous function."
```



## 立即执行函数

立即执行函数的英文是Immediately Invoked Function Expression，简称IIFE。它的作用是定义一个函数并立即执行。

IIFE由两部分组成：定义一个函数（通常是匿名函数），然后在函数后面加上小括号以立即执行

IIFE的全称是立即执行函数表达式，所以必须是一个表达式，不能是一个函数声明



立即执行函数的语法如下：

```javascript
(function() {
    // 这里是函数体
})();
```

或者：

```javascript
(function() {
    // 这里是函数体
}());
```



立即执行函数也可以接受参数和返回值：

```js
(function(name) {
    console.log("Hello, " + name);
})("World");

var result = (function() {
    return "Hello, World";
})();
console.log(result);
```



立即执行函数的作用是

1. **避免变量命名冲突，开启简单的模块化**

它有自己的独立作用域，避免了变量污染。

随着ES6引入了块级作用域（let、const）和模块化，IIFE的使用逐渐减少。



2. **解决没有块级作用域的问题**

假设页面中有九个按钮

```js
document.addEventListener("DOMContentLoaded", function() {
  var buttons = document.querySelectorAll(".btn");
  for (var i = 0; i < buttons.length; i++) {
    buttons[i].addEventListener("click", function() {
      console.log("按钮" + (i + 1) + "被点击了");
    });
  }
});
```

此时每次点击，index的值都是9，因为ES6之前，for循环不会创建块级作用域



```js
document.addEventListener("DOMContentLoaded", function() {
  var buttons = document.querySelectorAll(".btn");
  for (var i = 0; i < buttons.length; i++) {
    (function(i) {
      buttons[i].addEventListener("click", function() {
        console.log("按钮" + (i + 1) + "被点击了");
      });
    })(i);
  }
});
```

此时可以使用立即执行函数来创建一个新的作用域，以便在循环中捕获当前的索引值。



但这样解决本质是借用了闭包的原理，相对消耗性能。

在ES6中，我们可以使用 `let` 声明变量来解决该问题，因为它具有块级作用域

```js
document.addEventListener("DOMContentLoaded", function() {
  let buttons = document.querySelectorAll(".btn");
  for (let i = 0; i < buttons.length; i++) {
    buttons[i].addEventListener("click", function() {
      console.log("按钮" + (i + 1) + "被点击了");
    });
  }
});
```



### 一些其他写法

1. **常见写法**：

   ```javascript
   (function() {
       console.log("IIFE executed");
   })();
   ```

2. **其他写法**：

   ```javascript
   (function() {
       console.log("IIFE executed");
   }());
   ```

   ```javascript
   !function() {
       console.log("IIFE executed");
   }();
   
   +function() {
       console.log("IIFE executed");
   }();
   ```



## 默认参数

```js
// ES6之前编写默认参数
function sum(num1, num2, num3, num4) {
  // 编写默认参数方式一
  num1 = num1 ? num1 : 0

  // 编写默认参数方式二
  num2 = num2 || 0

  // 编写默认参数方式三
  // 前两种编写方式是具有缺陷的，因为类似于空字符串或0之类的转换为boolean后为false的值
  // 其也会触发对应的默认值，所以使用编写方式三更为的严谨
  num3 = [null, undefined].includes(num3) ? 0 : num3

  // 空值合并运算符是ES6后提供的一种新的默认值编写方式
  // 其本质是编写方式三的语法糖
  num4 = num4 ?? 0 // => 只有当num4的值为null或undefined的时候，才会使用对应的默认值

  console.log(num1 + num2 + num3 + num4)
}

sum()
```

```js
// 当函数参数的值为undefined的时候，就会触发对应函数参数的默认值
function sum(num1 = 0, num2 = 0) {
  console.log(num1, num2)
  console.log(num1 + num2)
}

sum()
```



1. 默认参数应该在没有默认值参数之后 --- 约定属性，避免需要显示传入undefined
2. 剩余参数必须位于最后，所以默认参数应该应该在剩余参数之前

```js
function sum(num1, num2 = 0, ...nums) {
  console.log(num1, num2, nums)
}
```



1. 有默认值的参数和剩余参数是不计算在函数的length属性值中
2. 自第一个有默认值的参数开始后边所有的参数全部开始不进行统计

```js
function sum(num1 = 0, num2, ...args) {}

console.log(sum.length) // => 0
```



## 剩余参数

`...`为前缀的参数，会将之后所有参数存入该变量中，类型是数组

剩余参数必须放到最后一个位置，否则会报错



## 展开运算符

1. 以在函数调用/数组构造时，将数组表达式或者string在语法层面展开
2. 在构造字面量对象时, 将对象表达式按key-value的方式展开



展开运算符依赖的依旧是可迭代特性，对象字面量依旧是进行了特殊处理

所以对象怎么了只能在构造对象字面量的时候，使用展开运算符

```js
function foo(...args) {
  console.log(args)
}

const name = 'Klaus'
const users = ['Klaus', 'Alex', 'Jhon']

const info = {
  name: 'Klaus',
  age: 23
}

foo(...name) // => [ 'K', 'l', 'a', 'u', 's' ]
foo(...users) // => [ 'Klaus', 'Alex', 'Jhon' ]
foo(...info) // error
```

```js
const info = {
  name: 'Klaus',
  age: 23
}

const userInfo = {
  // 其底层使用的是对Object.keys(info)的结果进行遍历，所以其是一种浅拷贝
  ...info,
  address: 'shanghai'
}

console.log(userInfo) // => { name: 'Klaus', age: 23, address: 'shanghai' }
```



## 内置属性

JavaScript中函数是一种特殊的可以执行的对象

| 属性   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| name   | 存储了函数的名称                                             |
| length | 第一个有默认值参数之前的所有<br />除剩余参数和默认参数之外的形参个数 |



## arguments

1. 存放数据所有实参的类数组对象
2. arguments是可迭代对象
3. 被剩余参数所取代



类数组对象(array-like object)

+ 拥有数组的一些特性，比如说length，比如可以通过index索引来访问

+ 没有数组的一些方法，比如filter、map等



arguments转数组

1. `Array.prototype.slice.apply(arguments)`
2. `Array.from(arguments)`
3. `[...arguments]`



## 纯函数

纯函数本质上是一个不依赖外部环境，也不影响外部环境的函数



当一个函数满足如下条件的时候，该函数就是一个纯函数:

+ 确定的输入，在任何情况下都一定会产生确定的输出
+ 函数只能和输入或输出值有关，不可以依赖外部状态，例如外部的自由变量，或者I/O设备产生的外部输入输出
+ 在函数在执行过程中，不能产生任何形式的副作用
  + 所谓副作用就是在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响
  + 比如修改了全局变量，修改参数或者改变外部的存储

