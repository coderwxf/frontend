用户对页面执行不同操作后，浏览器会触发不同的事件

如果对应事件存在事件绑定函数，就去执行时间绑定函数



**绑定方式**

1. 直接在元素上绑定
2. 通过`onxxxx`属性绑定 「 DOM0级事件绑定 」
3. 通过`addEventListener`绑定 「 DOM2级事件绑定 」

```html
<!-- 浏览器原生的事件名都是小写的 -->
<button onclick="console.log('button was clicked')">ckick me</button>
```



1. 原生事件名也是全小写的
2. 本质是个属性，同名事件后续的会覆盖之前的同名事件 「 只能绑定一个同名事件 」

```js
const btnEl = document.getElementById('btn')

btnEl.onclick = () => console.log('button was clicked')
```



DOM2级事件绑定，事件名不以on开头

可以同时绑定多个同名事件，对应处理函数会被存入数组，并被依次回调

```js
const btnEl = document.getElementById('btn')

btnEl.addEventListener('click', () => console.log('按钮第一次被点击'))
btnEl.addEventListener('click', () => console.log('按钮第二次被点击'))
```



## 事件流

假设触发元素为`el`, 则事件的传播流程( 也叫做 **事件流** )如下:

1. 捕获阶段 => 从window -> document -> ... -> el的父元素 「早期NetSpace采用的事件流形式」
2. 触发阶段 => el触发对应事件
3. 冒泡阶段 => el的父元素 -> ... -> document -> window 「早期IE采用的事件流形式」



`addEventListener`方法第三个参数默认值为false

+ 当其值为false的时候，表示该事件响应函数在事件的冒泡阶段触发
+ 当其值为true的时候，表示该事件响应函数在事件的捕获阶段触发

```js
const btnEl = document.getElementById('btn')

btnEl.addEventListener('click', e => {
  // eventPhase是事件处理对象中的一个属性，其值是Number类型值
  // 1 - 事件在捕获阶段被触发 2 - 事件在触发阶段被触发 3 - 事件在冒泡阶段阶段被触发
  console.log(e.eventPhase) // => 1
  
  // 返回事件流中所有传播节点组成的数组
  // 顺序是从最内层的目标节点到最外层的节点（如 window）
  console.log(e.composedPath())
}, true)
```



1. 并不是所有的事件都支持事件传播机制，如`mouseenter/mouseleave`、`focus/blur`等都是不支持事件传播机制的
2. 事件流的流向 是由dom结构决定的，与cssom无关 「 即便通过样式将子元素移动了父元素外，事件流流向依旧不会发生任何改变 」



`mouseenter和mouseleave`是一对 对应的函数

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/759871d1eb7d4f289c2ca82843ce9c03~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=733&h=328&s=25916&e=png&b=ffffff) 

`mouseover和mouseout`是一对 对应的函数

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e1812b5bcea4a5690d93b2080adb95e~tplv-k3u1fbpfcp-zoom-1.image)  



## 事件对象

Event类的实例，封装了和当前事件相关的信息

| 属性             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| type             | 事件类型                                                     |
| target           | 触发事件的元素，即事件最初发生的元素                         |
| currentTarget    | 表示当前正在处理事件的元素<br />事件存在冒泡和捕获，所以只有事件被触发时，`currentTarget`才会等价于`target` |
| offsetX、offsetY | 触控点相对于currentTarget左上角的坐标                        |
| clientX、clientY | 触控点对于视口左上角的坐标                                   |
| pageX、pageY     | 触控点相对于页面左上角的坐标<br />页面可能被卷曲出去 所以值可能为负数 |
| screenX、screenY | 触控点相对于 显示屏左上角的坐标                              |

| 方法                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| preventDefault           | 1. 取消事件的默认行为                                        |
| stopPropagation          | 1. 阻止事件的进一步传递<br />2. 冒泡或者捕获都可以阻止<br />3. 当前目标节点的后续事件处理函数仍然会被调用。只有当该节点上所有绑定的事件处理函数都执行完毕后，才会阻止事件继续向上传播或向下捕获 |
| stopImmediatePropagation | 1. 阻止事件的进一步传递<br />2. 冒泡或者捕获都可以阻止<br />3. 当前目标节点上其他绑定的事件处理函数将**不会**被调用，即使它们尚未被执行。它立即阻止后续的事件处理函数，并阻止事件的进一步传播。 |

```js
const aEl = document.getElementById('a')

// 优先执行自定义逻辑，在处理默认事件响应逻辑
aEl.addEventListener('click', e => {
  console.log('超链接被点击了')
  // 阻止默认行为
  e.preventDefault()
})
```



## this

```js
const innerEl = document.getElementById('inner')

innerEl.addEventListener('click', function (e) {
  // 事件回调中的this是事件触发对象，也就是currentTarget
  console.log(this === e.currentTarget) // => true
})
```



## EventTarget

EventTarget是一个DOM接口，主要用于添加、删除、派发Event事件

所有的节点、元素都继承自EventTarget, 包括window对象，所以理论上所有节点都可以进行事件绑定

| 方法                | 说明                             |
| ------------------- | -------------------------------- |
| addEventListener    | 注册某个事件类型以及事件处理函数 |
| removeEventListener | 移除某个事件类型以及事件处理函数 |
| dispatchEvent       | 使用JavaScript来主动触发某个事件 |

```js
const handleClick = () => {
  console.log('handleClick')
}


innerEl.addEventListener('click', handleClick)

// 移除事件和绑定事件必须是同一个事件 「 事件队列中只比较地址 」
innerEl.removeEventListener('click', handleClick)
```



`dispatchEvent`用于手动进行事件派发「 即可以派发内置事件，也可以派发自定义事件 」

```js
const btn = document.getElementById('btn')

btn.addEventListener('click', () => {
  // 1. 通过某个元素派发事件 「 不传默认就是window 」
  // 2. 参数是事件对象 「 new Event(<event type>) 」
  btn.dispatchEvent(new Event('customEvent'))
})

btn.addEventListener('customEvent', () => console.log('customEvent'))

btn.dispatchEvent(new Event('click'))
```



## 事件委托

通过事件冒泡机制，将子元素的事件统一在父元素进行处理

事件委托本质是名为代理模式(委托模式)的设计模式

可以减少需要绑定的事件处理函数，从而简化事件处理流程，提高性能

```js
const ulEl = document.getElementById('ul')

ulEl.addEventListener('click', e => {
  // 通过e.target来判断实际触发事件的那个元素
  if (e.target.tagName !== 'UL') {
    for (const liEl of ulEl.children) {
      liEl.classList.remove('active')
    }

    e.target.classList.add('active')
  }
})
```



### 委托标记

给元素添加自定义属性，从而区分同类型元素

```html
<div id="outer" class="outer">
  <!-- 这里的data-action就是事件委托标记 -->
  <button data-action="add">添加</button>
  <button data-action="change">修改</button>
  <button data-action="remove">移除</button>
</div>
```

```js
const outerEl = document.getElementById('outer')

outerEl.addEventListener('click', e => {
  const action = e.target.dataset.action

  switch (action) {
    case 'add':
      console.log('add clicked')
      break
    case 'change':
      console.log('change clicked')
      break
    case 'remove':
      console.log('remove clicked')
  }
})
```



## 常见事件

| 事件               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| click              | 点击事件                                                     |
| contextmenu        | 右击打开菜单                                                 |
|                    |                                                              |
| mousedown          | 鼠标按下事件                                                 |
| mouseup            | 鼠标抬起事件                                                 |
|                    |                                                              |
| keydown            | 键盘按下事件                                                 |
| keyup              | 键盘抬起事件                                                 |
|                    |                                                              |
| mouseover          | 鼠标划入元素「支持冒泡」                                     |
| mouseout           | 鼠标划出元素 「 执行冒泡 」                                  |
|                    |                                                              |
| mouseenter         | 鼠标进入元素 「不支持冒泡」                                  |
| mouseleave         | 鼠标离开元素 「不支持冒泡」                                  |
|                    |                                                              |
| mousestart         | 鼠标开始滑动                                                 |
| mousemove          | 鼠标滑动中                                                   |
| mouseend           | 鼠标滑动结束                                                 |
| mousecancel        | 鼠标滑动中被突然打断                                         |
|                    |                                                              |
| pointerup          | 鼠标，手指，数控笔开始滑动                                   |
| pointermove        | 鼠标，手指，数控笔滑动中                                     |
| pointerend         | 鼠标，手指，数控笔滑动结束                                   |
| pointercancel      | 鼠标，手指，数控笔滑动中被突然打断                           |
|                    |                                                              |
| DOMContentLoaded   | DOM树构建完成，准备渲染<br />外部资源 「 如图片等 」还未加载完成 |
| load               | 外部资源都已经加载完毕准备开始渲染<br />load可以给window绑定，也可以给图片，视频等外部资源元素绑定 |
|                    |                                                              |
| resize             | 浏览器尺寸改变                                               |
| scroll             | 浏览器或元素的滚动条滚动了<br />scroll既可以在window绑定，也可以给有滚动条的元素绑定 |
|                    |                                                              |
| online             | 网络连接成功                                                 |
| offline            | 网络断线                                                     |
|                    |                                                              |
| focus              | 获取焦点「不支持冒泡」                                       |
| blur               | 失去焦点「不支持冒泡」                                       |
|                    |                                                              |
| transitionstart    | 过渡动画开始执行                                             |
| transitionend      | 过渡动画执行完成                                             |
| transitioncancel   | 过渡动画执行过程中被打断                                     |
|                    |                                                              |
| animationstart     | 帧动画开始执行                                               |
| animationend       | 帧动画执行完成                                               |
| animationiteration | 在帧动画的每次循环结束时触发，除了第一次（即从第二次循环开始）每次动画重复执行开始时都会触发 |
| animationcancel    | 帧动画执行过程中被打断                                       |

```js
const inputEl = document.getElementById('input')

inputEl.addEventListener('keyup', e => {
  // key 表示按下的键在当前键盘布局下实际生成的字符或功能键名称。如果修改了键位布局，key 会反映修改后的字符或功能键。
 // code 表示按下的键的物理位置代码，不受键盘布局修改的影响。即便修改了键位布局，code 仍然保持原始的物理位置代码不变。
  console.log(e.key, e.code)
  /*
    => 输出结果示例:
     key     code
     a       KeyA
     A       KeyA
     Enter   Enter
     Control ControlLeft
  */
})
```



### 表单事件

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4e8e6eb1e7747f79da5859de6f046f3~tplv-k3u1fbpfcp-zoom-1.image) 



表单输入元素的input事件和change事件

+ 每输入一个字符，就会触发一次input事件
+ 只有内容完全输入完毕并失去了焦点，才会触发change事件



在表单中，按钮元素（`<button>`）如果没有显式指定 `type` 属性，其默认类型是 `submit`，即它默认会触发表单的提交操作。

虽然点击按钮元素可以触发表单的 `submit` 或 `reset` 事件，但这些事件实际上是绑定在 `<form>` 元素上的，而不是按钮或其他表单控件上。因此，当这些事件触发时，事件回调函数中的 `this` 关键字会指向对应的 `<form>` 元素。

需要注意的是，表单控件（如 `<input>`, `<button>`, `<select>` 等）本身并不具有 `submit` 或 `reset` 事件，这些事件仅适用于 `<form>` 元素。

