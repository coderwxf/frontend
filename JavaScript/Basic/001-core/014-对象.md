## 创建对象

1. 字面量创建
2. 通过`new Object()`
3. 通过自定义构造函数



## 批量创建对象

1. 工厂函数

   + 工厂函数是一种设计模式，它可以帮助我们创建相似的对象。
   + 通过工厂函数，我们可以传入不同的参数，快速创建对象

   ```js
   function createPerson(name, age) {
       return {
           name: name,
           age: age,
           greet: function() {
               console.log("Hi, I'm " + this.name);
           }
       };
   }
   
   let person1 = createPerson("Alice", 25);
   let person2 = createPerson("Bob", 30);
   ```

2. 构造函数

   + 本质就是普通函数，但因为调用方式不同「 new调用和小括号调用 」，执行流程也不同
   + 为了和普通函数进行区分，构造函数采用大驼峰写法

   ```js
   function Person(name, age) {
       this.name = name;
       this.age = age;
       this.greet = function() {
           console.log("Hi, I'm " + this.name);
       };
   }
   
   let person1 = new Person("Alice", 25);
   let person2 = new Person("Bob", 30);
   ```

   

## 对象的常见操作

对象的操作在非严格模式下，一旦失败是静默失效，在严格模式下，执行失败才会包错

1. **访问对象的属性**

   - 使用点语法或方括号语法访问对象的属性。
   - 对于某些属性，JavaScript 无法直接理解，比如属性名中包含空格或特殊字符的情况。此时，我们需要使用方括号来获取属性值。
   - 方括号还可以用于变量名作为属性名的情况
   - 方括号中如果是普通属性名，则需要加上引号

   ```javascript
   console.log(obj1.name); // Alice
   console.log(obj1['age']); // 25
   ```

2. **修改对象的属性**

   - 直接赋值修改对象的属性。

   ```javascript
   obj1.name = 'Alice Updated';
   obj1['age'] = 26;
   ```

3. **添加新的属性**

   - 可以动态地为对象添加新的属性。

   ```javascript
   obj1.height = 170;
   obj1['weight'] = 60;
   ```

4. **删除对象的属性**

   - 使用 `delete` 操作符删除对象的属性。
   - `delete`操作符会返回一个布尔值
     + 如果删除成功，`delete` 操作符返回 `true`
     + 如果删除失败，`delete` 操作符返回 `false`

   ```javascript
   delete obj1.height;
   delete obj1['weight'];
   ```

   + 试图删除不可配置的属性（如通过 `Object.defineProperty` 定义的不可配置属性）时delete操作符才会返回false

   + 试图删除一个不存在的属性会返回 `true`，因为对于不存在的属性，删除操作被认为是成功的。

     ```js
     let obj = {
       name: 'Alice',
       age: 25
     };
     
     // 删除存在的属性
     console.log(delete obj.age); // true
     console.log(obj); // { name: 'Alice' }
     
     // 删除不存在的属性
     console.log(delete obj.height); // true
     
     // 删除不可配置的属性
     Object.defineProperty(obj, 'name', {
       configurable: false,
       writable: true,
       enumerable: true,
       value: 'Alice'
     });
     
     console.log(delete obj.name); // false
     console.log(obj); // { name: 'Alice' }
     ```

   + `delete` 操作符只能删除对象的属性，不能删除变量

     ```js
     let x = 10;
     console.log(delete x); // false
     console.log(x); // 10
     ```



## 计算属性

```js
const dynamicKey = 'role';
const user = {
  name: 'John',
  // 计算属性中可以是变量，也可以是表达式
  ['add' + 'ress']: 'shanghai',
  [dynamicKey]: 'admin'
};
console.log(user.role); // 输出：admin
```



## 对象的迭代方式

1. 普通for + `Object.keys()/Object.values()/Object.entries()`

2. `for-in` + `obj.hasOwnProperty(key)`

   + `for-in`会迭代自身和原型上所有非symbol可枚举属性，所以需要结合`hasOwnProperty`一起使用
   + `for [key] in [obj]`这里获取的key值的类型是字符串

3. `for-of`

   + 迭代的内容需要是可迭代对象，本质使用的是`Symbol.iterator`
   + **原生对象 默认是 不可迭代的**

   ```js
   let iterableInfo = {
     *[Symbol.iterator]() {
       for (let key of Object.keys(this)) {
         yield [key, this[key]];
       }
     }
   };
   
   for (let [key, value] of iterableInfo) {
     console.log(`Key: ${key}, Value: ${value}`);
   }
   ```



- `Object.keys()`、`Object.values()` 和 `Object.entries()` 只获取对象自身的可枚举非 `Symbol` 属性。
- `Object.getOwnPropertyNames()` 获取对象自身的所有非 `Symbol` 属性（包括不可枚举属性）。
- `Object.getOwnPropertySymbols()` 获取对象自身的所有 `Symbol` 属性。
- `Reflect.ownKeys()` 获取对象自身的所有属性（包括可枚举和不可枚举属性，以及 `Symbol` 属性）。



## 引用赋值

你运行一个程序，不管是本地程序还是浏览器中的JavaScript代码，程序都会被加载到内存中执行。

浏览器在运行时，会为每一个标签页创建一个独立的进程，在这个进程中又包含多个线程来执行代码。

内存可以简单地划分为栈内存和堆内存。栈内存主要用来存储**基本数据类型和函数调用栈**，而堆内存则用于**存储对象和复杂数据结构**。

- 基本数据类型存储在栈内存中，直接保存值。
- 对象类型存储在堆内存中，变量保存对象的引用。
- 修改引用类型变量的属性会影响所有引用该对象的变量。

例如我们比较两个对象：

```javascript
let obj1 = {};
let obj2 = {};
```

这两个对象是不相等的，即使它们的内容相同，因为它们在内存中是不同的对象。比较对象时，实际上是在比较它们的内存地址。



当我们将一个对象赋值给另一个变量时，实际上是复制了对象的引用地址。这就是引用赋值



## 构造函数

JavaScript 提供了一种更符合面向对象思维方式的创建对象的方法，这便是构造函数

一般情况下，构造函数首字母大写，以和普通对象进行区分

```js
function Student(name, age, height) {
    this.name = name;
    this.age = age;
    this.height = height;
}
```

只要构造函数通过new调用，内部this的值就是新建实例对象



通过 `new` 操作符调用构造函数时，JavaScript 引擎会自动执行以下步骤：

1. 在内存中创建一个空对象。
2. 将空对象赋值给 `this`。
3. 将构造函数的显示原型赋值给实例对象的隐式原型。
4. 执行构造函数内部的代码。
5. 如果构造函数没有返回非空对象，则自动返回 `this` 指向的新对象。
   + 如果构造函数显式地返回一个对象，那么返回的就是这个对象。
   + 如果构造函数没有显式地返回对象，或者显式地返回的是一个非对象值，则默认返回 `this`，即新创建的对象。

构造函数的优点:

1. 构造函数可以看成是简化了的工厂函数，简化了`对象的创建和对象的返回`，当我们通过new关键字进行调用时，JavaScript 引擎会自动帮我们创建对象并返回，而不需要手动返回 `this`
2. 通过构造函数创建的实例会继承构造函数的原型，因此它们具有更具体的类型信息（即构造函数的类型），而工厂函数返回的对象默认都是 `Object` 的实例，除非手动设置原型。



## 面向对象

面向对象编程的核心在于通过抽象和封装，将多个实例的公共属性和方法提取出来，形成一种用于创建实例的模板——类 「 一种新的数据结构 」。类定义了对象的属性（状态）和方法（行为），而具体的属性值则通过构造函数在实例化时传入。

为了减少重复代码的编写，多个类的公共部分可以进一步抽取，形成一个父类（基类）。子类通过继承父类，自动获得父类的属性和方法，同时可以根据需求重写父类的方法，从而实现定制化的行为。这种继承机制不仅提高了代码的重用性，还增强了系统的灵活性和可维护性。



在ES5中，构造函数其实就是类

```js
function Student(name, age) {
  this.name = name;
  this.age = age;
}

Student.prototype.greet = () => {
  console.log(`Hello, my name is ${this.name}`);
}

let student = new Student("Charlie", 23);
console.log(student instanceof Student); // true
```



在ES6之后，JavaScript引入了`class`关键字，使得定义类更加直观。

ES6的class本质是ES5中通过function关键字定义构造函数的语法糖写法

```js
class Animal {
  constructor(name) {
      this.name = name;
  }

  speak() {
      console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  speak() {
      console.log(`${this.name} barks.`);
  }
}

let dog = new Dog("Rex");
dog.speak(); // Rex barks.
```



### 面向对象的三大特性

1. **封装性**: 

   +  **封装**是指将对象的属性（数据）和方法（行为）封装在一个统一的结构中，使它们作为一个整体来运作。
   + 在这一过程中，可以将某些属性设置为私有属性，以隐藏其内部实现细节。
   + 此外，可以通过定义`getter`和`setter`方法来拦截对这些属性的访问和修改，从而在读取属性或设置属性时插入额外的逻辑，如数据验证、转换或日志记录，实现类似于中间件的效果。

   

2. **继承性**:  继承允许一个类（子类）从另一个类（父类）获得属性和方法，实现代码的重用。子类继承了父类的所有特性，同时可以根据需要对父类的方法进行修改或扩展，以适应新的需求。



3. **多态性**:   **多态**是指不同的实例在调用同名方法时，可以表现出不同的执行效果。
   1. 多态的前提是继承，即子类继承父类的属性和行为。
   2. 子类可以通过重写（override）父类的方法来提供自己的具体实现。
   3. 多态性允许通过向上转型 「 将一个更具体的子类对象引用转型为更一般的父类引用 」，将子类的对象赋给父类的引用（例如：`Parent p = new Child();`）。这实际上是一种类型缩小的表现。
   4. 在运行时，根据对象的实际类型，调用相应的子类方法，从而实现多态行为。



## 全局对象

### globalThis

`globalThis` 是 JavaScript 中表示全局对象的统一方式，在不同的运行环境下，它对应的全局对象有所不同：

- 在浏览器环境中，`globalThis` 对应 `window` 对象。
- 在 Node.js 环境中，`globalThis` 对应 `global` 对象。



#### window

1. window是作用域链的头，即变量查找的最终位置。

2. 浏览器提供的一些全局对象和方法实际上是定义在`window`对象上的。

   通过window去调用其属性和方法时，可以省略window

   ```js
   window.alert()
   // 等价于
   alert()
   ```

3. 使用`var`定义的变量会被默认添加到`window`对象上的 「 这是不被推荐的  」

   隐式全局变量会被添加到window对象上 「 这是不被推荐的  」

   使用`let`或`const`定义的变量不会被添加到`window`对象上

4. `window`对象有一个属性也是`window`，即`window.window`指向自身。这种关系可以一直递归下去，即`window.window.window`也是指向`window`对象。



#### global

node中的全局对象

1. 隐式全局变量，会被挂载到global下
1. var声明变量，可以访问，但不会被挂载到global下
1. let/const声明变量，可以访问，不会挂载到global下



### Function

函数的本质是一种特殊的可执行对象，其是通过`Function`函数来创建的

```js
function sum(num1, num2) {
	return num1 + num2
}

/* 
	本质如下:
  1. 最后一个参数是字符串类型函数体
  2. 之前的参数，分别依次是对应的形参列表
*/
const sum = new Function('num1', 'num2', 'return num1 + num2');
```



在JavaScript中，函数也是对象，因此它们既可以被执行，也可以拥有属性。

```js
function Dog() {}
Dog.running = function() {
    console.log("Running");
};
Dog.running(); // 输出: Running
```

在这个例子中，`Dog.running` 是通过 `Dog` 函数直接调用的方法。这种方法通常被称为**静态方法** 「又叫类方法」。

静态方法是定义在构造函数或类上的方法，可以通过类名或构造函数名直接调用。

通用的，直接定义在类上的属性被称之为静态属性，本质上静态方法是一种特殊的静态属性。



## 获取属性描述符

```js
const user = {
  name: 'Klaus',
  age: 23
}

console.log(Object.getOwnPropertyDescriptor(user, 'name'))

console.log(Object.getOwnPropertyDescriptors(user))
```



## Object fromEntries

+ Object.entries 将一个普通对象 转换成 entries
+ Object fromEntries 将 entries 转回 普通对象



## 去除空格

```js
const str = '   World   '

// 去除首尾空格
console.log(str.trim()) // => World (首尾空格皆被移除)

// 去除首部空格
console.log(str.trimStart()) // => World   （尾部有未移除的空格）

// 去除尾部空格
console.log(str.trimEnd()) // =>    World （首部有未移除的空格）
```



## Object.hasOwn

Object中新增了一个静态方法（类方法）： hasOwn(obj, propKey)

`Object.hasOwn方法`用于判断一个对象中是否有某个自己的属性

```js
const user = {
  name: 'Klaus',
  __proto__: {
    age: 23
  }
}

// hasOwn是Object的静态方法
// 参数一: 需要查找的那个对象
// 参数二: 对应的需要查找的属性
console.log(Object.hasOwn(user, 'name')) // => true
console.log(Object.hasOwn(user, 'age')) // => false
```

`Object.hasOwn方法`的功能和以前的`Object.prototype.hasOwnProperty`方法的功能是一致的，其使用用来替换`hasOwnProperty`方法的

```js
const user = Object.create(null, {
  name: {
    value: 'Klaus'
  }
})

// 此时使用Object.prototype.hasOwnProperty方法 就会出错
// 因为user的原型对象为null
console.log(user.hasOwnProperty('name')) // error

// 此时就只能使用Object.hasOwn方法
console.log(Object.hasOwn(user, 'name')) // => true
```

