## 定时器

浏览器存在两类定时器

+ `const timerId = setTimeout(() => {}[, delay, arg1, arg2, ...])` 

  ​	=> `clearTimeout(timerId)`

+ `const intervalId = setInterval(() => {}[, delay, arg1, arg2, ...])` 

  ​	=> `clearInterval(intervalId)`

1. 既可以在浏览器运行，也可以在node运行
2. `setTimeout`是过一段时间执行回调，`setInterval`是按照某个间隔重复执行回调
3. `setTimeout`和`setInterval`都会返回number类型值，用于标识对应定时器 「 功能是清除对应定时器 」
4. `clearTimeout(timerId)`和`clearInterval(intervalId)`都用于清除定时器标识对应定时器
   + `setTimeout`用`clearTimeout`清除
   + `setInterval`用`clearInterval`清除
   + **如果定时器标识不存在，则静默失效。如果定时器标识存在，则清除定时器**
5. `setTimeout`和`setInterval`都是宏任务
6. `setTimeout`和`setInterval`的`delay`单位都是毫秒，默认值是`0`



## requestAnimationFrame

定时器是宏任务，需要等微任务执行完毕才会执行。这就导致了定时器的时间并不是非常准确的，存在误差

`requestAnimationFrame`会在屏幕自动刷新时被回调，从而更加平稳和更加精准



浏览器会为保证操作平滑，默认大多数屏幕的刷新频率都是60HZ，也就是每一秒，屏幕会自动刷新60次

此时将会产生重绘和回流的操作在浏览器自己刷新的时候一并执行，就可以最大程度去减少浏览器的重绘和回流



所以`requestAnimationFrame` 的本质并不是定时器，而是一个浏览器为优化动画效果而提供的接口。

因此只有浏览器环境才有`requestAnimationFrame`， node中并不存在

可以简单将`requestAnimationFrame`看成是`delay`固定的`setTimeout`



`requestAnimationFrame`既不是宏任务也不是微任务。它不是由传统的事件队列来控制的，而是和屏幕的刷新频率保持一致，在屏幕进行刷新前执行回调



同时浏览器对requestAnimationFrame的回调函数的调用进行了如下优化

1. 对于不是激活状态的页面，requestAnimationFrame对应的回调会停止执行，知道页面恢复激活状态
2. 对于隐藏，不可见的元素，requestAnimationFrame会自动失效，因为对看不见的元素执行动画是没有任何意义的



```js
// requestAnimationFrame也会返回number类型值，表示requestAnimationFrame标识
const timer = requestAnimationFrame(function fn() {

  console.log('requestAnimationFrame被回调了')

  // 默认requestAnimationFrame效果和setTimeout一致
  // 如果要模拟setInterval, 需要通过递归
  requestAnimationFrame(fn)
})

// 使用cancelAnimationFrame方法 清除requestAnimationFrame
cancelAnimationFrame(timer)
```

