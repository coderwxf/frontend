### eval

1. 参数是代码字符串
2. 会执行参数，并将最后一条语句的结果返回



不推荐使用`eval`

1. 容易被XSS
2. 可读性差
3. eval的参数不会被JS引擎优化后再被执行 「 例如可能无法转换为被优化的机器码 」



```js
let msg = 'Hello World'

// eval会创建一个独立的作用域
eval("var username = 'Klaus'; let age = 23; console.log(msg);")

console.log(username) // => Klaus
console.log(age) // error
```



### 严格模式

JavaScript的更新是向后兼容的，所以即使更新了新语法，旧语法依旧存在，这种默认模式被称之为**懒散(sloppy)模式**

可以开启严格模式，以只支持正常语法，而不支持老版本语法和新特性语法

1. 静默错误将不再静默，而是抛出错误
2. JS运行效率变高 「 不需要兼容老语法 」
3. 不支持老版本语法，也不支持处于实验性的新语法



通过`use strict`开启严格模式

1. 可以为整个JavaScript文件开启
2. 可以为某个函数单独开启



1. 严格模式一但开启，无法关闭
2. 在以下情况下，默认会开启严格模式:
   + 类
     - **ES6 模块语法**默认启用严格模式，即使你没有手动添加 `"use strict";`
     - **CommonJS 模块**不会默认启用严格模式，除非你在模块中手动添加 `"use strict";`
   + ES模块
   + 打包工具构建后的代码



开启严格模式后：

1. 隐式全局变量会报错
2. 静默错误将抛出异常 「 删除不可删除属性，修改只读变量 」
3. 函数参数无法同名
4. 八进制不允许以`0`开头 「 现在使用`0o`, 早期才是`0` 」
5. 不能使用with关键字
6. this不会进行隐式转换
7. 全局this为undefined
8. `eval`内定义的变量，外部无法访问

```js
"use strict"

eval("var username = 'Klaus';")

// 严格模式下，eval中定义的变量 在eval外将无法获取
console.log(username) // error
```



## 展开运算符

1. 在函数调用或构造数组时，将数组或字符串 转换为队列传入 「 ...iterable 」
2. 字面量构造对象时，浅拷贝对象 「 ...obj 」

```js
function foo(...args) {
  console.log(args)
}

const name = 'Klaus'
const users = ['Klaus', 'Alex', 'Jhon']

const info = {
  name: 'Klaus',
  age: 23
}

foo(...name) // => [ 'K', 'l', 'a', 'u', 's' ]
foo(...users) // => [ 'Klaus', 'Alex', 'Jhon' ]

// 对象默认不是可迭代的，所以默认情况下，函数参数中的展开运算符不可以用在对象上
foo(...info) // error
```

```js
const name = 'Klaus'
const users = ['Klaus', 'Alex', 'Jhon']

const info = {
  name: 'Klaus',
  age: 23
}

// 构造数组字面量的时候，可以使用展开运算符
console.log([...users, 'Steven']) // => [ 'Klaus', 'Alex', 'Jhon', 'Steven' ]

// 在构建对象字面量时，也可以使用展开运算符 
//「 调用Object.keys并对结果进行迭代 -- 本质是key-value的浅拷贝 」
const userInfo = {
  ...info,
  address: 'shanghai'
}

console.log(userInfo) // => { name: 'Klaus', age: 23, address: 'shanghai' }
```

