JavaScript使用动态类型，也就是弱数据类型 「 鸭子类型 」

在JavaScript中，一共有8中数据类型，分别是7种基本数据类型语言和1种复杂数据类型

`7种基本数据类型` 

+ Number
+ String
+ Boolean
+ Null
+ Undefined
+ BigInt
+ Symbol

`1种复杂数据类型` 

+ Object



## number

1. 不区分 整数 和 浮点数
2. NaN 「 isNaN 」
3. Infinity / -Infinity 「 1 / 0 结果是 Infinity 」
4. Number.MIN\_VALUE / Number.MAX\_VALUE 「 小于 Number.MIN\_VALUE，会被自动转为0 」
5. Number.MIN_SAFE_INTEGER / Number.MAX_SAFE_INTEGER

```js
// 十进制
const num = 100

// 二进制 -> 0b中的b不区分大小写
const bin = 0b100

// 八进制 -> 0o中的o不区分大小写
const oct = 0o100

// 十六进制 -> 0x中x不区分大小写
const hex = 0x100

// 无论变量使用什么进制进行编写
// 输出的最终结果默认都是十进制
console.log(num, bin, oct, hex) // => 100 4 64 256
```



## string

字符串底层以字符数组的形式进行解析和使用，但并不存在字符类型变量



### `\r 和 \n`

在某些老式的打字机和计算机系统中

- 回车字符(`\r`)会将打印头移到行的开头
- 换行字符(`\n`) 会将光标移到下一行，但不移动到行的开头

现代系统中，`\r`和`\n`的区别仅在他们作为换行符使用的时候

| 换行符 | 说明                                                      |
| ------ | --------------------------------------------------------- |
| `\r`   | 在早期的 Mac 系统 中被用作换行符                          |
| `\n`   | 在 Unix 和类 Unix 系统（如 Linux 和 macOS）中被用作换行符 |
| `\r\n` | 在 Windows 系统中，`\r\n` 被用作换行符                    |



### 标签模板字符串

标签模板字符串是一种特殊的函数调用方式，也是一种特殊的模板字符串

```js
function foo(...args) {
  console.log(args)
}

// 标签模板字符串调用 -> 一种特殊的函数调用方式
foo`my name is, my age is`
// => [['my name is, my age is']]
```

```js
const username = 'Klaus'
const age = 24

// 模板字符串会被解析形成如下参数后被传入对应函数:
// 1. 第一个元素是数组，是被模块字符串拆分的字符串组合
// 2. 之后的参数内容是一个个模块字符串传入的变量值
foo`my name is ${username}, my age is ${age}`
// => [ [ 'my name is ', ', my age is ', '' ], 'Klaus', 24 ]
```



## boolean

1. 用于表示真假
2. `true | false`

**falsy值**

1. `false`
2. `0`
3. `-0`
4. `0n` (BigInt zero)
5. `""` (空字符串)
6. `null`
7. `undefined`
8. `NaN`

除上述值以外的所有值在布尔上下文中都被视为 "truthy"



## null 

JavaScript中null 被认为是一种特殊的对象，即空对象



## bigint

1. `bigint`的表示方式是在数值的最后加上`n`
2. 用于表示大于`MAX_SAFE_INTEGER`的整数

```js
// 只要数值后边有n，就是bigint - 前边的数值不一定很大
const bingInt =  1n

// bigint和number的底层实现完全不同，所以不能一起使用
console.log(1n + 2n) // => 3n
console.log(1n + 2) // error

console.log(Number(1n)) // => 1
console.log(1n + '2') // => '12'
```



## symbol

1. `symbol`用于表示独一无二的值
2. 作为对象的key属性

```js
// 通过Symbol函数创建symbol值 「 没有字面量创建方式 」
const s1 = Symbol() // => Symbol()
const s2 = Symbol()

// Symbol函数执行后每次创建出来的值都是独一无二的
console.log(s1 == s2) // => false
console.log(s1 === s2) // => false
```



Symbol值不能进行运算, 但可以转换为字符串和布尔值

```js
const symbol = Symbol()

// console.log(symbol + 2) => error

console.log(symbol.toString()) // => 'Symbol()'
console.log(!!symbol) // => true
```



`description`的类型为`string`, 其余类型会被转换为字符串后再使用

「 TS中允许的类型是`string | number` 」

```js
const s1 = Symbol('name')
console.log(s1) // => Symbol(name)
```



当`Symbol.for`所传入的key一致时，即认为这2个symbol值是相等的

如果省略参数，key默认为`undefined`

`Symbol.for`方法会先根据key去进行查找

- 如果对应的key已经被创建就直接返回对应的symbol值
- 如果对应的key没有被创建，那么会新建一个新的symbol值，并将其返回

```js
const s1 = Symbol.for()
const s2 = Symbol.for()
console.log(s1 === s2) // => true
```



```js
// 对于description, 可以通过symbol的description属性去进行获取
let s = Symbol('bar')
console.log(s.description) // => bar

// 对于key, 可以通过symbol的keyFor方法进行获取
s = Symbol.for('baz')
console.log(Symbol.keyFor(s)) // => baz
```



```js
const user = {
  name: 'Klaus',
  age: 23,

  [Symbol('address')]: 'shanghai',
  [Symbol('height')]: 1.88
}

// JSON.stringify 方法将对象转换为字符串的时候，会自动过滤symbol属性, 因为JSON不支持Symbol类型

// Object.keys 获取自身可迭代 非Symbol类型值
console.log(Object.keys(user)) // => [ 'name', 'age' ]

// 如果我们需要获取到Symbol属性值，需要使用Object.getOwnPropertySymbols方法
console.log(Object.getOwnPropertySymbols(user)) 
// => [ Symbol(address), Symbol(height) ]

// 使用Reflect.ownKeys 可以获取对象自身的所有的属性名，包括symbol属性名，可迭代属性名和不可迭代属性名
console.log(Reflect.ownKeys(user)) 
// => [ 'name', 'age', Symbol(address), Symbol(height) ]
```



### 内置symbol值

#### **toStringTag**

1. 是一个getter
2. 返回值需要时字符串类型值，如果返回值不是字符串类型值则静默失效，不进行任何转换

```js
const user = {
  name: 'Klaus',
  age: 23,

  get [Symbol.toStringTag]() {
    return this.name
  }
}

console.log(user.toString()) // => [object Klaus]
```



如果直接返回字符串类型值，且没有额外处理逻辑，则存在对应语法糖写法

```js
const user = {
  name: 'Klaus',
  age: 23,
  [Symbol.toStringTag]: 'Klaus'
}

console.log(user.toString()) // => [object Klaus]
```



#### **iterator**

覆盖默认的迭代方式或将非迭代对象转换为可迭代对象

```js
const user = {
  name: 'Klaus',
  age: 23,
  /* 底层调用方式类似于 user[Symbol.iterator]() */
  *[Symbol.iterator]() {
    yield* Object.entries(this)
  }
}

for (const [key, value] of user) {
  console.log(`${key} - ${value}`)
  /*
    => 
      name - Klaus
      age - 23
  */
}
```



#### **toPrimative**

##### toString

将参数转换为字符串形式，如果是对象会输出类似于`[object Type]`的形式，类似于`[object Object]`

部分内置对象重写了`toString`方法, 存在自己的转换行为

```js
const obj = {}
const arr = [1, 2, 3]
const fun = () => {}
const err = new Error('我是错误信息')
const date = new Date()

console.log(obj.toString()) // => '[object Object]'

// 数组输出的是arr.join(',') ---- 如果是空数组，返回的就是空字符串
console.log(arr.toString()) // => '1,2,3'
console.log([].toString()) // => ''
console.log([3].toString()) // => '3'

// 函数返回函数体本身
console.log(fun.toString()) // => '() => {}'
console.log(err.toString()) // => 'Error: 我是错误信息'
console.log(date.toString()) // 'Fri Nov 05 2021 13:57:12 GMT+0800 (中国标准时间)'
```



##### valueOf

输出对象的原始值，如果对象不存在对应原始值则返回对象本身

部分内置对象重写了`valueOf`方法, 存在自己的转换行为

```js
const num = 123
const str = 'Klaus'
const numObj = new Number(321)
const strObj = new String('Steven')

console.log(num.valueOf()) // => 123
console.log(str.valueOf()) // => 'Klaus'
console.log(numObj.valueOf()) // => 321
console.log(strObj.valueOf()) // => 'Steven'

const fn = () => {}
const arr = [1, 2, 3]

console.log(fn.valueOf()) // => [Function: fn]
console.log(arr.valueOf()) // => [1, 2, 3]

// Date实例重写了valueOf
// 1. new操作符的优先级 高于 方法调用
// 2. Date实例的valueOf方法返回的是时间戳
console.log(new Date().valueOf()) // => 1724245784593
```



##### **toPrimative**

对象转基本数据类型时会被调用

1. 严格判断，不进行类型转换，不调用`toPrimative`
2. 转布尔，不调用`toPrimative`

```js
toPrimitive(target, preferType = 'default': 'string' | 'number')
```



默认值是`default`，其表现行为和`number`保持一致

默认的`toPrimative`本质是根据不同情况调用内置的`toString`和`valueOf`



`preferType`的值为`number

1. 调用`valueOf`
2. `valueOf`转不了，调用`toString`
3. `toString`也转不了，直接报错, 但如果`toString`可以转换，则将转换后的基本类型再转`number`



`preferType`的值为`string

1. 调用`toString`
2. `toString`转不了，调用`valueOf`
3. `valueOf`也转不了，直接报错，但如果`valueOf`可以转换，则将转换后的基本类型再转`string`



某些内置对象重写了`toPrimitive`方法，存在自己的转换规则

```js
const dateValueOf =  Date.prototype.valueOf
const dateToString =  Date.prototype.toString

// 添加Date的valueOf日志
Date.prototype.valueOf = function () {
  console.log('date valueOf')
  return dateValueOf.call(this)
}

// 添加Date的toString日志
Date.prototype.toString = function () {
  console.log('date toString')
  return dateToString.call(this)
}

const date = new Date()

// Date重写了toPrimitive方法
// 所以在执行加法操作或判等操作时，preferType的值是string, 而不是number
console.log(date + 1)
console.log(date == 2)
```



##### Symbol.toPrimitive

可以通过`Symbol.toPrimitive`重写内部`toPrimitive`方法

hint类型是default | string | number 「 默认值是default，行为和number一致 」



1. 当hint值为number， 表示 对象 -> number
2. 当hint值为string， 表示 对象 -> string
3. 当hint值为default， 表示 对象 -> string | number



- 加号可能是数字相加 也可能是字符串拼接 --- hint的值就是default
- 判等操作(即 == 和 !=) --- hint的值也是default

```js
const obj = {
  name: '',

  [Symbol.toPrimitive]: hint => {
    if (hint === 'number') {
      return 0
    } else if (hint === 'string') {
      return ''
    } else {
      return false
    }
  }
}
```



## typeof 

使用 typeof 操作符会返回如下结果中的一种:

| 结果      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| number    | 值的类型为数值                                               |
| string    | 值的类型为字符串                                             |
| boolean   | 值的类型为布尔类型                                           |
| undefined | 值的类型为undefined                                          |
| object    | `值的类型为object或null`<br />因为null一般用来表示一个对象为空<br />在JS中，typeof 对象(除函数外)结果都是object，包括set，map，数组等 |
| function  | 值的类型为函数                                               |
| symbol    | 值的类型为symbol                                             |



在JavaScript中，最精确的类型判断方式是`Object.prototype.toString`

```js
console.log(toString.call(''))           // => [object String]
console.log(toString.call(22))           // => [object Number]
console.log(toString.call(undefined))    // => [object Undefined]
console.log(toString.call(null))         // => [object Null]
console.log(toString.call(new Date))     // => [object Date]

console.log(toString.call(Math))         // => [object Math]
console.log(toString.call(globalThis))   // => [object Window] / [object global]

console.log(toString.call(()=>{}))       // => [object Function]
console.log(toString.call({}))           // => [object Object]
console.log(toString.call([]))           // => [object Array]

console.log(toString.call(new Set()))    // => [object Set]
console.log(toString.call(new Map()))    // => [object Map]
```



## 类型转换

### to String

#### **隐式转换**

1. 字符串拼接
2. 某些方法会将参数自动转换为字符串 「 alert、prompt 」



#### **显示转换**

1. `String()`
2. `xxx.toString()`
   + `null` 和 `undefined` 没有包装类，不能调方法
   + `(123).toStirng()`、`123..toString()`
   + `({}).toString()`、`(function() {}).toString()`



### to Number

#### 隐式转换

1. 四则运算



#### 显示转换

1. `Number()`

   | 值            | 转换后                                                       |
   | ------------- | ------------------------------------------------------------ |
   | undefined     | NaN                                                          |
   | null          | 0                                                            |
   | true 和 false | true -\> 1    false -\> 0                                    |
   | string        | 1. 在进行类型转换前会去除字符串首尾空格后再进行类型转换<br />2. 如果去除空格后的字符串是空字符串 -\> 0<br />3. 如果去除空格后的字符串中存在非数值型字符 -\> NaN<br />4.  如果去除空格后的字符串中只存在数值型字符 -\> 数值型字符对应的数字 |
   | object        | 任何的对象类型在使用Number函数转换为number类型值的时候，结果都是NaN<br />包括空对象 |

2. `parseInt()/parseFloat()`

   + 在转换前会先去除首尾空格



### to Boolean

#### 隐式转换

1. 逻辑判断语句中



#### 显示转换

1. `Boolean()`
2. `!!x`

