JavaScript使用动态类型，也就是弱数据类型

在JavaScript中，一共有8中数据类型，分别是7种基本数据类型语言和1种复杂数据类型

`7种基本数据类型` 

+ Number
+ String
+ Boolean
+ Null
+ Undefined
+ BigInt
+ Symbol

`1种复杂数据类型` 

+ Object



## Number

1. JavaScript只有数值类型，不区分整数或浮点数
2. **Infinity**
   + `Infinity` - 正无穷，`-Infinity` - 负无穷
   + `1 / 0`得到的结果就是无穷大
3. **NaN**
   + `not a number`的简写，表示该值不是number类型, 但`NaN`本身是number类型值
   + `isNaN`方法判断参数是否是NaN
   + 任何的值和NaN进行比较的时候，结果都为false，包括是NaN和其自身进行比较

```js
// MIN_VALUE和MAX_VALUE等都是常量值，所以全大写 
// 「 这些属性也被称之为类属性 或 静态属性 」

Number.MIN_VALUE // 最小浮点数 - 小于这个数会被转换为0
Number.MIN_SAFE_INTEGER // 最小整数

Number.MAX_VALUE // 最大数
Number.MAX_SAFE_INTEGER // 最大整数
```



**其它进制表示**

```js
// 十进制
const num = 100

// 二进制 -> 0b中的b不区分大小写
const bin = 0b100

// 八进制 -> 0o中的o不区分大小写
const oct = 0o100

// 十六进制 -> 0x中x不区分大小写
const hex = 0x100

// 无论变量使用什么进制进行编写, 输出的最终结果默认都是十进制
console.log(num, bin, oct, hex) // => 100 4 64 256
```



为了方便进行阅读，可以使用`_`对长数字进行分割 

「 这种分割方式只是语法糖，并不影响JavaScript Engine对其的解析 」

```js
let num = 10_000_000
num = 1_0_00_000
```



## bigint

大于MAX_SAFE_INTEGER的数，直接使用number可能出现运行错误，为此ES提供了新的数据类型`bigint`

`bigint`的表示方式是在数值的最后加上`n`

```js
// 只要数值后边有n，就是bigint - 前边的数值不一定很大
const bingInt =  1n

// bigint和number的底层实现完全不同，所以不能一起使用
console.log(1n + 2n) // => 3n
console.log(1n + 2) // error

console.log(1n + '2') // '12'
```



## boolean

1. 用于表示真假
2. `true | false`



**falsy值**

1. `false`
2. `0`
3. `-0`
4. `0n` (BigInt zero)
5. `""` (空字符串)
6. `null`
7. `undefined`
8. `NaN`

除上述值以外的所有值在布尔上下文中都被视为 "truthy"



## string

在JavaScript中，字符串可以使用单引号，双引号和反引号进行包裹

单引号和双引号之间没有任何区别，反引号可以插入变量和换行编写 

「 反引号包裹的字符串也叫模板字符串 」

字符串的前后引号类型必须一致，不同引号类型之间不可以混用

```js
const firstWord = "Hello"
const lastWord = 'World'

// 通过 ${expression} 来插入JavaScript表达式
const word = `${firstWord + ' ' + 'lastWord'}` // -> Hello Wolrd
```



字符串是只读的，具有不可变性

所有对字符串的方法本质都会返回一个新的字符串，而不是修改源字符串

在底层操作中，字符串会被当做字符数组进行处理，但JavaScript中并没有字符类型值

```js
const str = 'Hello World'

// length属性可以获取字符串的长度
console.log(str.length) // => 11
```



### 标签模板字符串

标签模板字符串是一种特殊的函数调用方式，也是一种特殊的模板字符串

很少直接使用标签模板字符串，但是在使用一些第三方库的时候，其内部函数调用可能需要我们以标签模板字符串的形式去进行调用，如`styled-components`

```js
function foo(...args) {
  console.log(args)
}

// 普通调用
foo(10, 20, 30)

// 标签模板字符串调用 -> 一种特殊的函数调用方式
foo`my name is, my age is`
// => [['my name is, my age is']]
```

```js
const username = 'Klaus'
const age = 24

// 模板字符串会被解析形成如下参数后被传入对应函数:
// 1. 第一个元素是数组，是被模块字符串拆分的字符串组合
// 2. 之后的参数内容是一个个模块字符串传入的变量值
foo`my name is ${username}, my age is ${age}`
// => [ [ 'my name is ', ', my age is ', '' ], 'Klaus', 24 ]
```



### 转义字符

如果某个字符在字符串中存在特殊含义，则需要在特殊字符之前加上转义字符

![image.png](https://s2.loli.net/2024/08/21/D2ldQ9RFPyHaIY6.png) 



#### `\r 和 \n`

在某些老式的打字机和计算机系统中

+ 回车字符(`\r`)会将打印头移到行的开头
+ 换行字符(`\n`) 会将光标移到下一行，但不移动到行的开头

现代系统中，`\r`和`\n`的区别仅在他们作为换行符使用的时候

| 换行符 | 说明                                                      |
| ------ | --------------------------------------------------------- |
| `\r`   | 在早期的 Mac 系统 中被用作换行符                          |
| `\n`   | 在 Unix 和类 Unix 系统（如 Linux 和 macOS）中被用作换行符 |
| `\r\n` | 在 Windows 系统中，`\r\n` 被用作换行符                    |



## undefined

1. undefined 类型只有一个值，那就是 undefined
2. 以下情况下，变量的默认值为undefined
   + 变量声明了但未初始化
   + 访问对象上不存在的值

> 1. 不推荐显示使用`undefined`
> 2. 在定义变量的时候，尽可能对变量进行初始化，而不是使用默认值undefined



### void 0

- `undefined` 是 JavaScript 中的一个全局变量，表示变量未被赋值或未被定义。
- `void 0` 是一个表达式，使用 `void` 运算符对任何值（通常是 0）进行操作，结果总是 `undefined`

在早期的 JavaScript 版本中（ES3 及之前），`undefined` 是一个可被重定义的变量。所以使用 `void 0` 可能会被认为是一种更安全的做法。

但这个问题在ES3中已被修复，所以在现代 JavaScript 中，直接使用 `undefined` 是安全的且更直观



## null

1. `null`只有一个值即为`null`
2. 一般用于表示对象为空，指向了一个特殊内存地址`0x0`
3. `null`在JavaScript中可以认为是`空值对象`，是一种特殊对象，所以`typeof null -> object`



### null vs {}

1. **内存占用**：
   - `null` 是一个特殊的值，表示一个空的或不存在的对象引用。`null`占用很少的内存，通常与布尔类型值的存储大小相当。
   - `{}` 是一个空对象，它在堆内存中占据一定的空间，即使它没有任何属性。这是因为对象需要一些元数据来管理其结构和行为。
2. **布尔值转换**：
   - `null` 是一个 "falsy" 值，这意味着在布尔上下文中（如 `if` 语句中）它会被转换为 `false`。
   - `{}` 是一个 "truthy" 值，这意味着在布尔上下文中它会被转换为 `true`。



## symbol

表示独一无二的值

symbol类型值一般作为对象key使用，从而避免属性名冲突问题

```js
// 通过Symbol函数创建symbol值 「 没有字面量创建方式 」
const s1 = Symbol() // => Symbol()
const s2 = Symbol()

// Symbol函数执行后每次创建出来的值都是独一无二的
console.log(s1 == s2) // => false
console.log(s1 === s2) // => false
```



默认情况下，打印symbol值 输出结果皆为 `Symbol()`， 不同symbol值不利于区分

因此我们可以在创建时传入一个描述`description`

`description`的类型为`string`, 其余类型会被转换为字符串后再使用 

「 TS中允许的类型是`string | number` 」

```js
const s1 = Symbol('name')
console.log(s1) // => Symbol(name)
```



Symbol值不能进行运算, 但可以转换为字符串和布尔值

```js
const symbol = Symbol()

// console.log(symbol + 2) => error

console.log(symbol.toString()) // => 'Symbol()'
console.log(!!symbol) // => true
```



当`Symbol.for`所传入的key一致时，即认为这2个symbol值是相等的

如果省略参数，key默认为`undefined`

`Symbol.for`方法会先根据key去进行查找

+ 如果对应的key已经被创建就直接返回对应的symbol值
+ 如果对应的key没有被创建，那么会新建一个新的symbol值，并将其返回

```js
const s1 = Symbol.for()
const s2 = Symbol.for()
console.log(s1 === s2) // => true
```

```js
// 对于description, 可以通过symbol的description属性去进行获取
let s = Symbol('bar')
console.log(s.description) // => bar

// 对于key, 可以通过symbol的keyFor方法进行获取
s = Symbol.for('baz')
console.log(Symbol.keyFor(s)) // => baz
```



绝大多数迭代方法都只能迭代 可迭代的非symbol类型属性

```js
const user = {
  name: 'Klaus',
  age: 23,

  [Symbol('address')]: 'shanghai',
  [Symbol('height')]: 1.88
}

// JSON.stringify 方法将对象转换为字符串的时候，会自动过滤symbol属性
// 因为JSON不支持Symbol类型
console.log(Object.keys(user)) // => [ 'name', 'age' ]

// 如果我们需要获取到Symbol属性值，需要使用Object.getOwnPropertySymbols方法
console.log(Object.getOwnPropertySymbols(user)) 
// => [ Symbol(address), Symbol(height) ]

// 使用Reflect.ownKeys 可以获取对象自身的所有的属性名，包括symbol属性名，可迭代属性名和不可迭代属性名
console.log(Reflect.ownKeys(user)) 
// => [ 'name', 'age', Symbol(address), Symbol(height) ]
```



### 内置symbol值

#### **toStringTag**

1. 是一个getter
2. 返回值需要时字符串类型值，如果返回值不是字符串类型值则静默失效，不进行任何转换

```js
const user = {
  name: 'Klaus',
  age: 23,

  get [Symbol.toStringTag]() {
    return this.name
  }
}

console.log(user.toString()) // => [object Klaus]
```

如果直接返回字符串类型值，且没有额外处理逻辑，则存在对应语法糖写法

```js
const user = {
  name: 'Klaus',
  age: 23,
  [Symbol.toStringTag]: 'Klaus'
}

console.log(user.toString()) // => [object Klaus]
```



#### **iterator**

覆盖默认的迭代方式或将非迭代对象转换为可迭代对象

```js
const user = {
  name: 'Klaus',
  age: 23,
  /* 底层调用方式类似于 user[Symbol.iterator]() */
  *[Symbol.iterator]() {
    yield* Object.entries(this)
  }
}

for (const [key, value] of user) {
  console.log(`${key} - ${value}`)
  /*
    => 
      name - Klaus
      age - 23
  */
}
```



#### Symbol.toPrimitive

##### toString

将参数转换为字符串形式，如果是对象会输出类似于`[object Type]`的形式，类似于`[object Object]`

部分内置对象重写了`toString`方法, 存在自己的转换行为

```js
const obj = {}
const arr = [1, 2, 3]
const fun = () => {}
const err = new Error('我是错误信息')
const date = new Date()

console.log(obj.toString()) // => '[object Object]'

// 数组输出的是arr.join(',') ---- 如果是空数组，返回的就是空字符串
console.log(arr.toString()) // => '1,2,3'
console.log([].toString()) // => ''
console.log([3].toString()) // => '3'

// 函数返回函数体本身
console.log(fun.toString()) // => '() => {}'
console.log(err.toString()) // => 'Error: 我是错误信息'
console.log(date.toString()) // 'Fri Nov 05 2021 13:57:12 GMT+0800 (中国标准时间)'
```



在JavaScript中，最精确的类型判断方式是`toString`

```js
console.log(toString.call(''))           // => [object String]
console.log(toString.call(22))           // => [object Number]
console.log(toString.call(undefined))    // => [object Undefined]
console.log(toString.call(null))         // => [object Null]
console.log(toString.call(new Date))     // => [object Date]

console.log(toString.call(Math))         // => [object Math]
console.log(toString.call(globalThis))   // => [object Window] / [object global]

console.log(toString.call(()=>{}))       // => [object Function]
console.log(toString.call({}))           // => [object Object]
console.log(toString.call([]))           // => [object Array]

console.log(toString.call(new Set()))    // => [object Set]
console.log(toString.call(new Map()))    // => [object Map]
```



##### valueOf

输出对象的原始值，如果对象不存在对应原始值则返回对象本身

部分内置对象重写了`valueOf`方法, 存在自己的转换行为

```js
const num = 123
const str = 'Klaus'
const numObj = new Number(321)
const strObj = new String('Steven')

console.log(num.valueOf()) // => 123
console.log(str.valueOf()) // => 'Klaus'
console.log(numObj.valueOf()) // => 321
console.log(strObj.valueOf()) // => 'Steven'

const fn = () => {}
const arr = [1, 2, 3]

console.log(fn.valueOf()) // => [Function: fn]
console.log(arr.valueOf()) // => [1, 2, 3]

// Date实例重写了valueOf
// 1. new操作符的优先级 高于 方法调用
// 2. Date实例的valueOf方法返回的是时间戳
console.log(new Date().valueOf()) // => 1724245784593
```



##### **toPrimative**

对象转基本数据类型时会被调用

1. 严格判断，不进行类型转换，不调用`toPrimative`
2. 转布尔，不调用`toPrimative`



```js
toPrimitive(target, preferType = 'default': 'string' | 'number')
```

默认值是`default`，其表现行为和`number`保持一致

默认的`toPrimative`本质是根据不同情况调用内置的`toString`和`valueOf`



`preferType`的值为`number`

1. 调用`valueOf`
2. `valueOf`转不了，调用`toString`
3. `toString`也转不了，直接报错, 但如果`toString`可以转换，则将转换后的基本类型再转`number`



`preferType`的值为`string`

1. 调用`toString`
2. `toString`转不了，调用`valueOf`
3. `valueOf`也转不了，直接报错，但如果`valueOf`可以转换，则将转换后的基本类型再转`string`



某些内置对象重写了`toPrimitive`方法，存在自己的转换规则

```js
const dateValueOf =  Date.prototype.valueOf
const dateToString =  Date.prototype.toString

// 添加Date的valueOf日志
Date.prototype.valueOf = function () {
  console.log('date valueOf')
  return dateValueOf.call(this)
}

// 添加Date的toString日志
Date.prototype.toString = function () {
  console.log('date toString')
  return dateToString.call(this)
}

const date = new Date()

// Date重写了toPrimitive方法
// 所以在执行加法操作或判等操作时，preferType的值是string, 而不是number
console.log(date + 1)
console.log(date == 2)
```



##### Symbol.toPrimitive

可以通过`Symbol.toPrimitive`重写内部`toPrimitive`方法

hint类型是default | string | number 「 默认值是default，行为和number一致 」

1. 当hint值为number， 表示 对象 -> number
2. 当hint值为string， 表示 对象 -> string
3.  当hint值为default， 表示 对象 -> string | number
   + 加号可能是数字相加 也可能是字符串拼接 --- hint的值就是default
   + 判等操作(即 == 和 !=) --- hint的值也是default

```js
const obj = {
  name: '',

  [Symbol.toPrimitive]: hint => {
    if (hint === 'number') {
      return 0
    } else if (hint === 'string') {
      return ''
    } else {
      return false
    }
  }
}
```



## Object

表示一组数据，是将多个相关联的变量组合在一起形成的一个集合

object是复杂数据类型，其保存的是数据的值在内存中的引用地址，所以也叫引用类型

> 在编程语言中，指针和引用的含义是一致的，他们都是指在内存中的某一块地址

```js
let age = Symbol('age')

const user = {
  // key如果是字符串，引号可以省略 「 如果key不是合法JS变量，引号不可省略 」
  name: 'Klaus',
  
  // key是不合法字符串时，需要加上引号
  'firend-name': 'Alex',
  
  // [expression] 叫计算属性名
  [age]: 23,
  ['last'+'name']: 'Wang',
  
  // 等价于 height: height
  height,
  
  // 等价于 run: function() { ... }
  run() {
    console.log('running')
  }
}

console.log(user.name)
console.log(user[age]) // user[expression] - 可以是任何合法的JavaScript表达式
```

对象的key需要是`string | symbol`，如果是其余类型值，会自动转string

TS中允许的类型是`string | symbol | number



## typeof 操作符

使用`typeof操作符`来确定任意变量的类型

使用 typeof 操作符会返回如下结果中的一种:

| 结果      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| number    | 值的类型为数值                                               |
| string    | 值的类型为字符串                                             |
| boolean   | 值的类型为布尔类型                                           |
| undefined | 值的类型为undefined                                          |
| object    | `值的类型为object或null`<br />因为null一般用来表示一个对象为空<br />在JS中，typeof 对象(除函数外)结果都是object，包括set，map，数组等 |
| function  | 值的类型为函数                                               |
| symbol    | 值的类型为symbol                                             |



```js
let num = 23

// typeof后边的小括号不是函数调用，而是用于表示一个整体
console.log(typeof (num + 3)) // => number
console.log(typeof num + 3) // => number3
```


