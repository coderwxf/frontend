在 SVN 中，创建分支实际上是通过对原文件的地址引用来实现。在 Git 中，分支只是一个指向提交对象的可变指针。「 Git的分支创建比SVN更轻量级 」



在Git中，创建一个新的分支实际上就是创建一个新的指针 

「 这个指针指向当前最新提交（commit） 」

![image.png](https://s2.loli.net/2024/09/20/S7EKXb6kPJC543h.png)  



在切换分支后，如果没有任何新的提交，两个分支的指针会指向同一个提交节点

![image.png](https://s2.loli.net/2024/09/20/Y198hNjEwyxCp6I.png) 



```shell
git branch # 查看所有分支

git branch <name> # 新建名为<name>的分支

git branch -m <name> # 当前分支 重命名为 <name>
```



```shell
git checkout <name>  # 切换到名为<name>的分支 
```

checkout 又可以进行版本穿梭，又可以切换分支，违背了单一职责原则

所以git使用switch替代了checkout 「 向后兼容，checkout依旧可以操作分支 」

switch操作分支 和 checkout操作分支 命令是一致的

```shell
git switch <name> # 切换到名为<name>的分支 

git switch - # 切换到上一次所在的分支 

git switch -c <name> # 创建名为<name>的分支，并跳转到名为<name>的分支
```



执行`git branch`后，`terminal`可能会输出

```shell
# * 表示当前所在分支
* master # 主分支 -> 线上版本的发布 「 一般名为master或main 」
	sit # 测试分支 -> 测试版本的发布
	fix/xxx # bug修复
	feature/xxx # 新功能开发
	refactor/xxx # 功能重构
	style/xxx # 样式修复
	hotfix/xxx # 线上问题修复
	docs/xxx # 文档更新
```



```shell
git branch -d <name> # 删除分支

git branch -D <name> # 强制删除分支
```

1. 在 Git 中，你不能删除你当前所在的分支 

   「 例如: 不能在sit上执行 `git branch -d sit` 」

   

2. 删除分支时，Git会检查删除分支的更改是否有被合并到当前分支中

   + 如果没有，会中断删除，并给予警告
   + 如果依旧需要删除，可以使用强制删除



```shell
git merge <name> # 将<name>分支合并「 应用 」回当前分支
```



在`main`分支执行`git merge sit`后，分支示意图如下

![image.png](https://s2.loli.net/2024/09/20/elMNK3jIwcSFgRa.png) 

此时当前提交节点C4，会存在两个parent，一个是C2，另一个是C3



## 快进

`fast-forward` 简称 `ff`，是一种合并方法，适用于目标分支在源分支的直接祖先的情况

假设合并回状态如下:

![image.png](https://s2.loli.net/2024/09/20/BO1XnPuFQTyeWZh.png) 

此时在main分支执行`git merge sit`

因为main指向的节点是sit指向节点的直接祖先，所以本次合并git只需要简单的移动指针即可，不需要进行任何节点处理，这类合并就被称之为`fast-forward`, 简称为`快进`或`ff`

![image.png](https://s2.loli.net/2024/09/20/zs7fZJr2i1HCtS3.png) 



```shell
$ git branch -v # 查看所有分支以及每个分支的最新提交信息

# * master beb4eaf fix: add one
#   sit    40e829d fix: add Two
```



分支可以看成是commit对象记录链 「 工作记录线，时间记录线 」

![image.png](https://s2.loli.net/2024/09/20/Ats79TXldk53VrJ.png) 

Git的每个commit对象中，都有属性`Parent`，值是上一次提交对应的commit id，从而实现链条的连接



`HEAD`是一个特殊指针，指向当前所在分支

`master`等会指向对应分支中 最新的那个提交

![image.png](https://s2.loli.net/2024/09/20/dSx87hun5oPIMpi.png) 



## 冲突

![image.png](https://s2.loli.net/2024/09/20/GsYbWpZTjc2wCyE.png)  

自分支点后，如果两个分支在同一个文件的同一行进行了不同的修改，Git 无法自动决定如何合并这些更改，这种情况就会导致合并冲突。此时，Git 会提示冲突，需要手动解决冲突后再继续合并。

```shell
# 冲突合并示例
hello World # 正常内容
<<<<<<< HEAD # 当前分支的修改
hello Vue
======= # 分割线
hello React
>>>>>>> sit # sit分之的修改
```



合并前，日志如下

```shell
# main branch log 
commit f88a6461210f8fd5d15185dc93b9f6663d5650ee (HEAD -> main)
Author: klaus <klauswang.2018@gmail.com>
Date:   Fri Sep 20 16:49:51 2024 +0800

    fix: add Hello Main

commit d2c07229a9b728e49c2a3378749ba511172670ea
Author: klaus <klauswang.2018@gmail.com>
Date:   Fri Sep 20 16:49:06 2024 +0800

    fix: add Hello World

# ----------------------------------------------------

# sit branch log 
commit c83dd95547ed7b7cca36d1be9b95eb8e5b2adc41 (HEAD -> sit)
Author: klaus <klauswang.2018@gmail.com>
Date:   Fri Sep 20 16:49:31 2024 +0800

    fix: add Hello Sit

commit d2c07229a9b728e49c2a3378749ba511172670ea
Author: klaus <klauswang.2018@gmail.com>
Date:   Fri Sep 20 16:49:06 2024 +0800

    fix: add Hello World
```

在`main`执行`git merge sit`后，日志如下

```shell
commit 5211fa96bbbcf7bb9789f0736964d8e5dab0124d (HEAD -> main)
Merge: f88a646 c83dd95
Author: klaus <klauswang.2018@gmail.com>
Date:   Fri Sep 20 16:50:42 2024 +0800

    Merge branch 'sit'

commit f88a6461210f8fd5d15185dc93b9f6663d5650ee
Author: klaus <klauswang.2018@gmail.com>
Date:   Fri Sep 20 16:49:51 2024 +0800

    fix: add Hello Main

commit c83dd95547ed7b7cca36d1be9b95eb8e5b2adc41 (sit)
Author: klaus <klauswang.2018@gmail.com>
Date:   Fri Sep 20 16:49:31 2024 +0800

    fix: add Hello Sit

commit d2c07229a9b728e49c2a3378749ba511172670ea
Author: klaus <klauswang.2018@gmail.com>
Date:   Fri Sep 20 16:49:06 2024 +0800

    fix: add Hello World
```

可以看出

1. git将两条branch线合并为了一条线

2. 分支点后的提交，按照提交的时间先后顺序进行排列

3. 新增了一个提交记录 「 如果存在冲突会在这个提交中解决冲突 」

4. 这种合并方式会生成一个新的commit Id，用于记录两个分支合并信息 

   「 这种会产生新提交节点的合并方式，就不是快进模式, 而是递归模式 」 

![image.png](https://s2.loli.net/2024/09/20/v9usUYx1C52O3D6.png) 



## 合并模式

Git默认使用的合并模式为 

+ 能使用快进模式就使用快进模式
+ 无法使用快进模式就使用递归模式



快进模式( Fast-Forward Mode )示意图:

![image.png](https://s2.loli.net/2024/09/20/V2WTgra6kBGq3dA.png) 

1. 提交日志是线性的
2. 此时删除合并分支后，合并分支对当前分支的合并将无法通过日志查看到



递归模式( Recursive Mode )示意图:

![image.png](https://s2.loli.net/2024/09/20/nfBKCywrix3c4PY.png) 

1. 提交日志是非线性的
2. 此时即使删除了合并分支「 这里是sit 」, 依旧可以在日志中查看到sit分支对当前分支进行的合并修改



## 分支的创建时机

使用 `git init` 创建一个新的 Git 仓库后，默认会有一个主分支（通常是 `master` 或 `main`，具体取决于配置），但这个分支是空的，因为没有提交

只有在进行第一次提交后，主分支才会真正存在，并指向该提交

如果在没有任何提交的情况下执行 `git switch -c <name>`，Git 会创建一个新的分支 `<name>`。

由于没有提交，Git 会认为你切换到了一个新的分支，因为原来的 `master` 或 `main` 分支没有任何提交记录，所以它实际上不存在任何状态。

在这种情况下，表现类似于重命名当前分支，但实际上是新建了一个分支并切换到它。
