## 版本控制

版本控制系统（VCS）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统

通过版本控制系统，我们可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态

我们可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等



### 本地版本控制系统

许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错

为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异

这种专门用于存储提交记录和项目版本信息的数据库被称之为版本库

![本地版本控制图解](https://git-scm.com/book/en/v2/images/local.png) 

其中最流行的一种叫做 RCS，工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容



### 集中式版本控制系统

本地版本控制系统没有办法让处于不同系统上的开发者协同工作。为此集中式版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生

这类系统，诸如 CVS、Subversion 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新

![集中化的版本控制图解](https://git-scm.com/book/en/v2/images/centralized.png) 

相较于老式的本地 VCS ，现在每个人都可以在一定程度上看到项目中的其他人正在做些什么

而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易



但是这么做最显而易见的缺点是中央服务器的单点故障

+ 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作
+ 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据



### 分布式版本控制系统

为了解决CVCS的缺陷，人们发明了分布式版本控制系统（Distributed Version Control System，简称 DVCS）

在这类系统中，例如 Git，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录

这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复

因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份

![分布式版本控制图解](https://git-scm.com/book/en/v2/images/distributed.png) 

DVCS 可以指定和若干不同的远端代码仓库 ( 例如github, gitlab等 ) 进行交互

由此DVCS可以满足开发小组成员协同工作的需求，也可以根据需要设定不同的协作流程



## 特点

### 直接记录快照，而非差异比较

CVS、Subversion这类集中式版本控制系统是**基于差异（delta-based）** 的版本控制

它们存储的信息由一组基本文件和每个文件随时间逐步累积的差异一起组成

![存储每个文件与初始版本的差异。](https://git-scm.com/book/en/v2/images/deltas.png) 



Git 不按照以上方式对待或保存数据。反之，Git 把数据看作是对小型文件系统的一系列快照，是一个 **快照流**

快照通常是指对系统、文件夹或者某个软件的当前状态进行的备份，以便在需要的时候能够恢复到该状态

在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引

为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件

![Git 存储项目随时间改变的快照。](https://git-scm.com/book/en/v2/images/snapshots.png) 



### 近乎所有操作都是本地执行

相对于有网络延时开销的集中式版本控制系统，Git的绝大多数操作都只需要访问本地文件和资源

因为在本地磁盘上就有项目的完整历史，所以大部分操作看起来可以瞬间完成

Git几乎可以在本地执行任何操作，只有当Git需要和远程仓库进行交互的时候，Git才需要进行网络连接



### 通过版本链进行版本穿梭

Git使用SHA-1散列算法为每个提交版本生成一个唯一的commit ID，这个commit ID由40位十六进制字符组成

由于SHA-1算法的特性，即使文件或目录内容仅有微小的更改，生成的commit ID也会完全不同

因此 Git 可以使用 commit ID 来对每个提交版本进行唯一标识

在每一个文件快照中都存在一个引用指向上一次提交版本的commit ID，从而生成一条完整的提交记录链

通过这条提交记录链，我们可以方便地在快照流中进行穿梭，以查看或回退到某一个历史提交版本



### 只执行添加操作

在 Git 中执行的大部分操作都是 **添加操作**，这么做的目的是为了确保我们所执行的每一个操作都有"后悔药"，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作

同别的 VCS 一样，一旦数据被提交到版本库中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话



## 文件状态

Git中的文件只可能是以下状态中的任意一种

+ **已修改（modified）**

  表示文件在工作区发生了修改，但是修改并没有被git所管理

  工作区是对项目的某个版本独立提取出来的内容， 是进行日常开发的场所

  工作区的内容中修改的内容并没有被Git所管理，只有当文件被纳入到暂存区时，文件才会被git所管理

   

+ **已暂存（staged）**

  已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中

  通过暂存区，我们可以将修改按照实际情况分批次进行提交，而不用强制一次性提交所有的修改

  当修改被纳入暂存区，就说明修改被git所追踪和管理了，但是此时还没有被纳入到本地版本库中

  

+ **已提交（committed）**

  已提交表示数据已经安全地保存在本地数据库中

  本地数据库是 Git 用来保存项目的元数据和对象数据库的地方

![工作区、暂存区以及 Git 目录。](https://git-scm.com/book/en/v2/images/areas.png)

## 安装与配置

```shell
$ brew install git
```



### 配置文件

Git可以通过 `git config` 命令来对 Git的行为 进行一系列的自定义配置

| 位置                                   | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `/etc/gitconfig`                       | 系统级别配置<br />执行`git config`时需要加上`--system`       |
| `~/.gitconfig`或`~/.config/git/config` | 用户级别配置<br />执行`git config`时需要加上`--global`       |
| `.git/config`                          | 项目级别配置<br />执行`git config`时需要加上`--local`<br />如果省略参数，这将是默认行为 |

每一个级别会覆盖上一级别的配置，即优先级为: `项目级别配置 > 用户级别配置 > 系统级别配置` 

```shell
# --list 查看所有配置
# --show-origin 查看配置是哪个级别的配置 以及对应配置文件所在的存储位置
$ git config --list --show-origin

# 通过 `git config <key>` 来检查 Git 的某一项具体配置
$ git config user.name
```



### 用户信息

Git是一种可以进行团队协作开发的版本控制系统，因此在第一次安装完Git后需要对用户名和邮件地址进行配置

之后的每次提交， Git都会将用户名和邮件地址信息写入到提交记录中一并进行提交

```shell
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```



### 查看帮助信息

如果我们使用 Git 时需要获取帮助，有三种等价的方法可以找到 Git 命令的综合手册（manpage）

```shell
# verb 表示具体指令

# 获取指令的完整参考
$ git help <verb>
$ git <verb> --help
$ man git-<verb>

# 获取指令的快速参考
$ git <verb> -h
```

