

## 版本管理

### svn

SVN 是 集中式版本管理工具 「 多个客户端 和 一个服务器 」

1. 中央仓库中保存了所有的代码版本，开发者可以访问、对比或恢复历史版本
2. 本地开发新版本后可以提交给服务器
3. 其余开发者可以从服务器拉取最新的提交版本，以保持代码同步
4. 中央服务器本地是用于执行
   + 版本管理
   + 代码共享



### git

1. 分布式版本控制系统
2. svn交换代码必须联网，连上中央仓库 「 存在瓶颈问题 」
3. git 本地存在完整的版本库 「 远程版本库仅用于代码交换 」

![image.png](https://s2.loli.net/2024/09/16/J4S5KHTpPzigG8t.png) 

| 区域                                  | 说明                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| **工作区**（Working Directory）       | 实际修改文件的地方<br />当创建或修改文件时，它们首先会位于工作区 |
| **暂存区**（Stage/Index，又叫索引区） | 当运行 `git add` 时，修改的文件会被放入暂存区<br />表示这些文件将被提交，但还没有正式记录在版本库中 |
| **版本库**（Local Repository）        | 当运行 `git commit` 时，<br />暂存区的所有文件会被提交到版本库，并保存历史记录。 |

暂存区相当于一个**中间缓冲区**，它的主要作用就是让你可以更灵活地控制哪些文件会被提交，哪些文件暂时不提交。

通过暂存区，你可以选择性地提交工作区中的某些部分，而不是一次性提交工作区中所有的改动。



| 命名     | 说明                     |
| -------- | ------------------------ |
| git push | 本地仓库 推送到 远程仓库 |
| git pull | 远程仓库 拉取到 本地仓库 |



git 是 基于分支的版本控制系统，推送和拉取的本质 是 本地的某一个分支代码 「 本地分支 」 和 远程的某一个分支代码 「 远程分支 」 保持同步 

git默认的主分支是master  「 或者 main  」

git的远程仓库一般托管在 `github` 或者 `gitlab`



## 常见操作

| 操作                   | 说明                              |
| ---------------------- | --------------------------------- |
| 发布项目 「 push -u 」 | 将本地项目 第一次 提交给 中央仓库 |
| 下载项目 「 clone 」   | 第一次从 中央仓库 下载项目到本地  |
| 提交更新 「 commit 」  | 将本地修改内容 同步到 服务器      |
| 下载更新 「 push 」    | 将服务器最新提交 同步到 本地      |

![image.png](https://s2.loli.net/2024/09/16/hcnI4qdW9RFwXe8.png) 

代码需要及时更新和提交，以减少代码冲突的发生

代码冲突通常发生在多个开发者同时修改了同一个文件的相同部分（例如同一行代码）

当版本控制工具（如Git、SVN）检测到这种情况时，它不知道应该以谁的修改为准，因此需要开发者手动解决冲突。

 一般情况下，推荐

1. 完成某一个功能或下班之前，就进行代码的提交
2. 编写一个新功能之前或每天上班第一件事，就进行代码的拉取操作

从而尽可能使本地代码 和 服务器代码保持一致



## 账户配置

git 是分布式的，需要和他人进行交互，所以在提交之前，需要对使用者的 用户名和邮箱 进行配置

```shell
# 设置 Git 用户名和邮箱地址

# 全局配置（适用于当前用户的所有 Git 仓库）「 ~/.gitconfig 」
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"

# 本地配置（仅限于当前仓库）「 .git/config 」
git config --local user.name "Your Name"
git config --local user.email "your.email@example.com"

# 系统配置（适用于整个系统上的所有用户）「 /etc/gitconfig 」
git config --system user.name "Your Name"
git config --system user.email "your.email@example.com"
```



## 鉴权配置

 可以在本地配置ssh密钥，当代码提交时，会自动携带密钥到远程仓库从而实现自动鉴权，而不需要每次都手动输入用户名和密码 

```shell
# 一般加密方式使用rsa 「 一种非对称密钥 」
# 注释一般是描述性内容 一般是邮箱
# ssh-keygen -t <加密方式> -C <注释>

# 加密后 私钥 和 公钥 一般放置在 ~/.ssh 目录下
# 以rsa 加密为例 「 ~ 表示用户主目录，例如用户名为Klaus，~ 就等价于 /Users/Klaus 」
# + 私钥 -> ~/.ssh/id_rsa 『 留在本地的公钥 』
# + 公钥 -> ~/.ssh/id_rsa.pub 「 配在远程仓库的公钥，一般为于authorized_keys文件中 」

ssh-keygen -t rsa -C "your_email@example.com"
```

 鉴权流程

1. **服务器挑战**：服务器生成一个随机数（挑战）并用客户端的公钥加密，然后将其发送给客户端
2. **客户端响应**：客户端用其私钥解密挑战，并将解密后的随机数发送回服务器
3. **服务器验证**：服务器验证客户端返回的随机数是否与原始挑战匹配。如果匹配，则证明客户端持有相应的私钥，鉴权成功。

测试连通性

```shell
ssh -T git@github.com # git@github.com 是写死的，用户测试github的密钥配置是否成功
```

连接成功后，会在`~/.ssh`目录中生成`known_hosts`文件

`known_hosts` 文件中记录着服务器的主机名（或IP地址）和对应的公钥。

当你通过 SSH 连接到服务器时，客户端会将服务器提供的公钥与 `known_hosts` 文件中的记录进行比较，以确保公钥与主机名（或IP地址）匹配。

这有助于防止中间人攻击，即避免攻击者伪造服务器的身份。因此，`known_hosts` 文件的作用是验证服务器的身份，确保你连接的是预期的服务器，而不是被攻击者冒充的

也就是说每次连接是

1. 服务器返回服务器自己的公钥，客户端在`known_hosts`中查找，以确认服务器身份

2. 身份通过，则再执行服务器挑战，以进行鉴权操作 

   「 服务器挑战加密使用的是用户在服务器配置的公钥 」

3. 鉴权通过，进行数据交互



![image.png](https://s2.loli.net/2024/09/16/l92OIGvZaBg6mUx.png) 

对于mac而言，只要有应用需要访问密钥等信息，就需要输入登录密码进行鉴权

此时可以每次输入登录密码进行验证，或选择始终允许来记住选项



## 初始化

```shell
git init
```

初始化后，本地就存在`.git`文件夹 「 本地 git 仓库 」



## 项目关联

`ssh` 只是本地计算机和远程仓库进行连接，但并没有将本地的具体项目和远程的具体项目之间实现关联



在远程仓库「 以github为例 」 新建项目后，会生成一个远程地址

例如`git@github.com:coder-klaus/git-demo.git` 「 这是远程仓库中某个项目的唯一地址 」

我们需要将本地项目和远程项目进行关联操作

```shell
# git remote add <远程仓库别名> <远程仓库地址> -> 新增一条新的远程记录
# 一般默认的远程仓库名都是 origin
git remote add origin git@github.com:coder-klaus/git-demo.git
```



### 首次提交

```shell
git add . # 工作区 -> 暂存区 「 . 表示工作区中所有的修改文件 」
git commit -m '提交描述' # 工作区 -> 本地仓库 「 实际是本地仓库的某个具体分支 」
git push -u <远程仓库别名> <分支名> # 本地仓库 -> 远程仓库 
```

`-u` 是 `--set-upstream`的缩写，简称设置上游分支，本质是将本地分支 和 远程分支 进行关联

以后推送拉取的时候，默认就是从上游分支进行推送和拉取



### 首次拉取

`git clone`成功后，本地默认存在主分支，且其上游分支是远程对应仓库的主分支

```shell
git clone <远程仓库地址>
```



### 后续提交

```shell
git add . 
git commit -m '提交描述' 
git push # 自动提交到 本地分支对应的上游分支
```



### 后续拉取

```shell
git pull # 将上游分支 拉取到 本地分支
```



