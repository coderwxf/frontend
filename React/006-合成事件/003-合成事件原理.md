React 中事件处理机制依赖的是 事件委托

1. React17之前 
   + 委托给document
   
   + 只委托了冒泡阶段 
   
     --- 即所有委托事件
   
     ​     是在`document.addEventListener(xxx, () => {})`中被处理的
   
   + ![image-20240331141136434](https://s2.loli.net/2024/03/31/tRoMO1UimgSKqNl.png) 
   
2. React17开始
   + 委托给#root 「 应用容器 」 -- 所以17开始不推荐使用body作为根容器
   
   + 冒泡和捕获阶段都进行了委托 
   
     --- 即所有委托事件
   
     ​      是在`#root.addEventListener(xxx, () => {}, true)` 
   
     ​	 以及 `#root.addEventListener(xxx, () => {})`中分别处理的
   
   + ![image-20240331124229622](https://s2.loli.net/2024/03/31/HOa21XVLdnhUKwN.png)

对于没有事件传播的事件，才是单独绑定到DOM元素自身上



## 执行流程

1. 在解析VDOM的时候，如果遇到onXxx 或 onXxxCapture 会将对应事件作为VDOM的属性进行绑定

   其中 onXxx 或 onXxxCapture 被称之为 合成事件属性

   注意:

   + 仅仅只是属性赋值，不是事件绑定
   + 既不是DOM0级事件绑定 「 onxxx - 全小写 」 也不是DOM2级事件绑定 「 addEventListener 」

   ```js
   // 伪代码
   inner.onClick = () => console.log('click buddle')
   inner.onClickCapture = () => console.log('click capture')
   ```

   

2. 渲染为真实DOM的时候，将对应的事件处理函数挂载到#root上

   因为 #root 元素 是容器元素，是所有JSX元素的父元素

   ```js
   const root = document.querySelector('.root')
   const outer = document.querySelector('.outer')
   const inner = document.querySelector('.inner')
   
   outer.onClick = () => console.log('outer buddle')
   inner.onClick = () => console.log('inner buddle')
   
   outer.onClickCapture = () => console.log('outer capture')
   inner.onClickCapture = () => console.log('inner capture')
   
   root.addEventListener('click', e => {
     console.log(e.composedPath())
     // e.composedPath() -> 用于获取事件的传播路径 -> 从最内层元素到最外层元素
     // 即传播路径为 inner -> outer -> root -> body -> html -> document -> window
     const path = [...e.composedPath()]
   
     // 执行捕获阶段的事件处理函数
     path.reverse().forEach(el => {
       // 默认函数调用 -> 模块和类在解析时会自动开启严格模式 -> 函数内部this是undefined
       el.onClickCapture?.()
     })
   }, true)
   
   root.addEventListener('click', e => {
     const path = [...e.composedPath()]
   
     path.forEach(el => {
       el.onClick?.()
     })
   })
   ```
   
    

所以react中合成事件本身就是基于事件委托处理的，所以我们实际绑定事件时，无需在主动考虑如何使用事件委托来绑定事件