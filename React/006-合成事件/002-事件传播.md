## 事件传播机制

事件执行会分为三个阶段 『 假设触发元素是A 』

1. 捕获阶段 

   + 事件从根节点（通常是window）开始，沿着DOM树向下传播，直到它到达触发事件的那个元素（目标元素A）的父节点

   + 从 window -> document -> html -> body ... -> A的父元素 『 从外到内 』
   + 其目的是建立事件的传播路径

2. 目标阶段

   + 触发 A的捕获事件
   + 触发A的冒泡事件
   + A叫做事件源 「 target 」

3. 冒泡阶段

   + 事件从目标元素开始，沿着DOM树向上冒泡，直到根节点

   + 反向依次执行事件传播链  「 从内到外 」

```js
// DOM2级事件 第三个参数
// true - 捕获阶段执行
// false - 表示冒泡阶段执行 -- 默认值
body.addEventListener('click', (e) => {
  console.log('body')
}, true)

body.addEventListener('click', (e) => {
  console.log('body')
}, false)
```



当事件在元素上触发时

+ 如果存在绑定的事件处理函数（Event Handler），则该函数将被执行

+ 如果一个元素上没有为特定事件绑定处理函数，则不会有任何响应执行



不是所有的事件都存在事件传播，例如`mouseenter/mouseleave`就不存在事件传播

我们可以调用事件对象上的`stopPropagation`方法和`stopImmediatePropagation`方法来阻止事件传播

```js
outer.addEventListener('mouseenter', (e) => {
  // 无论e.stopPropagation的执行位置在哪，都是先执行完当前函数，在阻止传播
  e.stopPropagation()
  console.log('outer mouseenter 捕获')
})
```



## eventPhase

```js
root.addEventListener('click', e => {
  console.log(Event.prototype)
  /*
    对于事件对象来说，有三个阶段
    为了标识事件流的当前阶段，Event 对象提供了一个 eventPhase 属性，它的值是一个整数，表示事件流的当前阶段。
    + AT_TARGET: 2, 事件目标阶段
    + BUBBLING_PHASE: 3, 冒泡阶段
    + CAPTURING_PHASE: 1  捕获阶段
  */
  console.log(e.eventPhase) // 获取事件流的当前阶段
})
```



## 阻止事件传播

`stopPropagation vs stopImmediatePropagation`

对于DOM2级事件，同名事件函数会被组合成一个数组后被依次执行

+ `stopPropagation`而言，是等到数组全部执行完毕后在阻止事件传播
+ `stopImmediatePropagation`是 当前事件执行完毕后，立即阻止事件传播

```js
outer.addEventListener('click', (e) => {
  e.stopPropagation()

  console.log('outer click 冒泡1')
})

outer.addEventListener('click', (e) => {
  console.log('outer click 冒泡2')
})

/*
  =>
    outer click 冒泡1
    outer click 冒泡2
*/
```

```js
outer.addEventListener('click', (e) => {
  e.stopImmediatePropagation()

  console.log('outer click 冒泡1')
})

outer.addEventListener('click', (e) => {
  console.log('outer click 冒泡2')
})

/*
  =>
    outer click 冒泡1
*/
```



## 事件委托

因为事件会冒泡，所以你可以在父元素上统一处理子元素事件，而不是在每个子元素上分别绑定事件处理函数

`不使用事件委托`

```js
const outer = document.querySelector('.outer')
const inner = document.querySelector('.inner')

outer.addEventListener('click', e => {
  console.log('outer clicked')
})

inner.addEventListener('click', e => {
  e.stopPropagation()
  console.log('inner clicked')
})
```

在内存中，存在元素`inner` 和`outer` 以及他们对应的事件处理函数，一共有四个部分需要存储



`使用事件委托`

```js
const outer = document.querySelector('.outer')

outer.addEventListener('click', e => {
  // e.target 是触发事件的元素 --- 事件源
  // e.currentTarget 是绑定事件的元素 --- 执行当前事件回调的元素
  if (e.target.id === 'inner') {
    console.log('inner clicked')
  } else {
    console.log('outer clicked')
  }
})
```

在内存中，只需要存储`outer`和对应事件处理函数，相比不使用事件传播，可以少存储一个变量和对应事件处理函数



## react中的事件传播

1. 合成事件对象上 阻止事件传播
2. 即能阻止合成事件传播，也可以阻止原生事件传播
3. 合成事件对象上 不存在stopImmediatePropagation

```js
e.stopPropagation() 
```



原生事件上的阻止事件传播

1. 只能阻止原生事件，阻止不了合成事件

```js
e.nativeEvent.stopPropagation() 

e.nativeEvent.stopImmediatePropagation() 
```



## 事件对象池

在React18之前，为了避免每次触发事件时候，需要重新生成新的合成事件对象

会将之前生成的合成事件对象存储到事件对象池中，下次使用时，直接从事件对象池中取出即可

```jsx
<div onClick={e => {
    // 从事件对象池中获取合成事件对象，并进行初始化操作后赋值给 e
    console.log(e.type) // => click

    setTimeout(() => {
      // 此时合成事件对象已经被清空，所以 e.type 为 null
      console.log(e.type) // => null
    }, 5000)

    // 函数执行完毕后，会将合成事件对象清空后，再次存储到事件对象池
  }}
/>
```

```jsx
<div onClick={e => {
    console.log(e.type) // => click

    setTimeout(() => {
      // 此时合成事件对象中值被保留下来了
      console.log(e.type) // => click
    }, 5000)

    // 为了阻止合成事件对象被执行清空操作，可以使用 e.persist() 方法
    e.persist()
  }}
/>
```



在React18中，已经移除了事件对象池，每次都会生成新的独立的合成事件对象

```jsx
<div className='inner' onClick={e => {
      console.log(e.type) // => click

      setTimeout(() => {
        console.log(e.type) // => click
      }, 5000)
    }}
  />
```

