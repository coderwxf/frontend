## state

状态:

1. 状态是一种特殊的数据
2. 状态参与界面渲染，当状态发生改变时，界面需要重新进行渲染

```js
import { PureComponent } from 'react'

export default class App extends PureComponent {
  // 1. 类组件的状态都必须定义在构造函数的state属性上
  // 2. 如果不初始化state，this.state的默认值将会是null
  // 3. 通过类的成员属性初始化state, 可以省略构造函数
  state = {
    name: 'John',
    age: 23
  }

  render() {
    const { name, age } = this.state
    return (
      <>
        {name} - {age}
      </>
    )
  }
}
```



## setState

在vue中，对视图状态进行了数据劫持

+ 使用状态，会触发get操作，对应视图部分会作为视图的依赖被收集
+ 修改状态，会触发set操作，该状态对应的所有依赖会被同时进行更新

而react中，并没有对状态进行任何的数据劫持, 因此直接修改state中的状态并不能触发界面更新

在react中，如果需要在修改状态的同时，进行界面刷新，必须通过setState方法

```js
import { PureComponent } from 'react'

export default class App extends PureComponent {
  state = {
    name: 'John',
    age: 23
  }

  render() {
    const { name, age } = this.state
    return (
      <>
        <div>{name} - {age}</div>
        <button onClick={() => this.addAge()}>addAge</button>
      </>
    )
  }

  addAge() {
    // 这种方式修改状态 只能单纯的修改状态值 无法触发视图更新
    // this.state.age+= 1

    // setState(obj)
    // 1. 修改状态 --- 新的state = Object.assign({}, this.state, obj)
    // 2. 触发视图更新
    this.setState({ age: this.state.age + 1 })

    // setState是异步更新 不能立即获取到最新的state
    console.log(this.state.age) // => 23
  }
}
```



## forceUpdate

界面强制刷新

```js
import { PureComponent } from 'react'

export default class App extends PureComponent {
  state = {
    name: 'John',
    age: 23
  }

  render() {
    const { name, age } = this.state
    return (
      <>
        <div>{name} - {age}</div>
        <button onClick={() => this.addAge()}>addAge</button>
      </>
    )
  }

  addAge() {
    this.state.age+= 1

    this.forceUpdate()

    // 界面强制刷新是同步的
    console.log(this.state.age) // => 24
  }
}
```

