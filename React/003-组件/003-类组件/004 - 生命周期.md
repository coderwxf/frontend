## 首次渲染

组件首次挂载会依次调用如下三个生命周期钩子

1. UNSAFE_componentWillMount
2. render
3. componentDidMount

```js
import { PureComponent } from 'react'

export default class App extends PureComponent {
  state = {
    name: 'John'
  }

  render() {
    console.log('render')

    const { name } = this.state
    return (
      <>
        <div>{name}</div>
      </>
    )
  }

  // componentWillMount生命周期钩子会在组件被挂载完成之前被调用 --- 即将被废弃 -- 调用会报黄色警告
  // componentWillMount() {
  //   console.log('componentWillMount')
  // }

  // 如果一定要使用componentWillMount，可以使用UNSAFE_componentWillMount替代
  // 在非react严格模式下, UNSAFE_componentWillMount 调用不会报黄色警告
  // 在react严格模式下, UNSAFE_componentWillMount 调用会报红色警告
  UNSAFE_componentWillMount() {
    console.log('UNSAFE_componentWillMount')
  }

  // 组件挂载完成后调用 -- 此时DOM已经渲染完成，可以在这里进行DOM操作
  componentDidMount() {
    console.log('componentDidMount')
  }
}
```



## 组件更新

让组件更新的方式一般有两种

1. 修改组件内部状态 除非 组件更新 --- 自更新
2. 父组件更新，带动子组件更新 --- 例如 传入了新的props

![image-20240323170027761](https://s2.loli.net/2024/03/23/1eTCDxt8SbRqKQg.png) 



### 自更新

组件自更新时，流程如下 

1. 执行shouldComponentUpdate 「 简称SCU 」
   + 如果SCU 返回false --- 退出更新
   + 如果SCU 返回true --- 更新流程继续
2. 除非`UNSAFE_componentWillUpdate` --- 组件即将更新
3. 更新状态和props
4. 触发render函数，更新视图
5. 触发 `componentDidUpdate` -- 组件更新完毕

```js
import { PureComponent } from 'react'

export default class App extends PureComponent {
  state = {
    count: 0
  }

  render() {
    console.log('render')

    const { count } = this.state

    return (
      <>
        <div>{ count }</div>
        <button
        onClick={() => this.setState({ count: this.state.count + 1 })}>+1</button>
      </>
    )
  }

  // SCU用来判断组件是否实际需要更新
  // 返回false则不会更新，返回true则会更新
  // 从而避免生成新的虚拟DOM，提高性能
  shouldComponentUpdate(nextProps, nextState) {
    // SCU内部的state和props是旧的
    // 新的state和props由参数传入
    console.log('shouldComponentUpdate')
    return nextState.count !== this.state.count
  }

  // 组件即将更新 --- 即将被废弃
  // componentWillUpdate -- 组件依旧还没有被实际更新
  // componentWillUpdate内通过this获取的state和props是旧的
  // 新的props和state通过参数传入
  UNSAFE_componentWillUpdate(nextProps, nextState) {
    console.log('UNSAFE_componentWillUpdate')
  }

  // 组件更新完毕时，执行的生命周期函数
  // componentDidUpdate内通过this获取的state和props是新的
  // 旧的props和state会通过参数传入
  componentDidUpdate(prevProps, prevState) {
    console.log('componentDidUpdate')
  }
}
```

特别需要注意的是

1. SCU的功能是通过判断props和state是否发生更新来判断组件是否需要实际更新

   如果视图不需要进行任何更新，新的VDOM压根不会生成，DOM-DIFF也不会发生, 从而提升了性能

2. 但有个特例，`forceUpdate`会跳过SCU的检测，而是直接从`componetWillUpdate`开始执行

   也就是说即使props和state没有发生任何更新，依旧会生成新的VDOM，并进行DOM-DIFF

   

### 父组件触发更新

react组件的更新流程是 深度优先遍历

也就是在render的过程中，遇到了子组件，会优先进行子组件的渲染流程

子组件渲染完毕后，才会继续父组件的渲染流程



更新流程

1. 触发`UNSAFE_componentWillReceiveProps`
2. 执行组件自更新渲染流程

```js
// 此时组件状态并没有更新，所以函数内部this.props是旧的props，新的props通过参数传入
UNSAFE_componentWillReceiveProps(nextProps) {
  console.log('UNSAFE_componentWillReceiveProps')
}
```



## 组件卸载

1. 触发`componentWillUnmount`
2. 组件销毁

```js
// 会在父组件更新时，被触发 -- 无论是否传入了新的props
// 目的: 在实际使用props之前，对传入的props进行二次加工处理
// 此时组件状态并没有更新，所以函数内部this.props是旧的props，新的props通过参数传入
UNSAFE_componentWillReceiveProps(nextProps) {
  console.log('UNSAFE_componentWillReceiveProps')
}
```



## 函数组件 vs 类组件

函数组件是静态组件，第一次渲染完成后，除非父组件更新迫使函数组件重新渲染

函数组件内部是没有自己状态的，所以无法通过修改自身状态进行自更新渲染

所以函数组件渲染性能比类组件高



类组件，拥有自己的props，state，生命周期函数，ref等

即可以通过父组件来重新渲染子组件，也可以通过修改类组件自身的状态来实现自更新渲染

所以类组件性能比函数组件低，但是功能更为强大



## hook组件

hook是一系列的函数

hook函数 + 函数组件 可以让函数组件也拥有类组件的状态，生命周期等功能

所以hook组件可以认为 即包含了函数组件的优点，也包含了类组件的优点



## 完整的生命周期流程图

![image.png](https://s2.loli.net/2024/03/23/5pMAVaSe6s8RwqZ.png) 
