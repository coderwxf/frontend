## 基本使用

`useState` 在函数组件中定义`state`

```jsx
// useState 参数是默认值，返回值是一个数组 -> [值，修改值的方法]
let [count, setCount] = useState(0)

// 执行setCount方法 -- 参数 是状态的新值
// 执行的操作是: 1. 修改状态 2. 状态更新
setCount(1)
```



`示例`

```jsx
import { useState } from 'react'

export default function App(props) {
  const [count, setCount] = useState(0)

  function add() {
    setCount(count + 1)
  }

  return (
    <>
      <div>{ count }</div>
      {/* hook组件没有this，所以引函数的时候，不在需要this了 */}
      <button onClick={add}>add</button>
    </>
  )
}
```



## 内部优化

```jsx
import { useState } from 'react'

export default function App(props) {
  const [count, setCount] = useState(10)

  console.log('render')

  function add() {
    // 执行状态更新函数时，会通过Object.is对新老状态进行判断
    // 如果新老状态是一致的，状态更新函数会静默失效
    setCount(10)
  }

  return (
    <>
      <div>{ count }</div>
      <button onClick={add}>add</button>
    </>
  )
}
```



## 传入函数

```jsx
import { useState } from 'react'

export default function App(props) {
  // 组件每次更新都会生成一个新的函数执行上下文
  // 每生成一个函数执行上下文都需要执行一次initalCount的计算
  // 而useState的初始值只有在首次渲染时才有效
  const initalCount = props.x + props.y
  const [count, setCount] = useState(initalCount)

  console.log('render')

  function add() {
    setCount(preCount => preCount + 1)
  }

  return (
    <>
      <div>{ count }</div>
      <button onClick={add}>add</button>
    </>
  )
}
```



```jsx
import { useState } from 'react'

export default function App(props) {
  // useState的参数可以是一个函数, useState会使用该函数的返回值作为状态初始值
  // 此时 props.x + props.y的计算只会在第一次渲染的时候被执行，之后渲染时就不会再被执行了 --- 惰性化初始状态
  // 所以useState的初始值如果是需要经过计算得到的，推荐将其写成一个函数后再传给useState
  const [count, setCount] = useState(() => props.x + props.y)

  console.log('render')

  function add() {
    setCount(preCount => preCount + 1)
  }

  return (
    <>
      <div>{ count }</div>
      <button onClick={add}>add</button>
    </>
  )
}
```

