## 异步更新

`useState`的更新逻辑和`setState`完全一致

+ React18 中 都是异步
+ React16中，react管控事件 「 合成事件，生命周期 」 是异步的，非react管控事件 「 dom事件，定时器 」是同步的

```jsx
import { useState } from 'react'

export default function App(props) {
  const [count, setCount] = useState(0)

  // render 只会输出一次
  console.log('render')

  function add() {
    // 存入更新队列的是三个 setCount(1)
    // 所以 只会渲染一次，且count的值是1
    setCount(count + 1)
    setCount(count + 1)
    setCount(count + 1)
  }

  return (
    <>
      <div>{ count }</div>
      <button onClick={add}>add</button>
    </>
  )
}
```

```jsx
import { useState } from 'react'
import { flushSync } from 'react-dom'

export default function App(props) {
  const [count, setCount] = useState(0)

  // render 会打印两次
  console.log('render')

  function add() {
    // flushSync将回调函数插入更新队列，并立即更新状态和视图
    flushSync(() => {
      // 回调函数中更新是异步的
      setCount(count + 1)
      setCount(count + 1)
    })

		// 虽然重新渲染了，生成了一个新的函数执行上下文
    // 但此语句位于第一个函数执行上下文 「 更新后，按钮还没有被点击 」
    // 所以此时count根据闭包原则会去第一个函数执行上下文获取，即0

    // 因为组件会被渲染两次，count的值是1
    setCount(count + 1)
  }

  return (
    <>
      <div>{ count }</div>
      <button onClick={add}>add</button>
    </>
  )
}
```



```js
import { useState } from 'react'

export default function App(props) {
  const [count, setCount] = useState(0)

  console.log('render')

  function add() {
    // react16和react17，定时器中状态修改是同步的，所以组件会被渲染三次
    // 在react18中，定时器中状态修改是异步的，所以组件只会被渲染一次
    setTimeout(() => {
      setCount(count + 1)
      setCount(count + 1)
      setCount(count + 1)
     }, 2000)
  }

  return (
    <>
      <div>{ count }</div>
      <button onClick={add}>add</button>
    </>
  )
}
```



```jsx
import { useState } from 'react'

export default function App(props) {
  const [count, setCount] = useState(0)

  console.log('render')

  function add() {
    for (let i = 0; i < 20; i++) {
      // 状态更新函数 也可以传入一个回调函数
      // 	1. 第一次preCount为初始值 这里就是0
      // 	2. 第二次preCount为上一次setCount的返回值
      setCount(preCount => preCount + 1)
    }
  }

  return (
    <>
      <div>{ count }</div>
      {/* 点击按钮后，界面更新一次，状态count的值变为20 */}
      <button onClick={add}>add</button>
    </>
  )
}
```

