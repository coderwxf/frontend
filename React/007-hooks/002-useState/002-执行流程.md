## 执行流程

![image-20240401213319222](https://s2.loli.net/2024/04/01/EWsf8qJxdQZywig.png) 

1. 函数组件每次更新，都是生成一个独立的函数执行上下文
2. 每次执行useState都是产生一个新的闭包，并从对应执行上下文中获取对应状态和方法
3. useState每次返回的更新函数都是独立的新函数

所以，存在下述情况

```jsx
import { useState } from 'react'

export default function App(props) {
  const [count, setCount] = useState(0)

  function add() {
    setCount(count + 1)

    // 等待两秒 目的是确保组件状态和视图都已经得到更新
    setTimeout(() => {
      // 这里的count是通过闭包得到的，不是再次调用useState得到的
      // 所以获取的是0，不是1
      console.log(count) // => 0
    }, 2000)
  }

  return (
    <>
      <div>{ count }</div>
      <button onClick={add}>add</button>
    </>
  )
}
```

