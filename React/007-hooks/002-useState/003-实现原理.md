## 实现原理

```jsx
// 伪代码

// 每一个 React 组件在渲染时都对应着一个 Fiber 节点 「 fiber是一种react内部定义的数据结构 」
// 当使用 useState 钩子时，状态存储在与组件对应的 Fiber 节点中
// 每当组件重新渲染时，React 能够通过这个 Fiber 节点访问到组件的状态
const _state = new Map()

// 这个key是从0开始的，每次调用useState都会自增
// 这也就是为什么hook只能在函数顶层调用，不能在循环、条件语句中调用 --- 避免因为执行顺序不同导致key不同
const key = Symbol('count')

function useState(initalValue) {
  // 如果第一次渲染，直接初始化
  if (!_state.get(key)) _state.set(key, typeof initalValue === 'function' ? initalValue() : initalValue)

  function setKey(value) {
    if (Object.is(_state.get(key), value)) return

    if (typeof value === 'function') {
      // 更新状态函数参数是函数，则执行函数，并使用其返回值替换原本状态
      _state.set(key, value(_state.get(key)))
    } else {
      _state.set(key, value)
    }

    // 通知视图更新 类似于 再次调用 App(props)
  }

  // 第二次渲染，直接返回上一次的值
  return [_state.get(key), setKey]
}

let count

// 第一次获取状态
const [count1, setCount1] = useState(0)
count = count1
console.log(count) // => 0

// 更新状态并重新渲染
setCount1(100)

// 第二次获取状态
const [count2, setCount2] = useState(0)
count = count2
console.log(count) // => 100

// 每调用useState, 返回的更新函数都是独立的
console.log(setCount1 === setCount2) // => false
```

