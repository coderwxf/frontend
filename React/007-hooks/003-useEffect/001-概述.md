`useEffect`的作用是在函数组件中模拟生命周期函数



## 没有依赖

调用方式 `useEffect(副作用函数)`

1. 副作用函数会在组件首次渲染完成后被回调
2. 副作用函数会在组件更新渲染完成后被回调

```jsx
import { useEffect, useState } from "react"

export default function App(props) {
  const [ count, setCount ] = useState(0)

  function add() {
    setCount(count + 1)
  }

  // 组件更新完成后被回调，所以获取的count都是最新的值
  useEffect(() => {
    console.log(count) 
  })

  // hook函数本质就是React API -- 可以多次调用
  useEffect(() => {
    // 在componentDidMount时被回调，所以可以获取DOM元素
    console.log(document.getElementById('count'))
  })

  return (
    <>
      <div id="count">{ count }</div>
      <button onClick={add}>add</button>
    </>
  )
}
```



## 空依赖

`useEffect(副作用函数, [])`

1. 副作用函数会在组件初始渲染完成后被执行
2. 其余任何时候，副作用函数都不会再被回调

```jsx
import { useEffect, useState } from "react"

export default function App(props) {
  const [ x, setX ] = useState(0)
  const [ y, setY ] = useState(0)

  function changeX() {
    setX(x + 1)
  }

  function changeY() {
    setY(y + 1)
  }

  useEffect(() => {
    console.log(x)
  }, [])

  return (
    <>
      <div>{ x } - { y }</div>
      <button onClick={changeX}>changeX</button>
      <button onClick={changeY}>changeY</button>
    </>
  )
}
```



## 依赖数组

`useEffect(副作用函数, 依赖数组)`

1. 副作用函数会在组件初始渲染完成后被回调
2. 副作用函数会在依赖数组中任意一项发生更新，从而导致组件重新渲染完成后 再被触发

```jsx
import { useEffect, useState } from "react"

export default function App(props) {
  const [ x, setX ] = useState(0)
  const [ y, setY ] = useState(0)

  function changeX() {
    setX(x + 1)
  }

  function changeY() {
    setY(y + 1)
  }

  // 回调触发时机
  // 1. 首次渲染完成
  // 2. 状态x引起的组件重新渲染完成
  // tips: 引修改状态y引起的组件重新渲染 -- 不会触发回调执行
  useEffect(() => {
    console.log(x)
  }, [x])

  return (
    <>
      <div>{ x } - { y }</div>
      <button onClick={changeX}>changeX</button>
      <button onClick={changeY}>changeY</button>
    </>
  )
}
```



## 清理函数

副作用函数可以返回一个函数作为返回值，这个函数就是清理函数

该清理函数会在以下情况被回调

1. 组件卸载前
2. 副作用函数被回调之前，会执行上一个副作用函数所返回的清理函数

清理函数的作用是清除上一次渲染的相关副作用，例如: 定时器，事件监听等

```jsx
import { useEffect, useState } from "react"

export default function App(props) {
  const [ x, setX ] = useState(0)
  const [ y, setY ] = useState(0)

  function changeX() {
    setX(x + 1)
  }

  function changeY() {
    setY(y + 1)
  }

  // 没有依赖数组，任何状态更新都会触发callback
  // 而callback执行前会调用上一个callback的返回函数
  useEffect(() => {
    return () => {
      console.log('任意状态发生变化都会触发')
    }
  })

  useEffect(() => {
    return () => {
      // 清理函数所对应的执行上下文是上一次函数渲染所产生的函数上下文
      // 所以在清理函数中获取的是旧状态
      console.log(x) // => 0
      console.log('只有x发生变化才会触发')
    }
  }, [x])

  return (
    <>
      <div>{ x } - { y }</div>
      <button onClick={changeX}>changeX</button>
      <button onClick={changeY}>changeY</button>
    </>
  )
}
```

