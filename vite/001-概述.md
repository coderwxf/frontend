早期构建工具使用JavaScript编写，将模块代码捆绑起来，变成浏览器可以直接运行的单个文件或多个文件，这个过程被称之为打包

但是随着项目越来越大，涉及的JavaScript代码也越来越多，这些打包工具就出现了如下问题

1. 启动服务器时间变长
2. HMR时间变长

vite就是为了解决这个问题而产生的

1. 开发阶段直接使用浏览器原生的ES模块
2. 一些转换编译工具开始使用编译型语言重写



## 解决冷启动时间问题

早期构建工具，在冷启动的时候会编译转换整个项目才能工作

vite将项目分为了两类

`依赖`

1. 依赖是在开发过程中，绝大多数情况不会发生修改的部分
2. 使用go编写的esbuild进行预构建，并缓存起来 --- 存储在`.vite`文件夹下

`源码`

1. 源码由可以直接使用的文件(JavaScript,css等)和需要转换的文件(vue,ts等)组成
2. 源码需要实时编译，但并不需要全部加载
3. vite根据用户请求，通过浏览器原生ES模块识别需要加载那些模块，并只编译需要加载和使用的模块

![image-20240408103901885](https://s2.loli.net/2024/04/08/y8fmDZCsIWwunxq.png) 

依赖预购建发生在如下情况下:

1. 第一次运行项目「 `node_modules`下没有`.vite`目录 」时，会解析所有的import进行依赖预购建
2. 在重启开发服务器时自动检测到依赖的更新，并执行必要的预构建
3. 如果解析到了一个没有预购建的模块，会自动进行预购建
4. 通过命名行参数，需要强制重新进行预构建的时候



## 解决HMR缓慢

传统构建工具，每次对代码做出改动的时候，都得重新打包整个应用，让它更新

就好比是，每次你在拼图中替换一块拼图片，都需要拆掉重新拼一遍整个画面

很显然这样性能和效率很低



为此构建工具引入了热模块替换（HMR）技术

这就像是在你正在玩的拼图上直接换掉一块拼图片，而不用重新拼整个图，其他部分还能保持不变

使用HMR技术能极大地提升你编码的体验，因为你能更快看到你改动的效果



在 Vite 中，HMR 是在原生 ESM 上执行的，vite可以更好的利用浏览器原生特性更好的识别需要更新的最小模块边界

这使得无论应用大小如何，HMR 始终能保持快速更新



其次，Vite 同时利用 HTTP 头来加速整个页面的重新加载

1. 源码模块的请求会根据 `304 Not Modified` 进行协商缓存
2. 依赖模块请求则会通过 `Cache-Control: max-age=31536000,immutable` 进行强缓存，因此一旦被缓存它们将不需要再次请求



尽管原生 ESM 现在得到了广泛支持，但是

1. 老版本浏览器不支持ESM
2. 需要发生更多的网络请求
3. 无法进行 tree-shaking、懒加载和 chunk 分割等一系列性能优化操作

所以

+ 在开发阶段，使用ESbuild构建依赖，使用原生ESM支持模块化
+ 在生产阶段，使用预先内置的rollup命令「 提供了一些默认的构建优化选项 」进行构建和优化



vite在生产阶段不使用esbuild使用因为需要借助rollup的生态

在vite v4中，使用rust编写的SWC 替代了TypeScript 和 Babel 之类的编译器

并在未来版本将使用 名为 Rolldown 的 Rust 版本的 Rollup 来替换 rollup 和 esbuild



vite默认认为浏览器支持ESM，如果生产环境不支持ESM，需要使用@vitejs/plugin-legacy插件

```shell
# 临时下载并运行 create-vite 初始化vite脚手架
npm create vite@latest

# -- 是参数终止符
# 表示 --template vue 是传递给create-vite的，不是npm的
npm create vite@latest my-vue-app -- --template vue
```



`npm scripts`

```json
{
  "scripts": {
    "dev": "vite", // 启动开发服务器
    "build": "vite build", // 为生产环境构建产物
    "preview": "vite preview" // 本地预览生产构建产物 -- 需要在本地有预先构建的内容才能预览
  }
}
```



## index.html

1. 在 Vite 项目中，使用命令执行所在的工作目录作为项目的根目录 `<root>`
2. 如果 `<root>` 下存在 `vite.config.js`，Vite 会自动识别并使用它作为配置文件。
3. Vite 会自动加载位于项目根目录下的 `index.html` 作为项目入口，并基于它来构建项目的依赖关系图。
4. 在 Vite 中，所有的绝对路径引用都会以 `<root>` 作为基准路径进行解析。
5. 可以通过执行 `vite serve some/sub/dir` 命令在启动开发服务器时指定一个不同的目录作为临时项目根目录