## http

HTTP（Hypertext Transfer Protocol）是一种通信协议，用于在万维网（WWW）中传输超文本数据

http是一个无状态协议，这意味着在处理客户端请求时，服务器不会存储先前的信息或会话状态

因此，每个请求都是独立的，服务器没有办法区分来自不同客户端的请求，也不会保留任何信息以便处理后续的请求

这种特性虽然可能会影响服务器的处理效率，但同时也使得 HTTP 协议更加简单，易于实现



### 会话

在计算机网络中，会话指的是两台计算机之间进行通信的一次交互过程

在这个过程中，双方可以交换数据，并且每一次请求和响应都会在某个特定的时间内完成



## 用户凭证

因为网络数据传输使用的是http协议，而http协议是一种无状态协议，那么我们就需要通过某种方式来证明自己的身份，如是否已经登录，有没有操作权限等

而这个用来证明自己身份的标识就被称之为`用户凭证`，常见的用户凭证有`cookies, sessions, token`等



### cookie

Cookie(复数形态Cookies)，又称为“小甜饼”。类型为“小型文本文件” ---- cookie最大存储空间为4KB

某些网站为了辨别用户身份而存储在用户本地 终端(Client Side)上的数据

cookie一般由服务器通过响应头进行设置， 也可以通过JS在客户端直接设置对应的cookie，但是在客户端设置对应cookie的方式很少使用

cookie在向对应网站发送对应请求的时候，会自动携带上符合条件的cookie，并不需要手动进行添加

同样，服务端向客户端发送对应的网络请求的时候，客户端也会将对应的cookie自动存储起来，并不需要手动进行干预



#### 分类

Cookie总是保存在客户端中，按在客户端中的存储位置，Cookie可以分为内存Cookie和硬盘Cookie

| 分类       | 说明                                                         | 设置方式                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内存Cookie | 内存Cookie由浏览器维护，保存在内存中，浏览器关闭时Cookie就会消失，其存在时间是短暂的 | 没有设置过期时间，默认情况下cookie是内存cookie，在关闭浏览器时会自动删除 |
| 硬盘Cookie | 硬盘Cookie保存在硬盘中，有一个过期时间，用户手动清理或者过期时间到时，才会被清理 | 有设置过期时间，并且过期时间不为0或者负数的cookie，是硬盘cookie，需要手动或者到期时，才会删除 |



#### 属性

##### 过期时间

默认情况下的cookie是内存cookie，也称之为会话cookie，也就是在浏览器关闭时会自动被删除

我们可以通过设置expires或者max-age来设置过期的时间：

1. expires:设置的是Date.toUTCString()，也就是对应的值必须是UTC格式字符串，设置格式是;expires=date-in-GMTString-format
2. max-age:设置过期的秒钟，;max-age=max-age-in-seconds (例如一年为60*60*24*365)



##### 作用域

cookie的作用域可以控制向那些域名传递对应的cookie，那些域名不需要传递对应的cookie

`cookie的默认作用域是同一域名下的任意路径地址`

`Domain -- 指定那些主机可以接收对应的cookie`

+ 如果不指定，那么默认是 origin，也就是子域名采用默认的www

  即如果origin为https://www.example.com

  那么访问 https://www.example.com/user/list 的时候，会携带对应的cookie

  而访问 https://chat.example.com 的时候，并不会携带对应的cookie

+ 如果指定Domain，则包含子域名

  如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中(如developer.mozilla.org)

`Path:指定主机下哪些路径可以接受cookie`, 默认值是任意路径

+ 例如，设置 Path=/docs，则以/docs开头的地址都会匹配：
  + /docs
  + /docs/Web/
  + /docs/Web/HTTP



#### 示例

`在客户端设置对应cookie`

```js
// 查看所有的cookie
console.log(document.cookie) // 所有的cookie会被整合成一个字符串并在控制台中打印

// 可以通过document.cookie来设置对应的cookie
document.cookie = 'name=Klaus' // 默认是会话cookie

// 多次通过document.cookie来设置对应的cookie是新增cookie
// 而不是覆盖原始cookie
document.cookie = 'age=23;'

// 通过max-age来设置过期时间 默认单位为s
document.cookie = 'height=1.88;max-age=30'

// 当设置某一个cookie对应的过期时间为0的时候，表示删除对应的cookie
document.cookie = 'name=Klaus;max-age=0'
```



`在服务器设置对应的cookie`

```js
const Koa = require('koa')
const Router = require('@koa/router')

const app = new Koa()
const router = new Router()

router.get('/login', ctx => {
  // 可以通过ctx.cookies.set方法来设置对应的cookie
  // 设置完成后，在接口返回数据的时候，会通过Set-Cookie响应头向客户端设置对应的cookie
  // 参数一 - key
  // 参数二 - value
  // 参数三 - 配置对象 - 可以省略
  ctx.cookies.set('token', 'sdasdasdsafvxvsadsafsd', {
    maxAge: 5 * 1000 // 设置过期时间 默认是会话cookie 单位是ms
  })

  ctx.body = 'login success'
})

router.get('/list', ctx => {
  // 可以通过ctx.cookies.get方法获取对应的cookie
  // 当浏览器请求对应的接口的时候，浏览器会自动将符合对应cookie作用域的cookie通过Cookie请求头传递给服务器
  console.log(ctx.cookies.get('token'))

  ctx.body = 'user list'
})

app.use(router.routes())
app.use(router.allowedMethods())

app.listen(8000, () => console.log('server is running'))
```



### session

Session是基于cookie实现机制，session本质上是对cookie进行加密后的存储方式

在koa中，我们可以借助于 koa-session 来实现session认证

```js
const Koa = require('koa')
const Router = require('@koa/router')
const session = require('koa-session')

const app = new Koa()

const router = new Router()

// 调用session方法生成对应的中间件
// 将生成的中间件注册到app实例上后
// 就可以通过ctx.session来设置和访问对应的session

// session方法需要传递两个参数
// 参数一: 配置对象
// 参数二: app实例 - 也就是session对象需要被挂载到那个对象上
app.use(session({
  // session加密后的key 本质上依旧是通过cookie的方式设置到浏览器中
  // key就是这个cookie的名称
  key: 'sessionId',
  
  // 设置过期时间 默认单位是ms
  // 不设置，对应的session默认是会话session
  maxAge: 5 * 60 * 1000,
  
  // 将对应的cookie设置成httpOnly
  // 默认值 为true
  // 当httpOnly为true的时候，只能通过http方式去设置对应的cookie
  // 也就是说只能通过服务器向客户端进行设置，无法通过JS脚本进行设置
  // 当httpOnly的值为false的时候，既能通过服务器想客户端进行设置，也可以通过JS脚本向客户端进行设置
  httpOnly: true,
  
  // 每次响应后，都刷新cookie对应的有效期
  // 默认值为false
  rolling: true,
  
  // 是否对session进行签名认证 --- 默认值为true
  // 当值为true的时候，就需要通过app.keys设置对应的盐
  // koa-session会通过这些盐和sessionId进行加密后并进行数字签名
  // 生成一个名为sessionId.sig的cookie
  // 也就是说开启签名后，客户端会接收到两个cookie，分别为sessionId和sessionId.sig
  signed: true
}, app))

// 加盐操作
// 所谓加盐操作，就是对明文的前边或后边加上对应的随机字符串
// 这样可以保证即使两个用户输入同一段明文，其生成的对应密文也是不一样的
app.keys = ['klaus', 'Steven', 'Alex']

router.get('/login', ctx => {
  // 向session中添加对应的数据
  ctx.session.token = 'sdasdasfsdfsdfsdwqesf'

  ctx.body = 'login success'
})

router.get('/list', ctx => {
  // 从session中获取对应的数据
  console.log(ctx.session.token)

  ctx.body = 'user list'
})

app.use(router.routes())
app.use(router.allowedMethods())

app.listen(8000, () => console.log('server is running'))
```



### token

1. 虽然在浏览器中可以用浏览器自动来设置和处理对应的cookie和session

   但是在ios或android中，是无法由系统自动来对cookie和session进行处理

2. session是存储在单台服务器上的，无法被其他服务器访问到

   所以在[分布式和集群系统](https://juejin.cn/post/7115343432125513759)中，在多个不同的子系统中验证对应的cookie和session是不容易实现的

3. cookie和session都是只能在同源下进行传输的

   如果两个系统是跨域的，那么这两个系统之间是无法进行cookie和session的共享的

所以为了解决上述的问题，目前采用更多的是使用token来进行身份验证

token可以翻译为令牌，是在验证了用户账号和密码正确的情况，给用户颁发一个令牌

这个令牌作为后续用户访问一些接口或者资源的凭证， 我们可以根据这个凭证来判断用户是否有权限来访问



目前比较常见的生成token的方式`JWT - json web token`

一个完整的token由以下三个部分组成：

![image.png](https://s2.loli.net/2022/12/15/gPx9AkpjqtBHSfy.png) 

1. header - token的头部相关信息

   | key  | value                                                        |
   | ---- | ------------------------------------------------------------ |
   | alg  | 采用的加密算法<br />默认是 HMAC SHA256 (HS256)<br />采用同一个密钥进行加密和解密 - 也就是默认是对称加密 |
   | typ  | JWT，固定值，通常都写成JWT即可                               |

   

2. payload - 携带的一些自定义认证数据
   + 携带的数据，比如我们可以将用户的id和name放到payload中
   + 默认也会携带iat(issued at)，令牌的签发时间
   + 我们也可以设置过期时间:exp(expiration time)



3. signature - 设置一个secretKey，通过将前两个的结果合并后进行HMACSHA256的算法

```shell
# base64Ulr - 表示对参数进行base64编码
# HMACSHA256 - 表示对参数进行 HS356加密
# 所以signature 是对 base64过的header + . + base64过的payload 使用密钥(secretKey) 进行加密后得到的数字签名
# HMACSHA256(base64Url(header) + . + base64Url(payload), secretKey);
```



最终得到的token将会是 `base64Url(header).base64Url(payload).signature`

因为默认情况下JWT生成token采用的是对称加密，所以密钥的安全存储就显得尤为的重要



#### 示例

在koa中，我们可以使用一个第三方库`jsonwebtoken`来生成对应的token

```js
const Koa = require('koa')
const Router = require('@koa/router')
const jwt = require('jsonwebtoken')

const app = new Koa()

const router = new Router()

// 定义密钥
const secretkey = 'p#ss2eew'

router.get('/login', ctx => {
  const payload = {
    id: 23333,
    name: 'Klaus'
  }

  // 通过sign方法生成对应的token
  // 参数一 - payload
  // 参数二 - 密钥 secretkey
  // 参数三 - 配置对象
  const token = jwt.sign(payload, secretkey, {
    // 过期时间 单位: s
    expiresIn: 60
  })

  ctx.body = {
    code: 0,
    token
  }
})

// token可以使用任何方式进行传递，如cookie, body, header等
// 在这里使用了Bearer Token的方式进行token的传递
// 也就是说使用一个名为Authorization的header进行token的传递
// 对应的值为`Bearer ${token}`
router.get('/list', ctx => {
  // 验证JWT的有效性
  try {
    // 从header中取出对应的token
    const token = ctx.header.authorization.replace('Bearer ', '')

    // 对token进行解析，并将解析后的数据返回
    // 参数一 --- token
    // 参数二 --- secretkey
    /*
      =>
        {
          "id": 23333, // -> 自定义数据 用户id
          "name": "Klaus", // -> 自定义数据 用户名
          "iat": 1671097634, // -> 令牌(token)签发时间
          "exp": 1671097694 // -> token过期时间
        }
    */
    ctx.body= jwt.verify(token, secretkey)
  } catch(e) {
    // 如果解析失败，就会抛出对应的异常
    ctx.body = {
      code: -1001,
      message: 'token过期或验证失败'
    }
  }
})

app.use(router.routes())
app.use(router.allowedMethods())

app.listen(8000)
```



但是在上述的示例中，使用的是对称加密体系，也就是加密和解密都使用的是一个密钥

此时也就是意味着在分布式和集群系统中的每一台服务器都存在对应的私钥

也就是说每一台服务器都具备创建并分发对应token的能力

但并不是所有的服务器需要具备这样的能力，并且这大大增加了系统安全风险

所以在实际开发中，我们往往会使用非对称加密算法来生成对应的token，常见的算法是 RSA256

`使用RSA256生成对应的私钥和公钥`

```shell
# openssl 一个安全加密库
# 该库中存放了大多数常见的安全加密算法和散列算法
openssl

# 生成一个RSA私钥 放入名为private.key
# 1024 表示生成的密钥长度为1024位
> genrsa -out private.key 1024

# 使用private.key生成对应的公钥，并将对应的内容写入public.key中
> rsa -in private.key -pubout -out public.key
```

```js
const fs = require('fs')
const Koa = require('koa')
const Router = require('@koa/router')
const jwt = require('jsonwebtoken')

const app = new Koa()

const router = new Router()

// require默认情况下只能加载和读取js和json文件
// 对于其余文件需要 需要使用fs模块进行加载
const privateKey = fs.readFileSync('./key/private.key')
const publicKey = fs.readFileSync('./key/public.key')

router.get('/login', ctx => {
  const payload = {
    id: 23333,
    name: 'Klaus'
  }

  const token = jwt.sign(payload, privateKey, {
    expiresIn: 60,
    // 使用哪种加密算法 -- 注意这里是RS256 不是RSA256
    algorithm: "RS256"
  })

  ctx.body = {
    code: 0,
    token
  }
})

router.get('/list', ctx => {
  try {
    const token = ctx.header.authorization.replace('Bearer ', '')
    console.log(token)
    ctx.body= jwt.verify(token, publicKey)
  } catch(e) {
    ctx.body = {
      code: -1001,
      message: 'token过期或验证失败'
    }
  }
})

app.use(router.routes())
app.use(router.allowedMethods())

app.listen(8000)
```



