## 字符串

1. 使用字符串，一律使用 双引号，可以通过`singleQuote`选项进行配置
2. JSX也有自己单独的`jsxSingleQuote` => 在JSX中，JS使用单引号，HTML部分使用双引号
3. 中文和emoji 不会被转移为 unicode编码



## 空行

1. prettier会保留源文件中的空行
1. 多个空白行 会被合并为 一个
1. 每个文件最终都会以一个独立的换行结尾



## 对象

prettier对对象的格式化是半自动的，因为prettier并没有确定那种格式化方式更合理

```js
const user = {  name: "John Doe",
  age: 30
};

// 格式化后
const user = { name: "John Doe", age: 30 };
```

```js
const user = {
 name: "John Doe", age: 30 };

// 格式化后
const user = {
  name: "John Doe",
  age: 30,
};
```



## 装饰器

prettier不会修改装饰器的位置

除了类装饰器，prettier总是将装饰器放到类声明之前的单独一行

```ts
@observer // 这个装饰器 一定单独位于类前，并独立成行
class OrderLine {
  @observable price: number = 0;
  @observable
  amount: number = 0;
}
```



## 分号

1. prettier默认不省略JS行尾的分号

2. 可以通过`noSemi` 选项 关闭 默认插入分号 这个行为

3. 即便开启了`noSemi` 选项，prettier仍然会在必要的地方插入分号以避免代码解析错误

   ```js
   if (shouldAddLines) {
     [-1, 1].forEach(delta => addLine(delta * 20))
   }
   
   // Prettier 格式化后
   if (shouldAddLines) {
     ;[-1, 1].forEach(delta => addLine(delta * 20))
   }
   ```

   但自动插入分号行为，有一个使用前提，语法必须是正确的，否则在转换为AST时，无法被prettier正确识别

   ```ts
   // 原始代码，忘记添加分号
   console.log('Running a background task')
   (async () => {
     await doBackgroundWork()
   })()
   
   // Prettier 格式化后的代码，显示实际行为，但不会修复逻辑错误
   console.log("Running a background task")(async () => {
     await doBackgroundWork();
   })();
   ```

   

## printWidth

`printWidth`表示一行最大长度 --- 这个是用户自主配置选项

在一行文本超出`printWidth`时，prettier会自主判断能否换行

+ 可以换行，prettier会自主换行
+ 不能转换 (如模板字符串中的文本)， prettier会保持原样，不进行任何处理

但也有特殊情况，

1. 在import导入值的时候

```js
// 导入多个内容，超出printWidth 会自动换行
import {
  CollectionDashboard,
  DashboardPlaceholder,
} from "../components/collections/collection-dashboard/main";
```

```js
// 导入单个内容，即使超出了printWidth，也不会自动换行
import { CollectionDashboard } from "../components/collections/collection-dashboard/main";
```

2. 如果引入了单元测试中的一些测试函数，即便这些函数的调用程度超过了`printWidth`, 也不会换行，因为测试函数对代码阅读的意义不大



## JSX

Prettier 在处理 JSX 时通常会在 JSX 元素外面包裹一层小括号，并且在 JSX 和小括号之间进行换行处理

```jsx
function greet(user) {
  return user
    ? `Welcome back, ${user.name}!`
    : "Greetings, traveler! Sign up today!";
}

function Greet({ user }) {
  return (
    <div>
      {user ? ( 
        <p>Welcome back, {user.name}!</p>
      ) : (
        <p>Greetings, traveler! Sign up today!</p>
      )}
    </div>
  );
}
```



## 注释

注释可以包含任何内容，且位于任何位置

prettier在格式化时，不会对其进行任何处理

JSDoc 风格的注释是一个例外，Prettier 会修正这些注释的缩进

其次，可能因为prettier的格式化，导致魔法注释「有特殊功能的注释」失效，此时需要手动移动魔法注释，确保其生效

```js
// eslint-disable-next-line no-eval
const result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
```

`格式化后`

```js
// eslint-disable-next-line no-eval --> 魔法注释失效
const result =
  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
```

`手动调整后`

```js
const result =
  // eslint-disable-next-line no-eval
  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);
```



### 魔法注释

1. 在格式上看起来和普通注释没有区别
2. 但它们包含特殊的语法或关键字，这些被工具如编译器、解释器或代码分析工具所识别，并触发一些特殊的行为或操作
3. 魔法注释给编写者提供了一种方式来影响编辑器的行为，如关闭某个规则的检查



## 语法提案

prettier会尽可能对语法提案进行格式化操作，但这是非标准且是实验性的，所以可能在不同版本中存在不同的行为



## 语法层面格式化

prettier只进行展示层面的格式化处理，并不处理语法层面的格式化处理 

如以下情况，prettier是不会处理的

1. 长字符串 转换为 字符串拼接并换行处理，以适应于`printWidth`
2. 三元运算符 转换为 if-else 格式
3. 
4. 。。。。