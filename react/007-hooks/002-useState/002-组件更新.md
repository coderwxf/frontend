## 延时更新

函数组件触发更新，本质就是重新执行一遍函数，生成一个全新的函数执行上下文



对于`useState`而言

1. 状态值
   + 第一次 --- 返回初始值
   + 第二次 --- 返回最新的状态值
2. 状态更新函数
   + 每次都是全新的函数

```jsx
import React, { useState } from "react";

export default function Demo(props) {
    let [num, setNum] = useState(10);
    const handler = () => {
        setNum(100);
        setTimeout(() => {
            console.log(num); // => 10
        }, 1000);
    };
    return <div>
        <span>{num}</span>
        <button onClick={handler}>新增</button>
    </div>;
};
```

`setNum`调用后，会开启一个全新的执行上下文  --- 新的执行上下文中是新的状态

但是定时器中的打印执行时，是在第一个执行上下文 --- 旧的执行上下文中是旧的状态

因此 在定时器中输出的num的值是10，即更新前的状态



## 整体更新

可以和类组件一样，将所有的状态定义到一个对象中，统一进行管理

但和`setState`不一样的是，`useState`不支持批量更新，也就是不会和原本状态对象执行`Object.assign`

```jsx
import React, { useState } from "react";
export default function Demo(props) {
    let [state, setState] = useState({
        x: 10,
        y: 20
    });
    const handler = () => {
        // 不支持批处理，所以需要浅拷贝之前所有的状态后，再进行状态更新
        setState({
            ...state,
            x: 100
        });
    };
    return <div>
        <span>{state.x}</span>
        <span>{state.y}</span>
        <button onClick={handler}>处理</button>
    </div>;
};
```

较为推荐的解决方法是 `把不同状态分开进行管理, 一个状态使用一个useState`



