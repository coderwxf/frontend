## 基本使用

在函数组件中使用状态，修改状态值可让函数组件更新，类似于类组件中的setState

`const [state, setState] = useState(initialState);`

1. `initialState`是初始值
2. 返回一个数组，组成是`[状态值，状态更新函数]`
3. 执行状态更新函数后，会执行
   + 状态更新
   + 视图更新



```jsx
import { useState } from "react";

export default function Demo(props) {
    let [num, setNum] = useState(10);
    
    return <div>
        <span>{num}</span>
        <button onClick={() => setNum(num + 1) }>新增</button>
    </div>;
};
```



## 性能优化

使用`useState`更新状态值时, 会使用`Object.is方法`将新旧状态进行比较

如果发现两次的值是一样的，则立即终止后续更新流程，也不会生成新的VDOM

这个行为类似于`PureComponent`中`shouldComponentUpdate`的默认实现

```jsx
import { useState } from "react";

export default function Demo(props) {
    console.log('RENDER渲染')
    let [num, setNum] = useState(10);

    return <div>
        <span>{num}</span>
        <button onClick={() => setNum(10) }>新增</button>
    </div>;
};
```

点击按钮时候，没有任何的打印输出，也就说明组件并没有触发更新流程



## 函数更新

`useState`的使用和`this.setState`完全一致，也支持传入函数

```jsx
import { useState } from "react";

export default function Demo(props) {
    // 状态是批处理更新，所以只有一次打印输出
    console.log('RENDER渲染');
    let [num, setNum] = useState(10);

    const handle = () => {
      for (let i = 0; i < 10; i++) {
        setNum(prev => {
          // 第一次pre的值是状态初始值
          // 第二次pre的值是上一个setX中callback返回的最新状态值
          console.log(prev);
          return prev + 1;
        });
      }
    };

    return <div>
        <span>{num}</span>
        <button onClick={handle}>新增</button>
    </div>;
};
```



## 惰性初始化

`useState`可以传入一个回调函数，初始值只在首次渲染时有用，所以`useState`传入的回调也只会在首次渲染时被执行

这非常适合于初始state需要经过某些复杂计算后才能获得最终值的情况

```jsx
import { useState } from "react";
export default function Demo(props) {
    let [num, setNum] = useState(() => {
        let { x, y } = props;
        return x + y;
    });
    return <div>
        <span>{num}</span>
    </div>;
};
```

