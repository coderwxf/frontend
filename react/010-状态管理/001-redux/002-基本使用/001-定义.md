## 行为对象

一个有`type`属性的对象，其中的`type`属性被称之为行为标识



## 基本使用

定义在redux的状态不能直接修改，而是应该通过reducer来修改

如果直接在组件中修改redux中的状态，会导致修改状态的逻辑遍布于整个项目，不利于代码后期维护

所以对于redux中状态的修改，需要统一定义在reducer中

每个组件通过dispatch action通知reducer修改对应状态

```js
import { createStore } from 'redux';

// 定义初始状态
const initialState = {
  count: 0
}

// const reducer = (state, action) => state
// 参数一: 需要存储的公共状态
// 参数二: 通过dispatch派发的行为对象 
const reducer = (state = initialState, action) => {
  /*
  	1. 基于行为标识修改状态
  	2. 整个reducer需要返回一个全新的状态，用于替换公共容器中存储的状态值
  	3. 需要克隆一个新的state进行修改，reducer需要是纯函数
  		 --- redux通过对新旧state的地址进行比较来判断是否需要执行事件池中的事件
  */ 
  switch (action.type) {
    case 'INCREMENT':
      return {
        ...state,
        count: state.count + 1
      };
    case 'DECREMENT':
      return {
        ...state,
        count: state.count - 1
      };
    default:
      return state;
  }
};

// 创建Store --- 创建一个公共容器
const store = createStore(reducer);

export default store;
```



## 状态初始化

初始执行的时候，公共存储区域内部的状态值是`undefined`



`redux`会在内部自动执行一次`dispatch`, 派发的行为标识是随机数

`type`没有任何配对，执行`switch-case`中`default`逻辑块



所以`reducer`中`switch-case`语句必须存在`default`逻辑块，且该逻辑块必须仅返回`state`本身

从而实现redux状态的初始化

```jsx
function getRandom() {
return Math.random().toString(36).substring(7).split('').join('.')
}

dispatch({
  // type是随机的，确保执行的是reducer的默认逻辑
  type: `@@redux/INIT${getRandom()}`
})
```



## dispatch

```js 
import { createStore } from 'redux';

const initialState = {
  count: 0
}

/*
  后续派发，就类似于
  dispatch({
    type: 'INCREMENT',
    。。。。
  })
  此时就会匹配到对应的行为标识，并使用修改后的状态，替换公共状态区域中的状态
*/
const reducer = (state = initialState, action) => {
  switch (action.type) {
    // 派发的事件名，一般全大写，多个单词之间使用下划线分割 
    // 之所以派发事件名需要使用大写，因为需要在多个文件中使用 -- 可以单独抽取到常量文件中
    case 'INCREMENT':
      return {
        ...state,
        count: state.count + 1
      };
    case 'DECREMENT':
      return {
        ...state,
        count: state.count - 1
      };
    default:
      return state;
  }
};

const store = createStore(reducer);

export default store;
```



###   参数传递

```js
dispatch({
  type: 'INCREMENT',
  setp: 10
})
```

但如果参数过多，可能层次关系不是那么明显

所以使用更多的方式是

```js
dispatch({
  type: 'INCREMENT',
  payload: {
    setp: 10
  }
})
```



