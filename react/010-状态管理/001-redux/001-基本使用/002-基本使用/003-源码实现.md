```js
/* 实现redux的部分源码 */
export function createStore(reducer) {
  if (typeof reducer !== 'function') {
    throw new Error("Expected the root reducer to be a function")
  }

  let state,  // 存放公共状态
  listeners = [] // 事件池

  // 获取公共状态
  function getState() {
    return state
  }

  // 当状态更新后，需要执行的回调函数
  function subscribe(cb) {
    if (typeof cb !== 'function') {
      throw new Error('Expected the listener to be a function')
    }

    if (!listeners.includes(cb)) {
      listeners.push(cb)
    }

    // 清理函数
    return function unsubscribe() {
      let index = listeners.indexOf(cb)
      listeners.splice(index, 1)
  	}
  }

  // 派发任务
  function dispatch(action) {
    if (action === null || typeof action !== 'object') {
      throw new TypeError("Actions must be plain objects")
    }

    if (typeof action.type !== 'string') {
      throw new Error('action.type must be string')
    }

    // 把公共状态和行为对象传递给reducer，让reducer根据行为对象的type属性，返回新的状态
    state = reducer(state, action)

    // 通知所有的订阅者 --- 依次执行事件池中对应方法
    listeners.forEach(listener => listener())

    // ??????
    return action
  }

  // 这里可以使用唯一symbol值进行替代
  function getRandom() {
    return Math.random().toString(36).substring(7).split('').join('.')
  }

  // redux内部会默认进行一次dispatch派发，目的：给公共容器中的状态赋值初始值
  dispatch({
    // type是随机的，确保执行的是reducer的默认逻辑
    type: `@@redux/INIT${getRandom()}`
  })

  // 返回创建的store对象
  return {
    getState,
    subscribe,
    dispatch
  }
}
```

