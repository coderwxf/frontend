React 会维护一个合成事件对象池，以提高性能和减少内存分配的次数

当一个事件触发时，React 会从池中取出一个合成事件对象，并将原生事件的属性赋值给这个合成事件对象

合成事件对象在事件处理函数执行完毕后会被重置并放回对象池，以便下次事件触发时重复使用

这就导致了在异步回调中，可能无法正确访问合成事件对象，因此此时合成事件对象已被重置并释放

```jsx
<div onClick={e => {
    // 从事件对象池中获取合成事件对象，并进行初始化操作后赋值给 e
    console.log(e.type) // => click

    setTimeout(() => {
      // 此时合成事件对象已经被清空，所以 e.type 为 null
      console.log(e.type) // => null
    }, 5000)

    // 函数执行完毕后，会将合成事件对象清空后，再次存储到事件对象池
  }}
/>
```



为了解决这个问题，react提供了`e.persist()` 方法,

调用该方法后，react将保留合成事件对象，而不是重置它

保留的合成事件对象会在不使用后，被浏览器GC回收

```jsx
<div onClick={e => {
    console.log(e.type) // => click

    setTimeout(() => {
      // 此时合成事件对象中值被保留下来了
      console.log(e.type) // => click
    }, 5000)

    // 为了阻止合成事件对象被执行清空操作，可以使用 e.persist() 方法
    e.persist()
  }}
/>
```



在现代浏览器中，合成事件对象池对react的性能优化已经意义不大，所有在React18中，已经移除了事件对象池，每次都会生成新的独立的合成事件对象

```jsx
<div className='inner' onClick={e => {
    console.log(e.type) // => click

    setTimeout(() => {
      console.log(e.type) // => click
    }, 5000)
  }}
/>
```

