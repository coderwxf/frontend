## 执行流程

1. 在解析VDOM的时候，如果遇到onXxx 或 onXxxCapture 会将对应事件作为VDOM的属性进行绑定

   其中 onXxx 或 onXxxCapture 被称之为 合成事件属性

   注意:

   - 仅仅只是属性赋值，不是事件绑定
   - 既不是DOM0级事件绑定 「 onxxx - 全小写 」 也不是DOM2级事件绑定 「 addEventListener 」

   ```js
   // 伪代码
   inner.onClick = () => console.log('click buddle')
   inner.onClickCapture = () => console.log('click capture')
   ```

   

2. 渲染为真实DOM的时候，将对应的事件处理函数挂载到#root上

   因为 #root 元素 是容器元素，是所有JSX元素的父元素

   ```js
   const root = document.querySelector('.root')
   const outer = document.querySelector('.outer')
   const inner = document.querySelector('.inner')
   
   outer.onClick = () => console.log('outer buddle')
   inner.onClick = () => console.log('inner buddle')
   
   outer.onClickCapture = () => console.log('outer capture')
   inner.onClickCapture = () => console.log('inner capture')
   
   root.addEventListener('click', e => {
     // compose - 组成
     console.log(e.composedPath())
     // e.composedPath() -> 用于获取事件的传播路径(冒泡阶段) -> 从最内层元素到最外层元素
     // 即传播路径为 inner -> outer -> root -> body -> html -> document -> window
     const path = [...e.composedPath()]
   
     // 执行捕获阶段的事件处理函数
     path.reverse().forEach(el => {
       // 默认函数调用 -> 模块和类在解析时会自动开启严格模式 -> 函数内部this是undefined
       el.onClickCapture?.()
     })
   }, true)
   
   root.addEventListener('click', e => {
     const path = [...e.composedPath()]
   
     path.forEach(el => {
       el.onClick?.()
     })
   })
   ```


