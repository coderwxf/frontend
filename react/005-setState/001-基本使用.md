```jsx
import { Component } from 'react'

export default class App extends Component {
  state = {
    count: 18,
    total: 30
  }

  shouldComponentUpdate() {
    return false
  }

  render() {
    const { count } = this.state
    return (
      <>
        <div>{ count }</div>
        <button onClick={() => this.add()}>add count</button>
      </>
    )
  }

  add() {
    // this.setState(partialState, callback)
    // 1. partialState 更新的状态
    //    + 可以是部分的，也可以是全部的
    //    + 会和原来的状态执行Object.assign操作

    // 2. callback 状态更新完毕后的回调函数
    //    + 会在componentDidUpdate之后，DOM更新前执行
    //    + 无论状态是否更新成功，都会执行 -- 类似于Vue中的$nextTick
    //      在事件队列中，执行完一个宏任务，并清空微任务队列 被称之为一个tick
    //      $nextTick和this.setState的callback都是在下一个tick一开始执行
    //      此时可以确保
    //        1. VDOM已经更新完毕 -- 可以获取更新后的状态
    //        2. 即使SCU返回false -- componentDidUpdate不会执行，但是callback依旧会执行
    this.setState({
      count: this.state.count + 1
    }, () => {
      console.log(this.state.count)
    })
  }

  // 1. setState的callback可以在指定状态发生改变后，才被回调
  // 2. componentDidUpdate会在任意状态发生改变后，被回调
  componentDidUpdate() {
    console.log('componentDidUpdate')
  }
}
```



## 批处理机制

在React18中，只要遇到`setState`修改状态，就会将状态更新加入到一个更新队列`updater`中(或者叫渲染队列`updater`)

在下一次`tick`一开始执行的时候统一进行更新，这种更新机制被称之为React的批处理机制 「也就是说setState更新操作都是异步的」

好处是:  

降低视图更新频率，提升了性能 「 同步渲染会在状态更新完毕后，将所有生命周期走一遍后，再进行下一个状态更新，非常消耗性能 」



### setState vs nextTick

1. `setState`会将更新操作放入到`updater`队列，具体的执行流程取决于react自身内部实现 「 在表现上，多数情况下，setState的回调会在执行微任务队列的时候被执行 」
2. `nextTick`会被插入到下一个`tick`周期的微任务队列中，从而确保执行`nextTick`回调时，可以获取到更新后的DOM元素
   + tick周期 = 一个宏任务执行 + 清空微任务队列 + 可能需要执行的DOM更新



## 老版本setState

在React18中，一切setState都是异步操作

在React16中

- 在像合成事件，生命周期等由React控制的上下文中，setState是异步的
- 在像定时器，原生DOM事件监听等非React控制的上下文中，setState是同步的 「 立即更新状态并重新更新视图 」