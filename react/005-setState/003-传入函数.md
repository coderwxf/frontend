`setState`异步更新，多次操作的state会被合并为一个对象，并进行批处理更新

```jsx
import { PureComponent } from 'react'

export default class App extends PureComponent {
  state = {
    count: 0
  }

  render() {
    // 数据更新后render只会被触发一次
    console.log('render')

    const { count } = this.state

    return (
      <>
      	{/* count的值是1, 不是2，也不是60 */}
        <div>{ count }</div>
        <button onClick={() => this.add()}>add</button>
      </>
    )
  }

  add() {
    // 最后合并的时候，会将多次更新执行Object.assign操作 合并成一个更新对象
    for (let i = 0; i < 20; i++) {
      // 像updater队列中插入 { count: 0 + 2 }
      this.setState({
        count: this.state.count + 2
      })
      
      // 像updater队列中插入 { count: 0 + 1 }
      this.setState({
        count: this.state.count + 1
      })
    }
  }
}
```



可以通过`flushSync`开启`setState`的强制同步更新

```jsx
import { PureComponent } from 'react'
import { flushSync } from 'react-dom'

export default class App extends PureComponent {
  state = {
    count: 0
  }

  render() {
    // 数据更新后，render方法会被回调20次
    console.log('render')

    const { count } = this.state

    return (
      <>
	      {/* count的值是20  */}
        <div>{ count }</div>
        <button onClick={() => this.add()}>add</button>
      </>
    )
  }

  add() {
    for (let i = 0; i < 20; i++) {
      this.setState({
        count: this.state.count + 1
      })

      // 强制同步更新
      flushSync()
    }
  }
}
```



如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState

该函数将接收先前的 state，并返回一个更新后的值

从而确保 在保证状态是叠加更新的前提下，界面只更新渲染一次

```jsx
import { PureComponent } from 'react'

export default class App extends PureComponent {
  state = {
    count: 0
  }

  render() {
    // 数据更新后render只会被触发一次
    console.log('render')

    const { count } = this.state

    return (
      <>
      	{/* count的值是20, 不是1 */}
        <div>{ count }</div>
        <button onClick={() => this.add()}>add</button>
      </>
    )
  }

  add() {
    // 每次存入updater中的都是函数
    // 第一个callback被调用时，会将this.state作为参数传入
    // 后续callback被调用是，会将上一次callback的返回值作为参数传入
    for (let i = 0; i < 20; i++) {
      // setState的第一个参数可以是函数
      // 1. 参数是之前的state
      // 2. 函数需要返回一个对象，作为新的state 「 依旧可以只修改部分state 」
      this.setState(preState => ({
        count: preState.count + 1
      }))
    }
  }
}
```

