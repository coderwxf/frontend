## createElement

```js
export function createElement(elem, props = {}, ...children) {
  const vdom = {
    $$typeof: Symbol('react.element'),
    ref: null,
    key: null,
    type: elem,
    props
  }

  if (children.length) {
    vdom.props.children = children.length === 1 ? children[0] : children
  }

  return vdom
}
```



## render

```jsx
// 渲染伪代码 -- 只考虑非组件情况
export function render(vdom, container) {
  const { type, props } = vdom
  const el = document.createElement(type)
  const { children, ...attrs } = props

  // 属性处理
  Reflect.ownKeys(attrs).forEach(attr => {
    if (attr === 'className') {
      el.setAttribute('class', attrs[attr])
    } else if (attr === 'htmlFor') {
      el.setAttribute('for', attrs[attr])
    } else if (attr === 'style') {
      // 处理样式对象
      Reflect.ownKeys(attrs.style).forEach((value, key) => {
        el.style.key = value
      })
    } else {
      el.setAttribute(attr, attrs[attr])
    }
  })

  if (children) {
    if (/^(string|number)$/.test(typeof child)) {
      // 文本节点 --- 使用createTextNode创建文本节点，避免覆盖el中原本的子节点
      el.appendChild(document.createTextNode(children))
    } else if (Array.isArray(children)) {
      // 数组节点 -- 仍就是子元素，递归渲染
      children.forEach(child => {
        render(child, el)
      })
    }
  }

  container.appendChild(el)
}
```

