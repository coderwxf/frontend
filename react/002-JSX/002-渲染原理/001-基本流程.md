## 基本流程

1. UI（JSX） -> VDOM
2. VDOM -> DOM



第一次渲染:

1. 缓存生成的VDOM，标记为旧VDOM
2. 将VDOM渲染成真实DOM



第二次渲染:

1. 生成新的VDOM，标记为新VDOM 「全部重新编译」
2. 将旧VDOM 和 新VDOM 进行 比较，找到两次视图更新差异部分
   - 这个比较过程 被称之为 DOM-DIFF
   - 这个更新差异部分 被称之为 PATCH 补丁包
3. 更新并渲染PATCH包，实现页面的重新渲染「页面更新」



## 协调（Reconciliation）

协调（Reconciliation）是React用来将虚拟DOM（VDOM）与真实DOM同步的过程

这个过程涉及到比较前后两次虚拟DOM的差异，并且只更新那些需要改变的部分到真实的DOM中

这种方法有效减少了对DOM的操作数量，从而提高了应用的性能和响应速度



## JSX -> VDOM

1. 基于 babel-preset-react-app 把JSX编译为 React.createElement(...) 这种格式
2. 再把 createElement 方法执行，创建出virtualDOM虚拟DOM对象「也有称之为：JSX元素、JSX对象、ReactChild对象... 」



## babel-preset-react-app 

babel-preset-react-app 是 @babel/preset-react + @babel/preset-typescript + @babel/preset-env的集合

![image-20240505120853582](https://s2.loli.net/2024/05/05/GJhRbBic85dXlLp.png) 



##  React.createElement

只要是元素节点（包括原生HTML标签和自定义组件），必然会基于createElement进行处理



`React.createElement(ele, props, ...children)`

+ ele：元素标签名「或组件名」
+ props：元素的属性集合(对象)「如果没有设置过任何的属性，则此值是null」
+ children：第三个及以后的参数，都是当前元素的子节点 「如果没有子节点，则没有第三个参数」



## vdom

虚拟DOM对象：框架自己内部构建的一套对象体系（对象的相关成员都是React内部规定的）

基于这些属性描述出，我们所构建视图中的，DOM节点的相关特征

**所以虚拟 DOM 是一个轻量的 JavaScript 对象，它是真实 DOM 的一个抽象**

```jsx
virtualDOM = {
  $$typeof: Symbol(react.element), // 一个symbol值 标志该对象是一个VDOM
  ref: null,
  key: null,
  type: Symbol(react.fragment), // 节点类型
  // props中 存放了 所有 属性(props) 和 子节点信息(children)
  // 如果即没有props也没有children 则props为 {} --- props一定是一个对象
  props: { 
      className: "title",
      // 1. 如果只有一个子节点，children是一个对象/字符串
      // 2. 如果有多个子节点，children是一个数组
      // 3. 如果没有子节点，则没有children属性 --- children的值是undefined
      children: 'hello world'
  }
}
```



## 渲染方式

 v16

```jsx    
ReactDOM.render(
  <>...</>,
  document.getElementById('root')
);
```



v18

```jsx
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <>...</>
);
```
