## 生命周期函数

生命周期指的是组件从被创建到被插入DOM、进行更新、然后最终从DOM中移除的整个过程

在这个过程中，开发者可以利用生命周期的各个阶段提供的回调函数（或称“生命周期方法”，“生命周期钩子”）执行特定的代码来处理副作用或执行其他任务

1. 是一系列回调函数

2. 这个回调函数 会在组件运行到某个状态节点的时候 被组件自己调用 

   「 这也就是为什么生命周期函数被称之为生命周期钩子 」

3. 我们可以通过实现这些函数，来在组件运行的某个特定阶段 执行自定义操作



##  更新方式

1. 自更新 
   + 组件内部state发生更新，而触发的更新
2. 外部引发的更新
   + 父组件重新渲染，导致其所有子组件也都要重新渲染
   + 父组件传入的props发生了更新，而导致组件发送更新



## 首次渲染

组件首次挂载会依次调用如下三个生命周期钩子

1. UNSAFE_componentWillMount --- 组件即将被挂载
2. render --- 组件挂载中
3. componentDidMount --- 组件挂载完成



## 更新

### 自更新流程

1. 执行`shouldComponentUpdate` 「 简称SCU 」
2. 执行`UNSAFE_componentWillUpdate` --- 组件即将更新
3. 更新state和props
4. render --- 组件更新中
5. `componentDidUpdate` --- 组件更新完成

```jsx
// SCU在实际渲染前被回调 --- 内部的state和props是旧的，新的state和props由参数传入
shouldComponentUpdate(nextProps, nextState) {
  console.log('shouldComponentUpdate')
  return nextState.count !== this.state.count
}

// 在实际渲染前被回调 --- 内部的state和props是旧的，新的state和props由参数传入
UNSAFE_componentWillUpdate(nextProps, nextState) {
  console.log('UNSAFE_componentWillUpdate')
}

// 在实际渲染之后被回调 --- 内部的state和props是新的，旧的state和props由参数传入
componentDidUpdate(prevProps, prevState) {
  console.log('componentDidUpdate')
}
```



#### shouldComponentUpdate

1. 返回布尔值
2. 在组件更新之前被回调



SCU用来判断组件是否实际需要更新, 返回false则不会更新，返回true则会更新

如果SCU返回false，视图更新流程将被立即中止

1. 后续生命周期钩子将不会再被调用

2. 新的VDOM压根不会生成，DOM-DIFF也不会发生, 从而提升了性能

3. 但有个特例，`forceUpdate`会跳过SCU的检测，而是直接从`componetWillUpdate`开始执行

   

### 父组件触发更新

1. `UNSAFE_componentWillReceiveProps` --- 已使用`getDerivedStateFromProps`替代
2. 组件的自更新渲染流程

也就是说父组件更新相比自更新而言，会多回调一个生命周期钩子



## 卸载

1. `componentWillUnmount`
2. 组件被卸载



## 总结

**挂载阶段:** ---  首次渲染

+ `constructor()`  --- 会在挂载阶段被回调，进行初始化操作，`constructor()`本身不属于生命周期钩子的一部分
+ `static getDerivedStateFromProps()`
+ `render()`
+ `componentDidMount()`



**更新阶段:** --- 当组件的`props`或`state`发生变化时触发

+ `static getDerivedStateFromProps()`
+ `shouldComponentUpdate()`
+ `render()`
+ `getSnapshotBeforeUpdate()`
+ `componentDidUpdate()`



**卸载阶段:** --- 组件卸载

+ `componentWillUnmount()`
