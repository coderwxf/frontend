## getSnapshotBeforeUpdate

1. 在组件DOM更新之前被回调

2. 返回的对象会作为`componentDidUpdate`的第三个参数被传入

   所以`getSnapshotBeforeUpdate`一般需要和`componentDidUpdate`一起使用，否则将没有实际意义

```jsx
class List extends React.Component {
  constructor(props) {
    super(props);
    this.listRef = React.createRef();
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    if (prevProps.items.length < this.props.items.length) {
      const list = this.listRef.current;
      return list.scrollHeight - list.scrollTop;
    }
    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    if (snapshot !== null) {
      const list = this.listRef.current;
      // 在数据列表更新时，确保滚动位置不发生变动
      list.scrollTop = list.scrollHeight - snapshot;
    }
  }

  render() {
    return (
      <ul ref={this.listRef}>
        {this.props.items.map(item => <li key={item}>{item}</li>)}
      </ul>
    );
  }
}
```



## getDerivedStateFromProps

1. 当某个状态需要通过props进行派生的时候，可以使用这个方法
2. 这是一个静态方法

```jsx
class App extends React.Component {
  state = {
    name: 'sachin'
  }

  change() {
    this.setState({
      name: 'Alex'
    })
  }

  render() { 
    return ( 
      <div> 
        <Child name={this.state.name} /> 
        <button onClick={() => this.change()}>click me</button>
      </div> 
    ) 
  } 
} 

class Child extends React.Component{ 
  constructor(props) { 
    super(props); 
    
    this.state = { 
      name: "kapil",
      age: 23
    }; 
  } 

  static getDerivedStateFromProps(props, state) { 
    if (props.name !== state.name) { 
      // 根据props返回一个新对象，这个对象会和原本state进行Object.assign操作
      return { 
        name: props.name 
      }; 
    } 
    
    // 返回null，什么都不会执行
    return null; 
  } 

  render() { 
    return ( 
      <div>
        <div>My name is {this.state.name}</div> 
        <div>My age is {this.state.age}</div>
      </div>
    ) 
  } 
}
```

