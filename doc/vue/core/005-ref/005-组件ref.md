```html
<Child ref="child" />
```

ref用在组件上，获取到的是组件实例对象



如果一个子组件使用的是选项式 API 或没有使用 `<script setup>`

父组件对子组件的每一个属性和方法都有完全的访问权



使用了 `<script setup>` 的组件是**默认私有**的

一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西

除非子组件在其中通过 `defineExpose` 宏显式暴露

```vue
<script setup>
import { ref } from 'vue'

const a = 1
const b = ref(2)

// 像 defineExpose 这样的编译器宏不需要导入
defineExpose({
  a,
  b
})
</script>
```

当父组件通过模板引用获取到了该组件的实例时，得到的实例类型为 `{ a: number, b: number }`



## 类型标注

```ts
const modal = ref<InstanceType<typeof MyModal> | null>(null)
```

1. typeof MyModal -> 拿到组件类类型 
2. 再通过InstanceType获取组件实例的类型



如果组件的具体类型无法获得，或者你并不关心组件的具体类型，那么可以使用 `ComponentPublicInstance`。这只会包含所有组件都共享的属性，比如 `$el`

```ts
import { ref } from 'vue'
import type { ComponentPublicInstance } from 'vue'

const child = ref<ComponentPublicInstance | null>(null)
```



即使是通过`defineExpose`暴露子组件属性和方法，父组件在获取的时候，依旧是通过组件实例的方式去进行类型标注

因为在底层实现上，ref获取的依旧是组件实例，只不过在编译时通过`defineExpose`限定了父组件可以获取的属性和方法